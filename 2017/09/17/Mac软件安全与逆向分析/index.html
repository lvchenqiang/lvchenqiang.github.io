<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lvchenqiang.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lvchenqiang.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/lvchenqiang.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/lvchenqiang.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/lvchenqiang.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/lvchenqiang.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/lvchenqiang.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="笔记,">










<meta name="description" content="Mac软件安全与逆向分析iOS开发中的逆向与安全是经常会提及的事情,本文主要是整理摘选《Mac软件安全与逆向分析》相关涉及到的知识。">
<meta name="keywords" content="笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Mac软件安全与逆向分析">
<meta property="og:url" content="https://lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/index.html">
<meta property="og:site_name" content="程序员码头">
<meta property="og:description" content="Mac软件安全与逆向分析iOS开发中的逆向与安全是经常会提及的事情,本文主要是整理摘选《Mac软件安全与逆向分析》相关涉及到的知识。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190518_16.png">
<meta property="og:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190518_17.png">
<meta property="og:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190518_19.png">
<meta property="og:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190518_18.png">
<meta property="og:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190520_22.png">
<meta property="og:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/snip_004.png">
<meta property="og:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/snip_002.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Mac软件安全与逆向分析//Snip20190522_10.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Mac软件安全与逆向分析//Snip20190522_11.png">
<meta property="og:updated_time" content="2019-05-25T09:51:21.444Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mac软件安全与逆向分析">
<meta name="twitter:description" content="Mac软件安全与逆向分析iOS开发中的逆向与安全是经常会提及的事情,本文主要是整理摘选《Mac软件安全与逆向分析》相关涉及到的知识。">
<meta name="twitter:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190518_16.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/lvchenqiang.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/">





  <title>Mac软件安全与逆向分析 | 程序员码头</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  

  <div class="container  page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/lvchenqiang.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序员码头</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/lvchenqiang.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/lvchenqiang.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/lvchenqiang.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/lvchenqiang.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/lvchenqiang.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lvchenqiang.github.io/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micah">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/lvchenqiang.github.io/image/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员码头">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Mac软件安全与逆向分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-17T22:25:00+08:00">
                2017-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/lvchenqiang.github.io/categories/BOOK/" itemprop="url" rel="index">
                    <span itemprop="name">BOOK</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/09/17/Mac软件安全与逆向分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Mac软件安全与逆向分析"><a href="#Mac软件安全与逆向分析" class="headerlink" title="Mac软件安全与逆向分析"></a>Mac软件安全与逆向分析</h2><p>iOS开发中的逆向与安全是经常会提及的事情,本文主要是整理摘选《Mac软件安全与逆向分析》<br>相关涉及到的知识。<br><a id="more"></a></p>
<h3 id="如何分析MacOS软件"><a href="#如何分析MacOS软件" class="headerlink" title="如何分析MacOS软件"></a>如何分析MacOS软件</h3><h4 id="安装Clang"><a href="#安装Clang" class="headerlink" title="安装Clang"></a>安装Clang</h4><p>如果安装了Xcode,那表明已经默认安装了Clang的编译器。</p>
<p>如果没有,可以直接到LLVM官网下载编译好的Clang,但是这样下载的Clang缺少一个必要的工具。</p>
<p>当然，我们也有更简单的方式，就是启动终端，在终端中输入clang并回车，系统会帮我们检测到我们有没有安装Clang编译器,然后会提示我们是否下载并安装命令行开发者工具。</p>
<h4 id="HT-Editor"><a href="#HT-Editor" class="headerlink" title="HT Editor"></a>HT Editor</h4><p>HT Editor是一个开源跨平台的十六进制编辑器，并且具有强大的反汇编/汇编功能。支持x86、x64、ARM、Power等多种处理器,并支持Windows平台上的PE文件格式、Linux上的ELF格式以及macOS的Mach-O文件格式。</p>
<p>官网:<a href="http://hte.sourceforge.net/" target="_blank" rel="noopener">http://hte.sourceforge.net/</a></p>
<p><img src="/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190518_16.png" alt=""></p>
<p>官网只提供了Windows版本的二进制文件,在Mac上我们可以自己动手编译来生成它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure &amp;&amp; make</span><br></pre></td></tr></table></figure>
<p>编译成功:<br><img src="/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190518_17.png" alt=""></p>
<p>将编译好的ht,放到 <strong>usr/local/bin</strong> 目录下即可。</p>
<p><img src="/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190518_19.png" alt=""></p>
<p>小插曲:<br><img src="/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190518_18.png" alt=""><br>如果报错,找到这个文件将 abs–&gt;fabs即可。</p>
<h4 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h4><p>安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure>
<p>卸载</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd `brew --prefix`</span><br><span class="line"><span class="meta">$</span> rm -rf Cellar</span><br><span class="line"><span class="meta">$</span> brew prune</span><br><span class="line"><span class="meta">$</span> rm `git ls-files`</span><br><span class="line"><span class="meta">$</span> rm -r Library/Homebrew Library/Aliases Library/Formula Library/Contributions</span><br><span class="line"><span class="meta">$</span> rm -rf .git</span><br><span class="line"><span class="meta">$</span> rm -rf ~/Library/Caches/Homebrew</span><br></pre></td></tr></table></figure>
<p>具体的不在介绍,网上相关资料很全。</p>
<p>如果觉得命令行管理软件不太方便,可以尝试基于Homebrew移植的GUI版本,<a href="https://cakebrew.com" target="_blank" rel="noopener">CakeBrew</a>.</p>
<h3 id="系统安全架构"><a href="#系统安全架构" class="headerlink" title="系统安全架构"></a>系统安全架构</h3><h4 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a>架构概述</h4><p>针对于非开发人员的分层方式:</p>
<p><strong>User Experience</strong>:用户体验层,包括DashBoard、Spotlight、Dock、输入法、屏幕保护、语音、位置地图等</p>
<p><strong>Application Framework</strong>:应用框架层,包括Cocoa,用于OS X系统上应用程序的开发。</p>
<p><strong>Graphics and Media</strong>:图形和媒体层.包括核心框架、OpenAL、OpenGL、Quartz、SceneKit、SpriteKit等。</p>
<p><strong>Darwin</strong>:系统核心层 包括系统内核以及shell环境。</p>
<blockquote>
<p><strong>Darwin</strong>(达尔文)是苹果公司开发的基于UNIX实现,它集成了UNIX上一些传统的特性，比如shell环境、目录结构、文件权限等。</p>
</blockquote>
<p>在macOS开发文档中,展示了另一种针对开发人员的分层方式</p>
<p><strong>Cocoa Layer</strong>:Cocoa框架层.包括了用于开发界面程序的框架集合</p>
<p><strong>Foundation Layer</strong>:基础框架层。 提供了程序开发时使用到的基础数据类型、数值处理、网络/文件IO、日期等方方面面的接口。可以说,开发可视的Mac App基本离不开它。</p>
<p><strong>Media Layer</strong>:媒体层. 提供了图像、声音、视频、动画、游戏开发需要的接口。</p>
<p><strong>Core Service Layer</strong>:核心服务层。 提供了系统安全、底层、内部数据访问以及存储的接口。如AddressBook、CoreData等。CoreFoundation框架属于这一层。</p>
<p><strong>Core OS Layer</strong>: 核心系统层 包括加速器、蓝牙、异常处理、网络扩展、系统配置等框架</p>
<p><strong>kernel&amp;Drive Layer</strong>:内核与驱动层。 包括开发设备驱动程序与内核扩展所需的一些框架。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>在UNIX架构的系统中,应用程序无法直接访问系统底层硬件资源，所有的操作最终通过系统调用来进行访问。</p>
<p>系统调用属于内核暴露出的系统调用接口,传统的UNIX定义了一套完整的POSIX调用规范。</p>
<p>macOS系统实现了POSIX标准,并且扩展了部分内容—加入了Mach Trap(Mach 陷阱),取名为xnu.xnu内核是开源的，地址是:<a href="https://opensource.apple.com/source/xnu/" target="_blank" rel="noopener">https://opensource.apple.com/source/xnu/</a></p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>负责进程间通信(IPC)是内核要做的一项重要的工作。传统的UNIX系统都支持通过socket、管道、消息队列、通知、共享内存等方式进行进程间通信。</p>
<p>macOS除了支持上诉通信方式外，还支持一些特殊的通信方式:</p>
<p><strong>Mach端口</strong>:这是一种底层的进程间通信方式,依赖于OSX内核提供的API. </p>
<ul>
<li>消息发送方调用 mach_msg_send()发送消息，消息参数中需要制定要发送的端口号、消息的内容以及类型。</li>
<li>消息接受方调用mach_msg_receive()来接收指定端口的消息。</li>
<li>在上层中,Core Foundation框架提供的CFMachPort以及 Foundation框架提供的NSMachPort堆Mach端口进行封装，以便开发者进行简单的调用。</li>
</ul>
<p><strong>分布式通知</strong>:使用消息发布、订阅对自身通知中心实例进行管理。</p>
<ul>
<li>接收通知的进程在通知中心中注册一个观察者，随后被观察的进程发出通知，观察者可以收到通知并作出响应</li>
<li>这种机制类似于安卓系统的广播组件，另外，发送分布式通知非常耗系统资源，如果应用程序间需要频繁的进行通信，最好选择别的方式。</li>
</ul>
<p><strong>NSConnection</strong>:这是一种比较方便的进程间通信方式。 </p>
<ul>
<li>负责接收处理数据的进程注册一个特定名字的NSConnection</li>
<li>发送数据方使用NSConnection类的rootProxyForConnection-WithRegisterredName()方法找到注册的观察者类，然后通过performSelector()调用该类的数据处理方法。这种通信方式的运作完全得益于Objective-C运行库的工作机制。</li>
</ul>
<p><strong>XPC</strong>:XPC是另一种广泛使用的进程间通信方式,macOS系统本身也大量的使用了该技术</p>
<ul>
<li>使用XPC的一大好处是将App拆分成多个进程,实现代码逻辑的解耦合，使用XPC方式很容易开发出插件式应用程序。</li>
<li>使用XPC的方式与前面的通信方式不同，需要重新为每个功能模块创建一个新的XPC Service,它本质上是一个Bundle包，以.xpc结尾的模块形式存在，存放于XPCServices目录下,最终一起打包到程序包或框架中。</li>
</ul>
<h4 id="安全框架"><a href="#安全框架" class="headerlink" title="安全框架"></a>安全框架</h4><p>安全框架,顾明思义就是提供安全接口的框架。它是系统安全的基础设施，为整个系统提供强有力的安全防护。</p>
<p>新版本的安全框架位于系统的/System/Library/Frameworks/Security.framework目录下，它提供全新的加密算法库(CommonCrypto)、私密内容存储方式(Keychain)和安全的网络通信库。</p>
<h5 id="CommonCrypto"><a href="#CommonCrypto" class="headerlink" title="CommonCrypto"></a>CommonCrypto</h5><p>早期的macOS系统的加解密算法库依赖于OpenSSL，该库近年来颇受安全研究人员关注，大大小小的漏洞层出不穷，CommonCrypto库的问世很大程度上就是为了在加密基础设施上将它替代。</p>
<p>CommonCrypto将常用到的数字摘要算法和对称加密、非对称加密算法，通过SecTransform提供统一的API调用接口,用苹果公司的话说，这是一个更安全、性能更高、对多线程支持更好的库。</p>
<h5 id="Keychain"><a href="#Keychain" class="headerlink" title="Keychain"></a>Keychain</h5><p>安全框架引入了另一种技术-Keychain(钥匙串)。它允许开发者使用系统内置的密钥存储服务来存储一些私密信息,比如密码，密钥、证书等。这些信息会被加密存储到设备中，keychain里保存的信息不会因为APP被删除而丢失，在用户重新安装APP后依然有效，数据依然还在。</p>
<h5 id="安全传输"><a href="#安全传输" class="headerlink" title="安全传输"></a>安全传输</h5><p>在网络中传输隐私数据时,一定要使用安全传输方式，这就确保了数据在传输过程中不被窃取和监听。</p>
<p>苹果引入了一项隐私保护功能ATS(APP Transport Security),它是苹果在推进网络通信安全中的一项重要措施。</p>
<p>苹果的安全框架中实现了HTTPS传输数据依赖网络数据传输协议SSL(Secure Sockets Layer)与TLS(Transport Layer Security).<br>安全传输层比较底层，位于网络库之下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line"></span><br><span class="line">A[Socket :BSD Socket API] --&gt; B[SSLContextRef  :Secure Transport]</span><br><span class="line">B --&gt; C[CFHTTPMessage :CFNetwork]</span><br><span class="line">C --&gt; D[Safari :Application]</span><br></pre></td></tr></table></figure>
<p>应用程序使用如下步骤进行安全传输。<br><strong>预备会话</strong></p>
<ol>
<li>调用SSLNewContext()或SSLCreateContext()创建一个加密会话上下文</li>
<li>调用SSLSetIOFuncs()设置SSLWrite()为IO写方法，SSLRead()为IO读方法</li>
<li>使用CFNetwork、BSD Socket或Open Transport创建一个连接，然后调用SSLSetConnection()为连接指定第一步创建的加密会话上下文</li>
<li>调用SSLSetPeerDomainName()指定端口域名</li>
</ol>
<p><strong>开始会话</strong></p>
<ol>
<li>调用SSLHandhake()执行SSL的握手与连接</li>
</ol>
<p><strong>操作会话</strong></p>
<ol>
<li>安全会话成功建立后,就可以传输数据了。可以调用SSLWrite()向服务器写数据,或者调用SSLRead()从服务器读取数据</li>
</ol>
<p><strong>结束会话</strong></p>
<ol>
<li>通信结束后，可调用SSLClose结束安全会话</li>
<li>关闭连接并释放连接引用</li>
<li>如果连接是使用SSLNewContext()创建的，调用SSLDisposeContext()来销毁安全连接上下文。如果是调用SSLCreateContext(),则调用CFRealease()来释放连接。</li>
<li>如果调用了SSLGetPeerCertificates()获取过任何证书的话，需要调用CFRelease()释放证书引用对象。</li>
</ol>
<h4 id="系统安全机制"><a href="#系统安全机制" class="headerlink" title="系统安全机制"></a>系统安全机制</h4><p>苹果系统并非一个开放的系统,它的安全很大的程度上来源于技术的不公开性。</p>
<h5 id="File-Vault2"><a href="#File-Vault2" class="headerlink" title="File Vault2"></a>File Vault2</h5><p>File Vault2是MacOS系统中使用的一种磁盘加密技术。 新版本的File Vault2通过AES对称加密算法使用128位的密钥对整个磁盘进行加密。加密后的文件以加密的形式存在于磁盘中</p>
<p>未开启磁盘加密的电脑，可以手动打开。通过System Perference(系统偏好设置) -&gt; Security &amp; Privacy(安全与隐私)进行管理。</p>
<p>对于File Vault2加密技术的攻击，已知有三种：<br><strong>旁路攻击</strong>:</p>
<ul>
<li>这种攻击方式针对的主体不是磁盘加密，而是操作系统。</li>
<li>macdestroyer程序会在运行期间向系统中添加一个名为fde_locked_user的用户，并生成一个长度为32的随机密码，然后将该用户添加到具有解锁磁盘权限的用户组，接下来删除掉系统中所有的其他用户，只保留新添加的用户，最后关闭计算机</li>
<li>这样做的后果是，下次启动电脑后，用户就再也无法进入系统，磁盘的数据再也无法访问</li>
</ul>
<p><strong>内存攻击</strong>:</p>
<ul>
<li>启用File Vault2加密即使的系统,会将磁盘解密用到的MasterKey(主密钥)存放在系统内核的一块只读区域中，研究人员使用安全测试框架对虚拟机中安装的macOS系统进行分析发现，内核空间中加密密钥书中存于特定的内存区域，可以在内存中直接搜索到密钥。</li>
</ul>
<p><strong>物理攻击</strong>:</p>
<ul>
<li>这种攻击称为DMA(Direct Memory Access)攻击,前提是攻击人员能物理接触到硬件设备</li>
</ul>
<h5 id="代码签名"><a href="#代码签名" class="headerlink" title="代码签名"></a>代码签名</h5><p>代码签名是对软件完整性检查、软件作者身份识别的技术，它是macOS系统上大多数安全特性得以有效实施的基础。</p>
<p>签名的过程使用命令行工具codesign完成，除了二进制应用签名外,codesign还可以对动态库、脚本、以及macOS软件包中的所有资源进行签名。</p>
<p><strong>手动进行签名</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ codesign -s &apos;xxxxxx@qq.com&apos; xxx.app</span><br></pre></td></tr></table></figure></p>
<p><strong>使用adhoc签名</strong> (只需要指定参数-s参数为’-‘):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ codesign -f &apos;-&apos; xxx.app</span><br></pre></td></tr></table></figure>
<p><strong>重新签名</strong>(需要加上-f参数)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ codesign -f -s &apos;xxxxxx@qq.com&apos; xxx.app</span><br></pre></td></tr></table></figure>
<p><strong>查看签名信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ codesign -d -vv xxxx.app</span><br></pre></td></tr></table></figure>
<p><code>codesig</code>在进行签名的时候,会改写可执行文件，在文件的<code>load_commands</code>中,添加一个<code>LC_CODE_SIGNATURE</code>项,里面会写入代码签名的一些信息。</p>
<p>CodeDiectory是嵌入二进制的一段签名信息，后面的Authority表示证书的签发机构为Apple Root CA.</p>
<p>签名的过程中会在程序包新建一个叫做_CodeSignature/CodeResources的文件,该文件存储了被签名程序包中所有文件的签名Hash信息。 CodeResources本质上是一个plist文件,可以使用任意一个文件编辑器打开查看。</p>
<h5 id="ASLR-KASLR"><a href="#ASLR-KASLR" class="headerlink" title="ASLR/KASLR"></a>ASLR/KASLR</h5><p>ASLR意为地址空间布局随机化,针对内核则是kASLR，这是一种针对缓存区溢出的安全保护技术,通过对堆、栈、共享库映射等线性区布局的随机化，增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p>
<h5 id="沙盒"><a href="#沙盒" class="headerlink" title="沙盒"></a>沙盒</h5><p>沙盒(Sandbox)对于不同的系统和软件应用场景，沙盒技术的含义也不同。</p>
<p>系统Sandbox通过读取程序的entitlements来检查程序可以访问的系统资源，entitlements在程序签名的过程中，写入到程序的签名信息，可以使用codesign读取已经签名程序中的entitlements。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -d entitlements - guitest.app</span><br></pre></td></tr></table></figure>
<h5 id="Rootless"><a href="#Rootless" class="headerlink" title="Rootless"></a>Rootless</h5><p>macOS10.11引入了一个新的安全特性：Rootless(更少的root权限)，又称为SIP(System Integrity Protection,系统完整性保护)。 通过Rootless，系统可以决定即使第三方程序获取了系统权限，也不能做以下的事情。</p>
<p><strong>文件系统保护</strong>:新版本系统中重要的目录与文件，不能被第三方应用程序任意修改。例如：/system、/bin、/sbin、/usr等目录中的文件</p>
<p><strong>运行时保护</strong>:向一个系统进程中注入代码与修改磁盘上受保护的文件一样，都是会失败的</p>
<p><strong>内核扩展限制</strong>:第三方开发的kext内核扩展经过签名之后放到/Library/Extension目录下。</p>
<h5 id="Gatekeeper"><a href="#Gatekeeper" class="headerlink" title="Gatekeeper"></a>Gatekeeper</h5><p>Gatekeeper直译为”看门人“，在macOS系统中，这扇门值得是当前计算机系统。作用就是检测从互联网上下载或其他地方安装的软件，当他们首次在系统中运行时，确保他们的行为对系统没有危害。</p>
<h3 id="软件的内幕"><a href="#软件的内幕" class="headerlink" title="软件的内幕"></a>软件的内幕</h3><h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h4><p>Bundle是苹果系统独有的特色,苹果系统中大量使用了Bundle.</p>
<p>Frameworks里存放了软件需要使用到的框架，它是以.framework结尾的Bundle结构。 XPCServices则存放了软件用到的XPC服务，它是以.xpc结尾的Bundle结构。</p>
<p>还有一种以.bundle扩展名结尾的Bundle，它是纯粹的Bundle，目录结构与其他的Bundle并无区别。可以存放二进制代码，也可以存放资源，也可以二者同时存放。 如果存放二进制代码的话，可在程序在代码中使用dlopen()函数打开</p>
<h4 id="通用二进制格式"><a href="#通用二进制格式" class="headerlink" title="通用二进制格式"></a>通用二进制格式</h4><p>为了解决软件在多个硬件平台上的兼容问题，苹果开发出了一个通用的二进制文件格式(Universal Binary),又称为胖二进制(Fat Binary).</p>
<p>通用二进制文件将多个支持不同CPU架构的二进制文件打包成一个文件,系统在加载运行该程序时，会根据通用二进制文件中提供的多个架构与当前系统平台做匹配，运行适合当前系统的那个版本。</p>
<p>在终端中执行file命令可以查看他的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ file /usr/bin/python</span><br></pre></td></tr></table></figure>
<p><img src="/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/Snip20190520_22.png" alt=""></p>
<p>系统提供了一个命令行工具lipo 来操作通用二进制文件,它可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。</p>
<p>提取python中x86_64版本的二进制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo /usr/bin/python -extract x86_64 -output ~/Desktop/python.x64</span><br></pre></td></tr></table></figure>
<p>删除python中x86_64版本的二进制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo /usr/bin/python -remove x86_64 -output ~/Desktop/python.x64</span><br></pre></td></tr></table></figure>
<p>瘦身为x86_64版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo /usr/bin/python -thin x86_64 -output ~/Desktop/python.x64</span><br></pre></td></tr></table></figure>
<p>胖二进制头部结构fat_header定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC   0xcafebabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM   0xbebafeca</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_header</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>  magic;</span><br><span class="line">   <span class="keyword">uint32_t</span> nfat_arch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>magic</code>字段通常被定义为常量<code>FAT_MAGIC</code>，它的取值是固定的：<code>0xcafebabe</code>这表示一个通用二进制文件。  <code>nfat_arch</code>字段指明通用二进制中包含了多少了<code>Mach-O</code>文件。</p>
<p>每个通用二进制架构信息都使用fat_arch结构体表示,在fat_header结构体之后,紧接着是一个或多个连续的fat_arch的结构体，它的定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_arch</span> &#123;</span></span><br><span class="line"> <span class="keyword">cpu_type_t</span>  cputype;</span><br><span class="line"> <span class="keyword">cpu_subtype_t</span> cpusubtype;</span><br><span class="line"> <span class="keyword">uint32_t</span>   offset;</span><br><span class="line"> <span class="keyword">uint32_t</span>   size;</span><br><span class="line"> <span class="keyword">uint32_t</span>   align;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>cputype</code>指定了具体的cpu类型,它的类型是<code>cpu_type_t</code>，定义在mach/machine.h中。 cpu的常用类型主要有如下几种:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_X86  ((cpu_type_t) 7)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_I386  CPU_TYPE_X86</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_X86_64 (CPU_TYPE_X86 | CPU_ARCH_ABI64)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_MC98000 ((cpu_type_t) 10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM ((cpu_type_t) 12)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM64  (CPU_TYPE_ARM | CPU_ARCH_ABI64)</span></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在macOS上的CPU类型一般为<code>CPU_TYPE_X86_64</code>.</p>
<p><code>offset</code>字段指明了当前cpu架构数据相对于当前文件开头的偏移值，<code>size</code>字段指明了数据的大小。<code>align</code>字段表明了数据的内存对齐边界，取值必须是2的次方，他确保了当前cpu架构的目标文件在加载到内存时，数据是经过优化对齐的。</p>
<p>可以使用<code>otool</code>工具打印本机安装的<code>python</code>程序的<code>fat_header</code>信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otool -f -v /usr/bin/python</span><br></pre></td></tr></table></figure>
<p>fat_arch结构往下就死具体的Mach-O文件格式。</p>
<h4 id="Mach-O文件格式"><a href="#Mach-O文件格式" class="headerlink" title="Mach-O文件格式"></a>Mach-O文件格式</h4><p>Mach-O描述了macOS系统上可执行文件的格式。熟悉Mach-O文件格式有助于了解苹果底层软件的运行机制，更好的掌握dyld加载Mach-O的步骤。</p>
<h5 id="Mach-O简介"><a href="#Mach-O简介" class="headerlink" title="Mach-O简介"></a>Mach-O简介</h5><p>典型的Mach-O文件格式<br><img src="/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/snip_004.png" alt=""></p>
<p>可以看出,Mach-O主要由以下3部分组成:</p>
<p><strong>Mach-O头部(Mach header):</strong> 描述了Mach-O的cpu架构、文件类型以及加载命令等信息。</p>
<p><strong>加载命令(load command)</strong>: 描述了文件中数据的具体组织架构，不同的数据类型使用不同的加载命令表示。</p>
<p><strong>Data</strong>: Data中每个段(segment)的数据都保存在这里,段的概念与ELF文件中段的概念类似。 每个段都有一个或多个Section,它们存放了具体的数据与代码。</p>
<h5 id="Mach-O头部"><a href="#Mach-O头部" class="headerlink" title="Mach-O头部"></a>Mach-O头部</h5><p>与Mach-O文件格式有关的结构体可以直接或间接地在mach-o/loader.h文件中找到。 32位与64位架构的CPU，分别使用了mach_header与mach_header结构体来描述Mach-O头部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mach_header结构体的定义如下:</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span>&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>   magic;</span><br><span class="line"><span class="keyword">cpu_type_t</span> cputype;</span><br><span class="line"><span class="keyword">cpu_subtype_t</span> cpusubtype;</span><br><span class="line"><span class="keyword">uint32_t</span>   filetype;</span><br><span class="line"><span class="keyword">uint32_t</span>   ncmds;</span><br><span class="line"><span class="keyword">uint32_t</span>   sizeofcmds;</span><br><span class="line"><span class="keyword">uint32_t</span>   flags;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>magic</code>字段与<code>fat_header</code>结构体中的<code>magic</code>字段一样,表示<code>Mach-O</code>文件的魔术值。 对于32位架构的程序说,它的取值是<code>MH_MAGIC</code>，固定为<code>0xfeedface</code>.</p>
<p><code>cputype</code>和<code>cpusubtype</code>字段和<code>fat_header</code>结构体的含义完全相同。</p>
<p><strong>filetype</strong>字段表示<code>Mach-O</code>的具体类型。它的取值如下所示：<br><img src="/lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/snip_002.png" alt=""></p>
<p><code>ncmds</code>指明了Mach-O文件中<code>加载命令(load commands)</code>的数量.</p>
<p><code>sizeofcmds</code>字段表明了<code>Mach-O</code>文件加载命令所占的总字节的大小。</p>
<p><code>flags</code>字段表示文件的标志,它是一个含有一组位标志的整数,指明了Mach-O文件的一些标志信息，可用的值如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_INCRLINK  0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLDLINK  0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_LAZY_INIT 0x40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL 0x80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PIE 0x200000</span></span><br></pre></td></tr></table></figure>
<p>64位Mach-O的mach_header_64结构体的定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span>&#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>   magic;</span><br><span class="line"><span class="keyword">cpu_type_t</span> cputype;</span><br><span class="line"><span class="keyword">cpu_subtype_t</span> cpusubtype;</span><br><span class="line"><span class="keyword">uint32_t</span>   filetype;</span><br><span class="line"><span class="keyword">uint32_t</span>   ncmds;</span><br><span class="line"><span class="keyword">uint32_t</span>   sizeofcmds;</span><br><span class="line"><span class="keyword">uint32_t</span>   flags;</span><br><span class="line"><span class="keyword">uint32_t</span>   reserved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比mach_header，他多了一个<code>reserved</code>字段,目前它的值是系统保留。</p>
<p><code>mach_header_64</code>的字段基本和<code>mach_header</code>中的基本一致,不同的是magic字段的取值是<code>MH_MAGIC_64</code>。固定的值为：<code>0xfeedfacf</code>.</p>
<h5 id="加载命令"><a href="#加载命令" class="headerlink" title="加载命令"></a>加载命令</h5><p>在mach_header之后是LoadCommand加载命令,这些加载命令在Mach-O文件加载解析时，会被加载到内裤加载器或者动态连接器调用，基本的加载命令的数据结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line"> <span class="keyword">uint32_t</span> cmd; <span class="comment">// 当前的加载命令</span></span><br><span class="line"> <span class="keyword">uint32_t</span> cmdsize;<span class="comment">// 当前加载命令的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cmd</code>的类型不同,所代表的加载命令的类型就会不同,它的结构体也会有所不同.不同类型的加载命令在load_commands结构体后面加一个或多个字段表示特定结构体信息。 macOS的系统进化过程中,加载命令是更新比较频繁的一个数据结构体。目前共计有48种。</p>
<p>所有的这些加载命令由系统内核加载器直接使用,或由动态链接器处理。下面介绍几个我们常见的加载命令:</p>
<ul>
<li><strong>LC_SEGMEN</strong>:表示的这是一个段加载命令,需要将它加载到对应的进程空间中。</li>
<li><p><strong>LC_LOAD_DYLIB</strong>:表示的是一个需要动态加载的链接库。它使用dylib_command结构体表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct dylib_command &#123;</span><br><span class="line"> uint32_t cmd;</span><br><span class="line"> uint32_t cmdsize;</span><br><span class="line"> struct dylib dylib;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当<strong>cmd</strong>的类型是<strong>LC_ID_DYLIB</strong>、<strong>LC_LOAD_DYLIB</strong>、<strong>LC_LOAD_WEAK_DYLIB</strong>与<strong>LC_REEXPORT</strong>与<strong>LC_REEXPORT_DYLIB</strong>时,统一使用<strong>dylib_command</strong>结构体表示。使用dylib结构体存储要加载的动态库的具体信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   struct dylib&#123;</span><br><span class="line">    union lc_str name;</span><br><span class="line">    uint32_t timestamp;</span><br><span class="line">    uint32_t current_version;</span><br><span class="line">    uint32_t compatibility_version;</span><br><span class="line">   &#125;</span><br><span class="line">  ```  </span><br><span class="line">`name`字段是动态库的完整路径,动态链接器在加载动态库时,会通过此路径进行加载. `timestamp`字段描述了动态库构建时的时间戳。`current_version`和`compatibility_version`指明了当前版本与兼容的版本号。</span><br><span class="line"></span><br><span class="line">* **LC_MAIN**: 此加载命令记录了可执行文件的主函数`main()`的位置,它使用`entry_point_command`结构体表示。</span><br><span class="line"> </span><br><span class="line">  ```c</span><br><span class="line">   struct entry_point_command &#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    uint32_t cmdsize;</span><br><span class="line">    uint64_t entryoff;</span><br><span class="line">    uint64_t stacksize;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  <code>entryoff</code>字段指定了<code>main()</code>函数的文件偏移,<code>stacksize</code>指定了初始的堆栈的大小。</p>
<h5 id="LC-CODE-SIGNATURE"><a href="#LC-CODE-SIGNATURE" class="headerlink" title="LC_CODE_SIGNATURE"></a><code>LC_CODE_SIGNATURE</code></h5><p><code>LC_CODE_SIGNATURE</code>是代码签名加载命令,描述了Mach-O的代码签名信息，它属于链接信息，使用linkedit_data_command结构体表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linkedit_data_command</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> cmd;</span><br><span class="line"><span class="keyword">uint32_t</span> cmdsize;</span><br><span class="line"><span class="keyword">uint32_t</span> dataoff;</span><br><span class="line"><span class="keyword">uint32_t</span> datasize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dataoff</code>字段表明了相对于__LINKEDIT段的文件偏移位置,<code>datasize</code>字段表明了数据的大小。</p>
<p>与代码签名相关的数据定义可以在xnu内核代码的<code>bsd/sys/codesign.h</code>文件中找到。 整个代码签名部分的头部使用一个<code>CS_SuperBlob</code>的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SC_SuperBlob</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> magic;</span><br><span class="line">  <span class="keyword">uint32_t</span> length;</span><br><span class="line">  <span class="keyword">uint32_t</span> count;</span><br><span class="line">  CS_BlobIndex index[];</span><br><span class="line">&#125; CS_SuperBlob;</span><br></pre></td></tr></table></figure>
<p><code>magic</code>字段指明了Blob的类型,可选值如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line"> CSMAGIC_REQUIREMENT = <span class="number">0xfade0c00</span>,</span><br><span class="line"> CSMAGIC_REQUIREMENTS = <span class="number">0xfade0c01</span>,</span><br><span class="line"> CSMAGIC_CODEDIRECTORY = <span class="number">0xfade0c02</span>,</span><br><span class="line"> ICSMAGIC_EMBEDDED_SIGNAURE = <span class="number">0xfade0cc0</span>,</span><br><span class="line"> CSMAGIC_EMBEDDED_SIGNAURE_OLD = <span class="number">0xfade0b02</span>,</span><br><span class="line"> CSMAGIC_EMBEDDED_ENTITLEMENTS = <span class="number">0xfade7171</span>,</span><br><span class="line"> CSMAGIC_DETACHED_SIGNATURE = <span class="number">0xfade0cc1</span>,</span><br><span class="line"> CSMAGIC_BLOBWRAPPER = <span class="number">0xfade0b01</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第一个Blob来说，它的值必定是<code>ICSMAGIC_EMBEDDED_SIGNAURE</code>,表示代码签名采用的是嵌入式的签名信息。</p>
<p><code>length</code>字段指明了整个SuperBlob的大小,其中包含了即将介绍的CodeDirectory、Requirement与Entitlement的大小.</p>
<p><code>count</code>字段指明了接下来会有多少条子条目.<br>从index开始,就是每一个子条目的索引,它的结构是CS_BlobIndex,定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BlobIndex</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span> type;</span><br><span class="line"><span class="keyword">uint32_t</span> offset;</span><br><span class="line"></span><br><span class="line">&#125; CS_BlobIndex;</span><br></pre></td></tr></table></figure>
<p><code>type</code>指明了子条目的类型,可选值如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CSSLOT_CODEDIRECTORY = <span class="number">0</span>,</span><br><span class="line">CSSLOT_INFOSLOT  = <span class="number">1</span>,</span><br><span class="line">CSSLOT_REQUIREMENTS = <span class="number">2</span>,</span><br><span class="line">CSSLOT_RESOURCEDIR = <span class="number">3</span>,</span><br><span class="line">CSSLOT_APPLICATION = <span class="number">4</span>,</span><br><span class="line">CSSLOT_ENTITLEMENTS = <span class="number">5</span>,</span><br><span class="line">CSSLOT_SIGNATURESLOT = <span class="number">0x10000</span>,</span><br></pre></td></tr></table></figure>
<p><code>offset</code>字段指明了子条目距离代码签名数据起始的文件偏移。</p>
<p>Certificates签名证书也是CS_GenericBlob结构,提取它的证书数据然后保存为cer文件。</p>
<h6 id="代码签名验证流程"><a href="#代码签名验证流程" class="headerlink" title="代码签名验证流程"></a>代码签名验证流程</h6><p>内核加载解析Mach-O加载命令的函数是parse_machfile(),位于内核代码<a href="https://github.com/apple/darwin-xnu/blob/master/bsd/kern/mach_loader.c" target="_blank" rel="noopener">XNU_SRC_Root/bsd/kern/mach_loader.c</a>文件中.</p>
<p>整个代码签名的验证过程大致分为<code>load_code_signature()</code>与<code>cs_validate_page()</code>两步。前者负责加载代码签名,后者负责验证数据页面。</p>
<p> <strong>load_code_signature()</strong>:</p>
<p>  在加载代码签名时,通过调用<code>ubc_cs_blob_get()</code>来获取特定CPU的<code>cs_blob</code>指针, <code>ubc_cs_blob_get()</code>第一次调用时,返回的cs_blob指针为空,会调用<code>ubc_cs_blob_add()</code>来加载与验证文件中的Blob信息；再次调用<code>ubc_cs_blobget()</code>就会返回内存中的<code>cs_blob</code>指针。 当然不是直接返回,系统会再次判断内存中的<code>cs_blob</code>指针是否损坏或者遭到篡改，具体的方法是调用<code>ubc_cs_generation_check()</code>初步检查，之后调用<code>ubc_cs_blob_revalidata()</code>对Blob做重验证。</p>
<p>  ubc_cs_blob_add()主要做了以下三项工作:</p>
<ol>
<li><p>调用<code>cs_validate_csblob()</code>验证<code>cs_blob</code>指针的合法性,<code>cs_validate_csblob()</code>会对<code>CSMAGIC_EMBEDDED_SIGNATURE</code>与<code>CSMAGIC_CODEDIREC</code>做相应的验证处理，包括调用<code>cs_validate_codedirectory()</code>验证<code>CS_CodeDirectory</code>结构体的合法性,以及调用<code>cs_validate_blob()</code>验证<code>CS_SuperBlob</code>中每一个<code>CS_GenericBlob</code>是否合法有效。</p>
</li>
<li><p>调用<code>mac_vnode_check_signature()</code>验证Blob块的签名,也就是比较Blob块的SHA1哈希值与计算的值是否相同。</p>
</li>
<li><p>加载所有的代码签名Hash信息,填充cs_blobs字段,为下一步的内存页签名验证做准备。<code>ubc_cs_blob_revalidate()</code>做的验证检查几乎与<code>ubc_cs_blob_add()</code>相同，但因为已经有了一些缓存信息，因此检查的时候会快一些。 <code>load_code_signature()</code>完成以后,会调用<code>ubc_get_cs_blobs()</code>获得<code>cs_blobs</code>指针,最后调用<code>cs_validate_page()</code>,逐页验证文件中每一页数据的签名。 </p>
</li>
</ol>
<p>以上检查做完后,LC_CODE_SIGNATURE就处理完了。 如果没有发生错误,代码的验证签名就通过了。</p>
<h6 id="代码加密流程"><a href="#代码加密流程" class="headerlink" title="代码加密流程"></a>代码加密流程</h6><p>Mach-O程序如果使用了代码加密技术,在加载列表中会有一个<code>LC_ENCRYPTION_INFO</code>加载命令，它存储了Mach-O的加密信息。</p>
<p>被加密的App文件,部分段的数据内容是加密的,而记录加密数据的关键就是<code>LC_ENCRYPTION_INFO</code>加载命令。 分析人员想要对加密的App文件进行逆向分析,必须先经过一次解密(俗称“砸壳”)操作。</p>
<p><code>LC_ENCRYPTION_INFO</code>使用<code>encryption_info_command</code>结构体表示,定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">encryption_info_command</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>  cmd;</span><br><span class="line">   <span class="keyword">uint32_t</span>  cmdsize;</span><br><span class="line">   <span class="keyword">uint32_t</span>  cryptoff;</span><br><span class="line">   <span class="keyword">uint32_t</span> cryptsize;</span><br><span class="line">   <span class="keyword">uint32_t</span>  cryptid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cryptoff和cryptsize字段指明了加密数据的文件偏移与大小,cryptid指定了使用的加密系统。</p>
<p>安全研究人员根据Mach-O在内存中被加载完即解密完成的特点,开发出了针对iOS平台App的代码解密工具 <a href="https://github.com/stefanesser/dumpdecrypted" target="_blank" rel="noopener">dumpdecrypted</a>，将内存中解密的数据写会原位置,并将cryptid置为0,来达到解密App的目的。</p>
<p>当系统内核被配置为启用代码解密(即定义了<code>CONFIG_CODE_DECRYPTION</code>)之后,<code>parse_machfile()</code>函数会解析<code>LC_ENCRYPTION与LC_ENCRYPTION_INFO_64</code>加载命令。</p>
<p>最后调用了<code>set_code_unprotect()</code>函数来对代码进行加密。该函数通过<code>encryption_info_command</code>中的<code>cryptid</code>来确定使用的加密系统,然后对代码进行内存解密。</p>
<p>text_crypter_create()是一个text_crypter_create_hook_t类型全局指针,在内核代码<a href="https://github.com/apple/darwin-xnu/blob/master/osfmk/kern/page_decrypt.c" target="_blank" rel="noopener">osfmk/kern/page_decrypt.c</a>文件中通过<code>text_crypter_creater_hook_set()</code>进行设置。</p>
<p>在填充完解密所需的信息crypt_info后,<code>text_crypter_create()</code>会再次计算需要重新解密映射内存的地址与大小,调用<code>vm_map_apple_protected()</code>进行解密操作。</p>
<h5 id="LC-SEGMENT"><a href="#LC-SEGMENT" class="headerlink" title="LC_SEGMENT"></a>LC_SEGMENT</h5><p>段加载命令<code>LC_SEGMENT</code>描述了32位Mach-O的段信息,使用<code>segment_command</code>结构体来表示,它的定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>  cmd;</span><br><span class="line">   <span class="keyword">uint32_t</span> cmdsize;</span><br><span class="line">   <span class="keyword">char</span> segname[<span class="number">16</span>];</span><br><span class="line">   <span class="keyword">uint32_t</span> vmaddr;</span><br><span class="line">   <span class="keyword">uint32_t</span> vmsize;</span><br><span class="line">   <span class="keyword">uint32_t</span> fileoff;</span><br><span class="line">   <span class="keyword">uint32_t</span> filesize;</span><br><span class="line">   <span class="keyword">vm_prot_t</span> maxprot;</span><br><span class="line">   <span class="keyword">vm_prot_t</span> initprot;</span><br><span class="line">   <span class="keyword">uint32_t</span>  nsects;</span><br><span class="line">   <span class="keyword">uint32_t</span>  flags;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>segname</code>字段是一个16字节大小的空间,用来存储段的名称。</p>
<p><code>vmaddr</code>字段指明了段要加载的虚拟内存地址</p>
<p><code>vmsize</code> 字段指明了段所占的虚拟内存大小</p>
<p><code>fileoff</code> 字段指明了段数据所在文件的偏移地址</p>
<p><code>filesize</code> 字段表明了段数据实际的大小</p>
<p><code>maxprot</code> 字段指明了页面所需要的最高内存保护</p>
<p><code>initprot</code> 字段指明了页面初始的内存保护</p>
<p><code>nsects</code> 字段指明了段所包含的节区</p>
<p><code>flags</code> 字段表明了段的标志信息</p>
<p>一个编译后可能执行的程序会分成多个段,不同类型的数据放入不同的段中。程序的代码段被称为代码段,放入一个名为__TEXT的段中,代码段的maxprot字段在编译时被设置成 <code>VM_PROT_READ(可读)</code>、<code>VM_PROT_WRITE(可写)</code>、<code>VM_PROT_EXECUTE(可执行)</code>，initprot 字段被设置成<code>VM_PROT_READ(可读)</code>、<code>VM_PROT_EXECUTE(可执行)</code>。 一个普通的程序中，代码段部分通常是不可写的，有特殊需求的程序,如果要求代码段可写,必须在编译时设置它的initprot字段为<code>VM_PROT_WRITE(可写)</code>。</p>
<p><code>nsects</code>字段指定了段加载命令包含几个节区,一个段可以包含0或多个节区。如__PAGEZERO段就不包含任何节区,该段被称为空指针陷阱段,映射到虚拟内存空间的第一页,用于捕捉对NULL指针的引用。</p>
<p>当一个段包含多个节区时,节区信息会以数组的形式存储在段加载命令后面.节区使用结构体section表示(64位使用section_64表示)，定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct section &#123;</span><br><span class="line"> char sectname[16];</span><br><span class="line"> char segname[16];</span><br><span class="line"> uint32_t addr;</span><br><span class="line"> uint32_t size;</span><br><span class="line"> uint32_t offset;</span><br><span class="line"> uint32_t align;</span><br><span class="line"> uint32_t reloff;</span><br><span class="line"> uint32_t nreloc;</span><br><span class="line"> uint32_t flags;</span><br><span class="line"> uint32_t reserved1;</span><br><span class="line"> uint32_t reserved2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sectname字段表示节区的名称,segname字段表示节区所在的段名,addr与size指明了节区所在的内存地址与大小,offset指明了节区所在的文件偏移。 align表示节区的内存对齐边界,reloff指明了重定位信息的文件偏移,nreloc表示重定位条目的数目，flags则是节区的一些标志属性。</p>
<p>段加载命令的最后一个字段flags存储了段的一些标志属性:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SG_HIGHVM  0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SG_FVMLIB  0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SG_NORELOC  0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SG_PROTECTED_VERSION_1 0x8</span></span><br></pre></td></tr></table></figure>
<p>值得关注的是<code>SG_PROTECTED_VERSION_1</code>, 当段被设置了该标志位时,表示段是经过加密的。<br>在macOS版本10.6以前,系统使用AES算法进行段的加密与解密。10.6之后则使用了Blowfish加密算法。  著名的iOS逆向工具<code>class-dump</code>提供了一个静态数据段解密工具<code>deprotect</code>.</p>
<h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><p>Windows系统的动态库时DLL文件,Linux系统是so文件,macOS系统的动态库则使用dylib文件。dylib本质上是一个Mach-O文件,只是在文件类型上是MH_DYLIB.</p>
<p>可以使用file命令查看系统动态库信息:</p>
<p><img src="Mac软件安全与逆向分析//Snip20190522_10.png" alt=""></p>
<p>可以使用otool查看dylib依赖信息:</p>
<p><img src="Mac软件安全与逆向分析//Snip20190522_11.png" alt=""></p>
<p>动态库的整个编译过程分为:检查依赖、生成辅助文件、编译、链接、生成调试符号、代码签名。</p>
<p>编译代码时使用的编译器是Clang,该编译器也被广泛使用于Android、Linux平台。 链接时使用Clang前端传入参数给链接器ld,链接完成后dylib动态库就编译成功了。 生成调试符号这一步主要用于生成符号的调试信息,供调试器使用。最后一步是代码签名，在没有指定签名证书的情况下,Xcode默认使用adhoc签名。</p>
<p>对于编译好的动态库,可以通过头文件声明隐式调用，也可以像Linux那样,使用系统函数dlopen()、dlsym()手动调用。</p>
<h5 id="dyld"><a href="#dyld" class="headerlink" title="dyld"></a>dyld</h5><p>动态库不能直接运行,需要通过系统的动态链接加载器加载到内存后执行。 动态链接加载器在系统中可执行文件形式存在，一般在Mach-O文件中会指定一个<code>LC_LOAD_DYLINKER</code>的加载命令。 此加载命令指定了dyld的路径,通常默认值是<code>/usr/lib/dyld</code>.</p>
<p>为了优化程序启动,dyld在加载时启用了共享缓存的技术(shared cache)。在进程启动的时候,共享缓存会被dyld映射到内存中,之后，当Mach-O映像加载时,dyld首先会检查该Mach-O映像与所需的动态库是否在共享缓存中。如果在，则直接将它在共享缓存中的内存地址映射到进程的内存地址空间。</p>
<p><code>update_dyld_shared_cache</code> 程序确保了dyld的共享缓存是最新的,它会扫描 <code>/var/db/dyld/shared_region_roots/</code>  目录下的paths路径文件,这些paths文件包含了需要加入到共享缓存的Mach-O文件路径列表。 <code>update_dyld_shared_cache</code> 会将这些Mach-O文件及其依赖的dylib逐个加到共享缓存中。</p>
<h5 id="动态库的加载"><a href="#动态库的加载" class="headerlink" title="动态库的加载"></a>动态库的加载</h5><p><a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">dyld</a>是苹果操作系统的重要组成部分，而且是开源的。</p>
<p>系统内核在加载动态库前,会加载dyld,然后调用执行 <code>__dyld_start()</code>函数. 该函数会执行 <code>dyldbootstrap::start()</code>,后者优惠执行_<code>_main()</code>函数,<code>dyld</code>加载动态库的代码就是从<code>__main()</code>开始执行的。</p>
<hr>
<ul>
<li><p>第一步 设置运行环境,处理环境变量</p>
<p>代码在开始时将传入的变量mianExecutableMH 赋值给了sMainExecutableMachHeader。 这是一个macho_header类型的变量,其结构体内容就是本章前面介绍的mach_header结构体，表示的是当前主程序的Mach-O头部信息。 有了头部信息,加载器就可以从头开始遍历整个Mach-O文件的信息。</p>
<p>接着执行了setContext(),此方法设置了一个链接上下文,包括一些回调函数、参数与标志设置信息。</p>
<p>如果进程受限,会有以下三种:</p>
<ul>
<li><code>restrictedByEntitlements</code>:在macOS系统上，在需要验证代码签名且<code>csr_check(CSR_ALLOW_TASK_FOR_PID)</code>标志位的,这意味着在默认情况下,系统运行的进程是受限的</li>
<li><code>restrictedBySetGUid</code>:当进程的<code>setuid</code>与<code>setgid</code>位被设置时,进程会被设置成受限. 受限后的进程无法访问<code>DYLD_</code>开头的环境变量。 在macOS10.10系统上,一个系统本地提权漏洞就是通过向<code>DYLD_PRINT_TO_FILE</code>环境变量传入拥有<code>SUID</code>权限的受限文件造成的,因为系统没做安全监测，这些文件有直接向系统创建与写入文件的权限。</li>
<li><code>restrictedBySegment</code>:段名受限。 当Mach-O包含一个<code>__RESTRICT/__restrict</code>段时,进程会被设置成受限。</li>
</ul>
</li>
</ul>
<p>在进程受限后,会执行一下三个方法:</p>
<ul>
<li><code>checkLoadCommandEnvironmentVariables()</code>:遍历Mach-O中所有的<code>LC_DYLD_ENVIRONMENT</code>加载命令,然后调用<code>processDyldEnvironmentVariable()</code>对不同的环境变量做相应的处理</li>
<li><code>pruneEnvironmentVariables()</code>:删除进程的<code>LD_LIBRARY_PATH</code>与所有以“<code>DYLD_</code>”开头的环境变量,这样以后创建的子进程就不包含这些环境变量。</li>
<li><code>setContext()</code>: 重新设置链接的上下文.这一步操作主要是由于环境变量发生了变化,需要更新进程的<code>envp</code>与<code>apple</code>参数。</li>
</ul>
<hr>
<ul>
<li>第二步  初始化主程序</li>
</ul>
<p>这一步主要执行了instantiateFromLoadedImage()，它的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// The kernel maps in main executable before dyld gets control.  We need to </span><br><span class="line">// make an ImageLoader* for the already mapped in main executable.</span><br><span class="line">static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)</span><br><span class="line">&#123;</span><br><span class="line">	// try mach-o loader</span><br><span class="line">	if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">		addImage(image);</span><br><span class="line">		return (ImageLoaderMachO*)image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	throw &quot;main executable not a known format&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>isCompatibleMachO()</code>主要检查<code>Mach-O</code>的头部的<code>cputype</code>与<code>cpusubtype</code>，从而判断程序与当前的系统是否兼容。 如果兼容就调用<code>instantiateMainExecutable()</code>实例化程序。</p>
<p><code>sniffLoadCommand()</code>主要获取了加载命令中的如下信息:</p>
<ul>
<li><p><code>compressed</code>: 判断<code>Mach-O</code>是<code>Compressed</code>还是<code>Classic</code>类型。 判断的依据是<code>Mach-O</code>是否包含<code>LC_DYLD_INFO</code>与<code>LC_DYLD_INFO_ONLY</code>加载命令。这两个加载命令记录了Mach-O的动态库加载信息,使用结构体<code>dyld_info_command</code>表示:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dyld_info_command</span> &#123;</span></span><br><span class="line"> <span class="keyword">uint32_t</span>  cmd;</span><br><span class="line"> <span class="keyword">uint32_t</span>   cmdsize;</span><br><span class="line"> <span class="keyword">uint32_t</span>   rebase_off;</span><br><span class="line"> <span class="keyword">uint32_t</span>   rebase_size;</span><br><span class="line"> <span class="keyword">uint32_t</span>   bind_off;</span><br><span class="line"> <span class="keyword">uint32_t</span>   weak_bind_off;</span><br><span class="line"> <span class="keyword">uint32_t</span>   weak_bind_size;</span><br><span class="line"> <span class="keyword">uint32_t</span>   lazy_bind_off;</span><br><span class="line"> <span class="keyword">uint32_t</span>   lazy_bind_size;</span><br><span class="line"> <span class="keyword">uint32_t</span>   export_off;</span><br><span class="line"> <span class="keyword">uint32_t</span>   export_size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>rebase_off</code>与<code>rebase_size</code>存储了rebase(重设基址)相关信息。当Mach-O加载到内存中的地址不是指定的首选地址时,就需要对当前的映像数据重设基址。</li>
<li><code>bind_off</code>与<code>bind_size</code>存储了进程的符号绑定信息。  当进程启动时,必须绑定这样符号,典型的有dyld_stub_binder,该符号被dyld用来做延迟绑定加载符号,一般动态库都包含该符号</li>
<li><code>weak_bind_off</code>与<code>weak_bind_size</code>存储了进程的弱绑定符号信息。 弱符号主要用于面向对象语言中的符号重载,典型的有C++中使用了new创建对象，默认情况下回绑定libstdc++.dylib.</li>
<li><code>lazy_bind_off</code>与<code>lazy_bind_size</code>存储了进程的延迟绑定符号信息,有些符号在进程启动时不需要马上解析，他们会在第一次调用时被解析，这类符号叫延迟绑定符号(Lazy Symbol).</li>
<li><code>export_off</code>与<code>export_size</code>存储了进程的导出符号绑定信息。 导出符号可以被外部的Mach-O访问,通常动态库会导出一个或多个符号供外部使用,而可执行程序又导出<code>__mian</code>与<code>__mh_excute_header</code>符号供dyld使用。</li>
<li><code>segcount</code>:段的数量。<code>sniffLoadCommands()</code>通过遍历所有的<code>LC_SEGMENT_COMMAND</code>加载命令来获取段的数量。</li>
<li><code>libCount</code>:需要加载的动态库的数量,Mach-O包含的每一条<code>LC_LOAD_DYLIB</code>、<code>LC_LOAD_WEAK_DYLIB</code>、<code>LC_REEXPORT_DTLIB</code>、<code>LC_LOAD_UPWARD_DYLIB</code>加载命令,都需要加载一个动态库</li>
<li><code>codeSigCmd</code>:通过解析<code>LC_CODE_SIGNATURE</code>来获取代码签名的加载命令。</li>
<li><code>encryptCmd</code>：通过<code>LC_ENCRYPTION_INFO</code>与<code>LC_ENCRYPTION_INFO_64</code>来获取段加密信息。</li>
</ul>
<hr>
<ul>
<li><p>第三步  加载共享缓存</p>
<p>这一步主要执行<code>mapSharedCache()</code>来映射缓存。该函数先通过<code>_shared_region_check_np()</code>来检查缓存是否已经映射到了共享区域，如果已经映射，则更新缓存的<code>slide</code>与<code>UUID</code>，然后返回。反之，判断系统是否处理安全启动模式，如果是，则删除缓存文件并返回。在正常启动的情况，调用<code>openShareCacheFile()</code>打开缓存文件。</p>
</li>
</ul>
<p> 共享缓存加载完毕后,接着进行动态库的版本化重载，这主要通过函数<code>checkVersionedPaths()</code>完成。该函数读取<code>DYLID_VERSIONED_LIBRARY_PATH</code>与<code>DYLD_VERSIONED_FRAMEWORK_PATH</code>环境变量,从这两个环境变量指定的路径中搜索动态库，如果路径中动态库的<code>current_version</code>字段已经加载的<code>dylib</code>的版本新,就使用新版本的库替换旧版本的库。</p>
<hr>
<ul>
<li><p>第四步  加载插入的动态库</p>
<p>这一步循环遍历<code>DYLID_INSERT_LIBRARIES</code>环境变量中指定的动态库列表,并调用<code>loadInsertedDylib()</code>将其加载。该函数调用<code>load()</code>完成加载工作。 <code>load()</code>会调用<code>loadPhrase()</code>尝试从文件加载。<code>loadPhase()</code>会向下调用下一层Phase来查找动态库的路径,直到<code>loadPhase6()</code>. 查找顺序为<code>DYLD_ROOT_PATH</code>-&gt;<code>LD_LIBRARY_PATH</code>-&gt;<code>DYLD_FRAMEWORK_PATH</code>-&gt;原始路径-&gt;<code>DYLD_FALLBACK_LIBRARY_PATH</code>.</p>
</li>
</ul>
<p> 找到后调用<code>ImageLoaderMachO::instantiateFromFile()</code>来实例化一个<code>ImageLoader</code>,之后调用<code>checkandAddImage()</code>验证映像并将其加入到全局映像列表中。 如果<code>loadPhase0()</code>返回为空,则表示在路径中没有找到动态库,就会尝试从共享缓存中查找。 如果找到就调用<code>ImageLoaderMachO::instanteFromCache()</code>从缓存中加载,否则就抛出没找到映像的异常。</p>
<hr>
<ul>
<li><p>第五步  链接主程序</p>
<p>这一步进行<code>link()</code>完成主程序的链接操作。该操作调用了<code>ImageLoader</code>自身的<code>link()</code>函数，对实例化的主程序的动态数据进程修正，达到让进程可用的目的。</p>
</li>
</ul>
<hr>
<ul>
<li><p>第六步  链接插入的动态库</p>
<p>链接插入的动态库与链接主程序一样,都是使用<code>link()</code>.插入的动态库列表是前面<code>addImage()</code>保存到<code>sAllImages</code>中的，之后，循环获取每一个动态库的ImageLoader,调用<code>link()</code>对其进行链接。<br>接下来调用灭一个映像的<code>registerInterposing()</code>方法,来注册动态库插入与调用<code>applyInterposing()</code>应用插入操作(也叫做符号地址替换)。</p>
</li>
</ul>
<hr>
<ul>
<li><p>第七步  执行弱符号绑定</p>
<p>weakBind()函数执行弱符号绑定。 首先通过调用context的getCoalescedImages()将sAllImages中所有含有弱符号的映像合并成一个列表，合并完成后调用initializeCoalIterator()对映像进行排序，排序完成后调用incrementCoalIterator()手机需要绑定的弱符号。</p>
</li>
</ul>
<p>  fishhook似乎跟这个有关系。</p>
<hr>
<ul>
<li>第八步  执行初始化方法</li>
</ul>
<p>  执行初始化的方法是<code>initializeMainExecutable()</code>。该函数主要执行<code>runInitializers()</code>,它调用了ImageLoader的<code>runInitializers()</code>方法，最终迭代执行了ImageLoaderMachO的<code>doInitialization()</code>方法，后者主要调用了<code>doImageInit()</code>和<code>doModInitFunctions()</code>，执行映像与模块为init的函数和静态初始化方法。</p>
<hr>
<ul>
<li><p>第九步  查找入口点并返回</p>
<p>这一步调用主程序映像的<code>getThreadPC()</code>函数来查找主程序的<code>LC_MAIN</code>加载命令，获取程序的入口。如果没有找到,就调用<code>getMain()</code>到<code>LC_UNIXTHREAD</code>加载命令中去找，找到后就跳到入口点指定的地址返回。</p>
</li>
</ul>
<p>  所有的延迟绑定符号都存储在TEXT段的stubs节区。 编译器在生成代码时创建的符号调用就生成在此节区中，该节区被称为“桩”节区。 桩只是一小段临时使用的指令，在stub中只是一条jmp跳转指令，跳转的地址位于 <strong>DATA段</strong>la_symbol_ptr节区中，指向的是一段代码。</p>
<hr>
<h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><p>静态库和动态库都是Mach-O格式的文件,动态库使用.dylib作为文件的扩展名,静态库则使用.a作为文件的扩展名。</p>
<p>在功能上，动态库通过动态链接的方式向其他程序提供接口,而静态库则将功能代码直接编译进目标Mach-O文件中去。 多个程序使用同一个动态库并不会增加目标文件的大小，使用静态库则会将每份功能代码相同都复制到目标文件中。</p>
<p>从运行效率上来说,动态库需要在加载后做符号绑定的操作,静态库代码直接在目标程序中运行，因此使用静态库的运行效率比动态库要高一些。</p>
<h5 id="静态库的格式"><a href="#静态库的格式" class="headerlink" title="静态库的格式"></a>静态库的格式</h5><p>与<code>Mach-O</code>可执行文件不同的是,动态库在<code>Mach-O</code>头部指定文件类型为<code>MH_DYLIB</code>，可执行程序为<code>MH_EXECUTE</code>.而静态库文件不是标准的<code>Mach-O</code>文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Srart</span><br><span class="line">Symtab Header</span><br><span class="line">Symbol Table</span><br><span class="line">String Table</span><br><span class="line">Object Header.o</span><br><span class="line">ObjNameO<span class="number">.0</span></span><br><span class="line">......</span><br><span class="line">Object Header N</span><br><span class="line">ObjNameN.o</span><br></pre></td></tr></table></figure>
<p>  start为静态库的开始,它是一个固定长度的签名值 ！<arch>\n，十六进制为 21 3c 61 72 63 68 3E oA.</arch></p>
<p>  Symtab Header为符号表头,描述了符号表的信息。它使用symtab_header结构体表示。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_header</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>  name[<span class="number">16</span>]; <span class="comment">/// 名称</span></span><br><span class="line">  <span class="keyword">char</span>  timestamp[<span class="number">12</span>]; <span class="comment">/// 库创建的时间戳</span></span><br><span class="line">  <span class="keyword">char</span>  userid[<span class="number">6</span>];  <span class="comment">/// 用户id</span></span><br><span class="line">  <span class="keyword">char</span>  groupid[<span class="keyword">char</span>]; <span class="comment">/// 组id</span></span><br><span class="line">  <span class="keyword">uint64_t</span> mode; <span class="comment">// 文件的访问模式</span></span><br><span class="line">  <span class="keyword">uint64_t</span> size;  <span class="comment">/// 符号表占总字节大小</span></span><br><span class="line">  <span class="keyword">uint32_t</span> endheader; <span class="comment">/// 头结束标志</span></span><br><span class="line">  <span class="keyword">char</span>   longname[<span class="number">20</span>]; <span class="comment">/// 符号表长名</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Symbol Table 为当前静态库导出的符号表。 它使用symbol_table结构体表示。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symbol_table</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span>  size;  <span class="comment">/// 符号表占用的总字节数</span></span><br><span class="line">  symbol_info syminfo[<span class="number">0</span>]; <span class="comment">/// 符号信息 它的个数是size</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symbol_info</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> symnameoff; <span class="comment">/// 符号表在字符表数据中的偏移值</span></span><br><span class="line">  <span class="keyword">uint32_t</span> objheaderoff; <span class="comment">/// 符号所属的目标文件的文件头在文件中的偏移值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  String Table为字符串表,该结构体存储的字符串信息提供符号表使用，使用 string_table结构体表示。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">string_table</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>  size; <span class="comment">/// 字符表占用的总字节数</span></span><br><span class="line">   <span class="keyword">char</span>  data[size]; <span class="comment">/// 字符串数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  Object Header为目标文件的头,描述了接下来的目标文件的信息。使用object_header结构体表示，具体定义为:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct  object_header &#123;</span><br><span class="line"> char  name[16]; /// 名称</span><br><span class="line"> char timestamp[12]; /// 目标文件创建的时间戳</span><br><span class="line"> char userid[6]; /// 用户id</span><br><span class="line"> char group[char] /// 组id</span><br><span class="line"> uint64_t mode; /// 文件的访问模式</span><br><span class="line"> uint64_t size;  /// 符号表占总字节大小</span><br><span class="line"> uint32_t endheader; /// 头结束标志</span><br><span class="line"> char longname[20]; /// 符号表长名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <code>object_header</code>结构体的布局与<code>symtab_header</code>基本一样、</p>
<p>  在<code>object_header</code>结构体下面紧接着就是具体的目标文件内容, 目标文件是以.o结尾的Mach-O格式的文件，它是由编译器生成的中间文件。 目标文件在它的Mach-O头部被标识为MH_OBJECT类型的文件。</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>使用静态库与动态库固然方便,但无法解决引用外部资源的问题,框架(framework)就是为了解决此问题而发明的。</p>
<h4 id="pkg"><a href="#pkg" class="headerlink" title="pkg"></a>pkg</h4><p>省略。。。。</p>
<h4 id="dmg"><a href="#dmg" class="headerlink" title="dmg"></a>dmg</h4><p>省略。。。。</p>
<h3 id="软件静态分析"><a href="#软件静态分析" class="headerlink" title="软件静态分析"></a>软件静态分析</h3><p>代码静态分析针对的目标是程序代码,通过人工或工具化的形式,对代码进行静态分析，检查程序的语法、结构、过程、接口的正确性，找出代码隐藏的错误和缺陷，如参数不匹配、嵌套语句有歧义、递归错误、非法计算、可能出现的空指针引用等</p>
<h4 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h4><p>本文讨论的静态分析指的是二进制静态分析,即大家常说的软件逆向分析。 软件逆向分析包含了软件的二进制静态分析与动态调试，两种分析方法需要使用不同的分析工具,目前主流的分析工具基本同时包含了静态分析与动态分析功能。</p>
<h5 id="Radare2"><a href="#Radare2" class="headerlink" title="Radare2"></a>Radare2</h5><p>Radare2是一套开源、跨平台的命令行工具集,项目地址为<a href="https://github.com/radare/radare2.支持在Linux、Windows、macOS、Android等主流的系统平台运行,是软件逆向分析工作的必备神器。" target="_blank" rel="noopener">https://github.com/radare/radare2.支持在Linux、Windows、macOS、Android等主流的系统平台运行,是软件逆向分析工作的必备神器。</a></p>
<p>Radare2支持的CPU结构与二进制格式非常多,其中就包含了本书讨论的x86-64平台下的Mach-O格式。 使用Radare2提供的命令行工具可以很方便的反汇编、调试、操作二进制文件。</p>
<p>安装Radare2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">brew install radare2</span><br></pre></td></tr></table></figure>
<p><strong>rabin2</strong>: 在分析二进制前,可以使用rabin2命令查看目标文件的基本信息。 如二进制的文件格式信息、字符串列表、重定位信息、段信息、导出符号等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabin2 -S /usr/bin/python</span><br></pre></td></tr></table></figure>
<p><strong>rasm2</strong>: rasm2是Radare2提供的汇编与反汇编工具。 可以执行 rasm2 -L查看支持的CPU架构。默认是x86架构。</p>
<p>查看十六进制数据“4831c0”表示的反汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rasm2 -a x86 -b 64 -d &apos;4831c0&apos;</span><br><span class="line">xor rax,rax</span><br></pre></td></tr></table></figure>
<p>  也可以执行如下命令查看反汇编代码的机器码</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rasm2 -a x86 -b 64 &apos;mov eax,1&apos;</span><br><span class="line">b801000000</span><br></pre></td></tr></table></figure>
<p>  <strong>rahash2</strong>: 使用rahash2可以很方便的计算字符串或文件的哈希值。执行rahash2 -L可以查看支持的哈希算法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rahash2 -L</span><br></pre></td></tr></table></figure>
<p>执行一下命令可以查看字符串“hello”的sha1的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rahash2 -a sha1 &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>执行下面的命令可以查看python程序的crc32:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rahash2 -a crc32 - &lt; /usr/bin/python</span><br></pre></td></tr></table></figure>
<p><strong>radiff2</strong>: radiff2在分析两个目标文件的差异时非常有用.执行下面的命令可以查看哪里被修改过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ radiff2 -a x86 -b 32 -D ./Sparkle_src   ./Sparkle_crack</span><br></pre></td></tr></table></figure>
<p><strong>rafind2</strong>:该工具既可以作为一个脚本宿主程序,执行自定义的rr2脚本文件,也可以指定环境变量与参数,作为二进制程序的启动程序。</p>
<p><strong>rax2</strong>: 进制转换工具。</p>
<p><strong>r2agent</strong>: 用于远程调试,执行r2agent -a开启监听后,可以在浏览器中远程访问并调试程序</p>
<p><strong>ragg2/ragg2-cc</strong>: 一个自定义的编译器,可以编写代码生成简短的程序。</p>
<p><strong>r2pm</strong>: Radare2包管理工具,用于安装与卸载Radare2插件。</p>
<p><strong>r2/radare2</strong>: Radare2的主程序,集成了以下所有命令的功能。</p>
<h5 id="IDA-Pro"><a href="#IDA-Pro" class="headerlink" title="IDA Pro"></a>IDA Pro</h5><p>IDA Pro是一款功能强大的跨平台反汇编工具与调试器,可以在Linux、Windows与macOS上运行,在逆向工程领域，几乎没有一款工具能够撼动它的地位。</p>
<p>IDA Pro强大的分析功能体现在结构体、交叉引用与符号重命名上。使用flair技术，IDA Pro在分析阶段会自动识别二进制中的符号以及变量的类型。</p>
<p>脚本化与插件支持是IDA Pro另一个强大的功能点。 编写脚本与插件可以将大量的手动工作解放出来，从而自动化的运行任务。对代码段的静态加密、特殊数据及算法的查找等工作,在逆向分析时会经常使用。使用脚本与插件功能，配合动态调试，甚至可以打造出一套完美的自动化脱壳方案</p>
<p>IDA Pro中BinDiff插件支持二进制文件分析和对比。在算法查找上有findcrypt插件，通过在二进制中查找常用的算法的magic魔数,可以直接识别其中可能使用到的加解密与Hash算法。</p>
<h5 id="Hopper"><a href="#Hopper" class="headerlink" title="Hopper"></a>Hopper</h5><p>Hopper是软件逆向工程界的后起之秀。Hopper整体操作和IDA Pro相同,它同样支持数据代码的交叉引用、插件及脚本化支持。但目前编写的插件和脚本没有那么多。</p>
<h4 id="代码分析技术"><a href="#代码分析技术" class="headerlink" title="代码分析技术"></a>代码分析技术</h4><p>软件逆向分析与软件开发设计一样,都有自己的一套方法论。在软件开发领域,不同的应用场景有着不同的软件开发方法,这称为软件开发的设计模式。 设计模式是开发经验的总结和积累,在逆向分析领域，也有一些通用的、没有成文的分析技术。</p>
<h5 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h5><p>拿到程序的第一步就是运行,查看它的运行行为,了解软件的注册机制,通过它的行为初步猜测程序的加密机制与加解密算法。</p>
<h5 id="资源分析"><a href="#资源分析" class="headerlink" title="资源分析"></a>资源分析</h5><p>可以使用<a href="https://www.charlessoft.com/" target="_blank" rel="noopener">NibUnlocker</a>解密nib文件的信息,也可以使用文本编辑器<a href="http://www.barebones.com/" target="_blank" rel="noopener">BBEdit</a>直接打开。</p>
<h5 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h5><p>保存文件的方法通常有以下几种:<br>UserDefault、KeyChain、Core Data、自定义路径的数据文件</p>
<h5 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h5><p>网络数据的抓取，可以使用跨平台网络抓包工具tcpdump,在终端输入以下命令就可以开始抓包,并自动将数据保存到桌面文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -p -vv -s o -w ~/Desktop/data.pcap</span><br></pre></td></tr></table></figure>
<p><a href="https://www.wireshark.org/" target="_blank" rel="noopener">WireShark</a>是跨平台的工具,在macOS平台还可以使用<a href="http://www.tastycocoabytes.com/cpa/index.php" target="_blank" rel="noopener">CocoaPacketAnalyzer</a>、<a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">Charles</a>.</p>
<h3 id="软件动态调试与跟踪"><a href="#软件动态调试与跟踪" class="headerlink" title="软件动态调试与跟踪"></a>软件动态调试与跟踪</h3><h4 id="DTrace"><a href="#DTrace" class="headerlink" title="DTrace"></a><a href="http://dtrace.org/blogs/" target="_blank" rel="noopener">DTrace</a></h4><p>软件追踪技术是一种宏观的软件动态分析技术。通过观察软件运行时的函数调用,初步判断软件的工作流程与原理。</p>
<h5 id="DTrace简介"><a href="#DTrace简介" class="headerlink" title="DTrace简介"></a>DTrace简介</h5><p>DTrace是由SUN公司为Solaris操作系统开发的一款动态跟踪的工具。该工具十分强大，后来被一直到了macOS、BSD以及Linux等操作系统上，主要用于性能分析与故障排除等工作</p>
<h5 id="DTrace示例"><a href="#DTrace示例" class="headerlink" title="DTrace示例"></a>DTrace示例</h5><p>打开终端，输入命令并回车:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dtrace -n &apos;proc::posix_spawn:exec-success &#123;printf(&quot;execname:%s&quot;,execname);&#125;&apos;</span><br></pre></td></tr></table></figure>
<h4 id="D脚本语言"><a href="#D脚本语言" class="headerlink" title="D脚本语言"></a>D脚本语言</h4><p> 上面的脚本语言告诉了DTrace我们关心程序的哪些行为,以及当这些行为触发时需要进行怎样的操作。这种脚本使用的语言名为D语言,不过这个D语言可不是通用编程语言的那个D语言,这是一门专门用DTrace使用的跟踪语言。</p>
<h5 id="脚本的加载方式"><a href="#脚本的加载方式" class="headerlink" title="脚本的加载方式"></a>脚本的加载方式</h5><p>D脚本的加载方式:</p>
<ul>
<li>DTrace直接执行。</li>
<li>DTrace调用脚本文件执行</li>
<li>作为脚本文件直接执行</li>
</ul>
<h4 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h4><p>调试器(Debugger)是一种用于调试其他应用程序的工具.调试器的目的是为了控制和查看被调试程序的运行状态，以便于查找和飘出软件中的bug.</p>
<p>一个完善的调试器一般都具有以下6项功能:</p>
<ul>
<li>查看被调试程序的反汇编代码</li>
<li>断点与追踪功能</li>
<li>单步执行功能</li>
<li>查看被调试程序的变量、寄存器状态</li>
<li>线程调试</li>
<li>栈帧回溯</li>
</ul>
<p>调试器具有强大的跟踪和控制能力,因此，它在逆向工程中毫无疑问的称为了最重要的工具之一，甚至产生了许多专为逆向工程设计的调试器。</p>
<h5 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h5><p>GDB(GNU Debugger)是GNU工具链中提供的一款调试器,可以称得上是现存调试器的元老,功能十分强大,支持的平台和语言数量众多。 GDB也支持macOS和iOS系统,在LLDB没有出现之前,GDB一直是苹果系统上的官方调试器,现在在苹果系统上仍然可用。</p>
<p>虽然GDB主要用作源码级调试和除错,但是由于它支持反汇编,并且调试功能强大,所以在逆向上也会经常用到。</p>
<p>可以使用HomeBrew安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gdb</span><br></pre></td></tr></table></figure>
<p>默认是没有签名的，需要签名或者在root权限下执行</p>
<p>查看签名信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -d -vv /usr/local/bin/gdb</span><br></pre></td></tr></table></figure></p>
<h5 id="LLDB-推荐"><a href="#LLDB-推荐" class="headerlink" title="LLDB(推荐)"></a>LLDB(推荐)</h5><p>LLDB是来自LLVM工具链中的一款调试器,也是目前苹果官方主推的调试器。LLDB的功能与它的前辈GDB非常相似,得益于良好的设计,LLDB解决了GDB中许多让人头疼的问题。LLDB使用C++开发,模块划分清晰,并且有良好的接口,比GDB的MI(Machine Interface)模式更便于与IDE等前端的整合,也更稳定。</p>
<h5 id="IDA-PRO"><a href="#IDA-PRO" class="headerlink" title="IDA PRO"></a>IDA PRO</h5><p>IDA Pro除了强大的静态分析能力,新的版本还有一项极其强大的功能，就是可以在反编译出的伪C代码上进行调试,可以进行单步或者下断点。</p>
<h6 id="Hopper-1"><a href="#Hopper-1" class="headerlink" title="Hopper"></a>Hopper</h6><p>Hopper是近几年新出的一款macOS系统上的逆向工具，支持本地调试与远程调试。 本地调试功能作为GDB与LLDB的前端使用,远程调试需要在远程机器运行Hoper Debugger Server,通过Bonjour协议进行通信。</p>
<h3 id="破解技术"><a href="#破解技术" class="headerlink" title="破解技术"></a>破解技术</h3><h4 id="常见的保护类型"><a href="#常见的保护类型" class="headerlink" title="常见的保护类型"></a>常见的保护类型</h4><h5 id="试用版-amp-序列号"><a href="#试用版-amp-序列号" class="headerlink" title="试用版&amp;序列号"></a>试用版&amp;序列号</h5><h5 id="License"><a href="#License" class="headerlink" title="License"></a>License</h5><h5 id="重启验证与暗桩"><a href="#重启验证与暗桩" class="headerlink" title="重启验证与暗桩"></a>重启验证与暗桩</h5><h5 id="防拷贝技术"><a href="#防拷贝技术" class="headerlink" title="防拷贝技术"></a>防拷贝技术</h5><h5 id="网咯验证"><a href="#网咯验证" class="headerlink" title="网咯验证"></a>网咯验证</h5><h5 id="混合验证"><a href="#混合验证" class="headerlink" title="混合验证"></a>混合验证</h5><h4 id="Hook技术"><a href="#Hook技术" class="headerlink" title="Hook技术"></a>Hook技术</h4><p>Hook中文名是钩子，在软件安全中，意思是将目标函数“钩住”,查看它的参数与返回值,或者修改函数的函数体。</p>
<p><code>DYLD_INSERT_LIBRARIES</code>: 插入库Hook方式,类似于Linux平台的LD_ORELOAD方式。这种Hook方式比较常见,除了可以常见的C与C++开发的程序库外,还可以Hook系统库中函数</p>
<ul>
<li>SymbolTable Hook. 符号表Hook方式,类似于Windows平台的IAT Hook.</li>
<li>Method Swizzing. 方法欺骗。这种Hook方式是macOS的Objecttive Runtime方式独有的，运用于Objective-C/C++与Swift的Hook.</li>
</ul>
<h5 id="DYLD-INSERT-LIBRARIES"><a href="#DYLD-INSERT-LIBRARIES" class="headerlink" title="DYLD_INSERT_LIBRARIES"></a><code>DYLD_INSERT_LIBRARIES</code></h5><p><code>DYLD_INSERT_LIBRARIES</code>是dyld使用的环境变量,使用该变量指定需要插入的动态库就,dyld在加载目标程序时会将指定插入的动态库的符号替换掉目标程序中的符号</p>
<h5 id="SymbolTable-Hook"><a href="#SymbolTable-Hook" class="headerlink" title="SymbolTable Hook"></a><code>SymbolTable Hook</code></h5><p><code>SymbolTable Hook</code>即符号表的Hook,通过对目标程序的符号表做手脚达到hook的目的。 Mach-O程序中的符号分为两种,一种是直接在动态库链接程序是就需要绑定的符号non-lazilysymbol,即非延迟绑定的符号,它保存在<code>__DATA</code>段中的<code>__nl_symbol_ptr</code>节区, 另一种是在程序运行后第一次调用才会绑定的符号<code>lazily_symbol</code>,即延迟绑定的符号。它保存在<strong>DATA段中的`</strong>la_symbol_ptr<code>节区中,延迟绑定符号的绑定操作是在dyld在加载程序时,通过</code>dyld_stub_binder`完成的。这两张表都保存了符号的名称与内存中的地址。符号表Hook的原理就是在镜像的加载绑定符号时,修改符号表指向的内存地址，通过这种“移花接木”的方式来完成Hook.</p>
<p>基于这种思想，Facebook公司发布了开源符号表Hook工具fishhook,fishhook提供了<code>rebind_symbols()</code>与<code>rebind_symbols_image()</code>来实现对当前镜像与指定镜像的符号重绑定工作,这两个方法都是调用<code>rebind_symbols_for_image()</code>来完成一个工作。</p>
<h5 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h5><p>Inline Hook是Windows平台上最常见的Hook技术方案之一,通过修改目标函数的汇编指令,跳转执行用户实现的自定义函数，执行完毕后根据实现需求跳转回原地址执行。</p>
<h5 id="Method-Swizzing"><a href="#Method-Swizzing" class="headerlink" title="Method Swizzing"></a>Method Swizzing</h5><p>Method Swizzing直译为方法欺骗。这种Hook方式基于Objective-C运行时库的动态特性。调用一个方法<code>Objective-C</code>，本质上想对象发送一个消息，查找消息依赖于方法的名字。<code>Objective-C</code>提供了一组底层的API,允许开发人员添加、修改、交换类的方法、变量、协议、属性等。</p>
<ul>
<li>clas_addMethod 为类添加一个方法</li>
<li>method_setImplementation 为一个方法设置实现</li>
<li>class_replaceMethod 替换类方法的实现，无则add,有则exchange.</li>
<li>class_addProtocol 为类添加协议</li>
<li>class_addProperty 为类添加属性</li>
<li>method_getImplementation 获取方法的实现</li>
<li>method_exchangeImplementations</li>
</ul>
<p>swift程序的Methos Swizzing需要注意以下两点:</p>
<ul>
<li>需要hook的方法所在类必须继承自NSObject,因为只有NSObject的子类才能接受消息</li>
<li>需要hook的方法必须具有dynamic属性，否则，method_exchangeImplementaions()的调用就会失败。</li>
</ul>
<h4 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h4><p>代码注入是将外部程序代码(通常是动态库)通过静态库或动态方式注入到目标文件或程序中的一种技术,也是目前计算机病毒使用比较频繁的一种技术，静态注入会修改目标程序,将需要执行的代码插入到程序中国,是一种侵入式的注入技术，动态注入与之相反,它是在运行时将代码注入到目标进程中，进行远程修改的方式,是一种非侵入式的注入。</p>
<h5 id="静态注入"><a href="#静态注入" class="headerlink" title="静态注入"></a>静态注入</h5><p>静态注入的一大作用就是对Mach-O文件进行补丁操作,当目标程序要补丁的汇编代码太多,而目标程序中又找不到空闲地址时,可以将要补丁的代码在一个新的动态中中作为函数实现,然后将其静态注入到目标程序中,最后修改目标程序,跳转到注入的动态库中执行。</p>
<p>静态注入首先就是在Mach-O程序中添加一个LC_LOAD_DYLIB加载命令,然后修正Mach-O头部的加载命令个数与大小的字段。 该功能可以自己实现,也可以通过optool等工具。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line">void hook_init()</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hook init&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的含义就是，当动态库被加载的时候，输出信息“hello init”.<br>使用optool静态注入生成的文件没有课执行的权限,在运行之前，需要执行<code>chmod a+x</code> 加上可执行权限。</p>
<p>除了使用<code>optool</code>外,还可以使用专门的Mach-O静态注入工具<code>insert_dylib</code>。</p>
<p>在插入动态库是，会涉及一个动态库加载路径的问题，为了方便管理动态库的加载路径，系统允许指定以下三种特殊路径来搜索动态库.</p>
<ul>
<li><p><code>@executable_path</code></p>
<p>   这种方式适合将动态库绑定到程序中,动态库的搜索路径将会与应用程序的同一目录下</p>
</li>
<li><p><code>@loader_path</code> </p>
<p>   <code>@loader_path</code>主要用来解决各个框架与插件依赖的动态库加载的问题。<code>@loader_path</code>指定的路径是当前加载的Mach-O二进制的所在路径,对于可执行程序的主程序来说，它与<code>@executable_path</code> 没有区别,都指向了可执行程序所在的目录； 对于插件来说,它通常会被多个程序与框架调用。  如果他依赖一个动态库,通常就需要与动态库的安装路径<code>INSTALL_PATH</code>配合工作。 <code>INSTALL_PATH</code> 指的是动态库的安装路径,简单的讲，每个dylib动态库都会有一个<code>LC_ID_DYLIB</code> 加载命令, <code>INSTALL_PATH</code>指的是该动态库的安装路径,简单的说,每个dylib动态库都会有一个<code>LC_ID_DYLIB</code>加载命令,<code>INSTALL_PATH</code>就是该加载命令中name字段执行的dylib路径。  修改动态库的<code>INSTALL_PATH</code>可以借助<code>install_name_tool</code>来完成,只需要在命令行执行 <code>install_name_tool  -change</code></p>
</li>
</ul>
<ul>
<li><p><code>@rpath</code>    </p>
<p><code>@rpath</code> 与前面两个路径不同,他不指定具体的一个路径,而是指定多个路径的一个列表。使用<code>LC_RPATH</code> 加载命令表示每一个rpath.  <code>@rpath</code>可以在开发Xcode中设置,也可以编译好程序后,使用<code>install_name_tool</code>工具传入 -rath选项进行修改。 可以使用<code>otool</code>工具,查看他们的<code>LC_PATH</code>信息。</p>
</li>
</ul>
<h5 id="动态注入"><a href="#动态注入" class="headerlink" title="动态注入"></a>动态注入</h5><p>与静态注入相对的技术是动态注入,在一些情况下,静态注入技术不再适用。可执行文件的加密与反调试很严格,代码是通过动态加密的,在这种情况下,代码中内存是解密了的，可以通过动态注入来达到代码的动态补丁效果; 另外,程序是长时间运行在内存中的，由于一些原因，不允许执行静态注入，相对来说，动态注入是一种更加稳妥的方案。</p>
<p>动态注入的技术原理是,首先通过task_for_pid()获取指定进程的任务信息,接着需要调用vm_protect()更改远程进程的地址空间为可读可写可执行。 完成后调用vm_read()与vm_write() 对远程进程的地址空间进行读写操作。 目前网上开源的动态注入工具<code>osxinj</code>可以完成该工作。<code>osxinj</code>的源代码包含了工具与演示程序的源代码。</p>
<p>动态注入使用到了task_for_pid(),因此，使用该技术前需要关闭Rootless，而且，这种技术对系统限制的进程是不起作用的。</p>
<h5 id="Hook与注入框架"><a href="#Hook与注入框架" class="headerlink" title="Hook与注入框架"></a>Hook与注入框架</h5><p>在对程序实施逆向分析期间,Hook与注入技术一般需要配合使用，此时对于分析工作而言,一个强大的Hook与注入框架是十分重要的,依赖框架提供的对外接口,可以方便快捷的做出Hook插件来辅助分析。</p>
<p>iOS平台鼎鼎大名的有Mobile Substrate框架,它同时支持代码Hook与代码注入，既可以用它Hook程序中的方法,应用于非越狱环境，也可以用它来做系统级别的注入工具的运行基础平台，iOS平台的逆向分析与越狱工作的插件的开发几乎离不开它。</p>
<ul>
<li><p><code>CaptainHook</code></p>
<p>这是一款轻量级的Hook框架,不支持注入功能,一般使用它开发注入库,然后配合静态注入工具使用,可以理解为它是一款优秀的注入伴侣</p>
</li>
</ul>
<ul>
<li><p><code>Frida</code></p>
<p>Frida是一款跨平台的程序注入框架,支持在Windows、macOS、Linux、iOS、Android等多个主流的操作系统上运行，支持向目标程序中注入JavaScript代码，同时也是高度可移植的，支持不同系统上不同语言的绑定,最新的frida可以使用Swift、C#、C等多种语言来编写脚本。</p>
<p>安装Frida</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install frida</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>frida</p>
<p>Frida的命令行交互工具,支持命令行模式下的进程注入与相关的内容访问。<br><code>frida xxx</code> </p>
<ul>
<li><code>frida-discover</code></li>
</ul>
<p><code>frida-discover</code>用来通过Hook注入目标程序,发现类中的内部方法，之后方便frida-trace命令使用</p>
<ul>
<li><p><code>frida-ls-devices</code><br><code>frida-ls-devices</code>列出连接到电脑上的设备</p>
</li>
<li><p><code>frida-ps</code> </p>
</li>
</ul>
<p><code>frida-ps</code> 列举本机与连接到电脑上手机的进程ID与进程名。</p>
<ul>
<li><code>frida-trace</code><br><code>frida-trace</code>功能很强大,可以动态追踪程序的函数调用。</li>
</ul>
</li>
</ul>
<ul>
<li><code>Cycript</code><br><code>Cycript</code>在iOS逆向界几乎无人不知,它是一款同时支持iOS/macOS平台动态运行时修改的Hook与注入框架，它几乎可以访问程序进程空间中所有的类与方法，同时支持修改它们的数据与行为，功能十分强大。</li>
</ul>
<h3 id="反破解技术"><a href="#反破解技术" class="headerlink" title="反破解技术"></a>反破解技术</h3><h4 id="反破解技术类型"><a href="#反破解技术类型" class="headerlink" title="反破解技术类型"></a>反破解技术类型</h4><p><code>检验保护</code>: 校验保护主要是保护软件的完整性,被破解的软件与原软件相比,最明显的区别就是其完整性遭到破坏。检测软件是否完整,就能知道软件是否被破解是否被破解篡改的</p>
<p><code>代码保护</code>: 破解人员拿到软件后,第一时间就是拿反汇编分析工具对软件二进制反汇编代码进行分析,提高软件分析的门槛与反汇编代码的难度,可以大大提高破解人员的分析成本,甚至将大量的初级破解人员拦在门外</p>
<p><code>数据保护</code>: 软件会与各种各样的数据打交道,对于软件中使用到的敏感数据,合理安全的使用于存储它们，也是十分重要的</p>
<p><code>调试器对抗</code>: 破解人员为了掌握软件流程或查找关键代码,可能会用到动态调试技术。在软件中加入反调试功能,可以在很大程度上防止程序被恶意调试。</p>
<p><code>Hook检测</code>: 如何函数被Hook了,那代码执行的流程就会受到篡改破坏,这不是软件开发人员希望看到的结果,在软件代码中加入Hook检测十分有必要。</p>
<p><code>注入检测</code>: 与Hook一样,软件在运行时有可能被注入了外部动态库,软件在运行时应该能够察觉并阻止他们。</p>
<h4 id="校验保护"><a href="#校验保护" class="headerlink" title="校验保护"></a>校验保护</h4><p><code>完整性检查</code>: 通过信息摘要算法可检查数据完整性</p>
<p><code>代码签名验证</code>:证书签名</p>
<p><code>沙盒检测</code>:</p>
<p><code>来源检测</code>:</p>
<h4 id="代码保护"><a href="#代码保护" class="headerlink" title="代码保护"></a>代码保护</h4><p>在逆向分析程序时,分析人员开展工作的入口主要有:字符串、符号名称与反汇编代码。查找符号特征，定位关键代码，基本都需要依赖这些直观的信息。代码的保护目的主要就是对这些信息进行保护，增加软件逆向分析的难度。</p>
<h5 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h5><p> 不同语言生成的代码特性不同,代码保护的方法也不一样。在安卓开发的SDK内,就有内置代码混淆工具Proguard. 对于C/C++语言编写的代码,主要的代码保护手段就是代码混淆、SMC与软件加密壳保护。</p>
<p> 基于Objective-C的代码混淆，比较容易实现的就是对符号名称的混淆。 <code>Camo</code>一款全自动化的代码混淆工具,通过搜索源代码目录,找出所有的Objective-C代码中的类名、方法名、属性名的符号,然后把这些名称使用#define重定向成随机的字符串，写到一个.h文件中，并加入预处理头文件。</p>
<h5 id="SMC"><a href="#SMC" class="headerlink" title="SMC"></a>SMC</h5><p>SMC是 <code>Self Mobifying Code</code>的编写,即自修改代码。SMC程序的主要特点是在运行时动态修改自己的数据。这类程序在执行时会在内存中动态解密数据与代码,程序初始化完成后,加密的数据与代码会在内存中解密完毕。 根据实现的不同,SMC可以针对个别具有重要功能的函数,也可以加密整个代码段。 由于它加载初始化完成即解密完成的特点,通常该技术会配合代码反调试一起使用,这样在程序破解难度会大大提高。 知名的反汇编软件Hoper在自身软件保护上就大量使用了SMC技术。</p>
<h5 id="代码校验"><a href="#代码校验" class="headerlink" title="代码校验"></a>代码校验</h5><p>代码校验技术在Windows平台的加密壳使用广泛。 采用这种技术加密过的程序的特点是:运行时开启单独的线程动态校验运行的代码,如果代码被修改了就会运行异常。 这种保护方式运用于代码防补丁与动态调试上。 </p>
<h5 id="壳保护"><a href="#壳保护" class="headerlink" title="壳保护"></a>壳保护</h5><p>软件外壳保护技术起源于DOS时代,之所以称之为壳,是因为加密后的程序通常整体经过压缩或加密,软件自身的内容需要在内存中解压解密才能正常运行,加密代码位于软件的外层,就像昆虫的茧一样,牢牢的保护自己。</p>
<p>软件加壳根据功能分为压缩壳与加密壳，单纯的压缩壳只是为了缩减源程序的大小,核心都放在了压缩算法的压缩比与解密速度上。 加密壳注重代码加密,主要用于防止软件被逆向工程分析,在对抗静态分析与动态调试上都比压缩壳强出太多。  复合型的加密壳也带有代码压缩功能,这类壳相对来说更为复杂</p>
<p>传统的加密壳经过几次技术上的迭代更新后,演变成了更加高级、加密强度更大的虚拟机执行壳,这类壳模拟计算机处理器的指令集系统,使用自身的指令系统模拟替代原指令集。 但是程序的体积与代码的流程都增加了许多,运行速度也会慢许多，相应的软件的安全强度也提高了一个级别。</p>
<p>一些跨平台的软件外壳支持对它们进行压缩操作,比较著名的有跨平台开源的压缩壳 <a href="https://github.com/upx/upx" target="_blank" rel="noopener">upx</a>. 软件的兼容性好,支持macOS上最新版本的Swift开发的程序进行压缩。 HomeBrew中也有它的移植版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install upx</span><br></pre></td></tr></table></figure>
<p>对程序压缩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx xxx</span><br></pre></td></tr></table></figure>
<p>执行压缩后的程序,在没有加壳的程序相比,在启动速度上几乎没有区别,程序功能也是正常的。没有任何异常。</p>
<h4 id="数据保护"><a href="#数据保护" class="headerlink" title="数据保护"></a>数据保护</h4><p>从宏观上讲,软件是有代码与数组组成的,代码与数据都是逆向分析工程的攻击面，当代码强度较大、分析成本比较高时，就会从软件的数据开始,对其进行数据分析与挖掘。</p>
<h5 id="数据清除"><a href="#数据清除" class="headerlink" title="数据清除"></a>数据清除</h5><p>软件在运行的过程中会生成很多临时的数据,这些数据可能无关紧要，也可能是个人隐私需要严加保护。只要数据使用有一点不规范，就可能导致整个软件的保护机制或安全机制被彻底击溃。、</p>
<h5 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h5><p>软件开发人员常用的数据存储方式有以下几种:</p>
<ul>
<li>NSUserDefault  最常用也是最简便的保存数据的方式</li>
<li>Core Data      Core Data数据库方式保存</li>
<li>类序列化       直接保护类的数据到plist文件</li>
<li>原始数据  调用原生的文件I/O接口进行读写文件</li>
<li>第三方库  使用第三方库的操作数据, 如sqlite、JSON操作库</li>
<li>Keychain. Keychain方式保存数据</li>
</ul>
<h5 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h5><p>HTTPS通信的另一种安全技术—SSL Pinning.SSL Pinning并没有官方的定义与解释,通俗的理解就是:对SSL通信中的服务器发送过来的整肃做绑定检查。</p>
<ul>
<li>服务器证书检查。 该需求与ATS检测通信链路是否安全一样,SSL pinning将服务器发送过来的证书与本地事先保存好的服务器证书或者证书的指纹信息做对比,判断通信是否安全</li>
</ul>
<ul>
<li>自签名证书验证。  有时候,软件开发人员可能出于成本考虑,自己的服务器的证书并没有获取公开可信的CA的证书,而是使用自签名的CA签发的。 这样的证书会被系统认为是不可信任的，但是又是安全可信的，此时就需要我们自定义SSL验证过程，让其能够验证这类证书。 通常的做法就是在SSL Pinning中导入自己的没有私钥的根证书</li>
</ul>
<h4 id="调试器对抗"><a href="#调试器对抗" class="headerlink" title="调试器对抗"></a>调试器对抗</h4><p>逆向分析人员经常会使用调试器来动态调试程序,防止程序被恶意调试的方法是检测到调试器后立即退出程序，或者加反调试代码，让调试器无法调试。</p>
<h5 id="调试器检测"><a href="#调试器检测" class="headerlink" title="调试器检测"></a>调试器检测</h5><p>软件开发人员一直在积极的寻找检测调试器的方法,安全人员通常通过对比正常运行程序与被调试程序的差异,来判断程序是否被调试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">amibeingdebugged_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">mach_msg_type_number_t</span>  count = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">exception_mask_t</span> masks[EXC_TYPES_COUNT];</span><br><span class="line"> mach_port ports[EXC_TYPES_COUNT];</span><br><span class="line"> <span class="keyword">exception_behavior_t</span> behaviors[EXC_TYPES_COUNT];</span><br><span class="line"> <span class="keyword">thread_state_flavort_t</span> flavors[EXC_TYPES_COUNT];</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">exception_mask_t</span> mask = EXC_MASK_ALL &amp; ~(EXC_MASK_RESOURCE | EXC_MASK_GUARD);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">kern_return_t</span>  result = task_get_exception_ports(mach_task_self(), mask, mask,&amp;count, ports, behavior, flavor);</span><br><span class="line"> <span class="keyword">if</span>(result == KERN_SUCCESS)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">mach_msg_type_number_t</span> portIndex = <span class="number">0</span>; portIndex &lt; count; portIndex ++)&#123;</span><br><span class="line">     <span class="keyword">if</span>(MACH_PORT_VALID(ports[portIndex])) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>task_get_exception_ports()</code>检查程序的任务异常端口是否有效,macOS系统拥有三个异常端口: 线程异常端口(Thread Exception Port)、任务异常端口(Task Exception Port)和主机异常端口(Host Exception Port). 当异常发生时,它会以消息的形式在这三个端口上进行传递,默认情况下,当线程异常端口为空,且任务异常端口继承自fork()调用,程序正常运行时,<code>task_get_exception_ports()</code>检测<code>mach_task_self()</code>返回自身任务端口为空; 如果程序被调试器调试，后者会为被调试程序设置一一个异常处理器，用来捕捉程序发送到任务异常端口的异常。此时，调试器设置异常处理器挂钩了异常端口,检测任务异常端口返回就不为空了。</p>
<p>被调试的程序与正常程序的另一个不同点是,当程序进程的底层内核信息的一个p_flag标志位被调试时,它的<code>p_TRACED</code>会被设置。这种检测方法与Android系统上检查TracePid类似。</p>
<p>除了通过对比程序进行时的系统特征来检测调试外,还可以使用程序运行时的动态特片来判断程序是否被调试。 比较常见的思路是，在可能被调试的代码的头与尾,分别获取程序运行的时间值,并计算时间差。  程序运行时的动态特点还有断点检测法，软件断点的本质就是在所在行的反汇编指令改为断点指令 int 3,对应的机器码为0xCC。 只需要找到函数的地址,循环扫描代码中是否包含0xCC,就可以判断方法是否被设置了软件的断点。</p>
<p>还有一种传统的Linux上的检测调试器的方法,依赖于<code>ptrace()</code>调用。</p>
<h5 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h5><p>检测到调试器后,就要做相应的反应，可以直接退出程序，也可以将程序的某些功能关闭。</p>
<p>使用<code>ptrace()</code>检测调试器时,使用PT_TRACE_ME标志并没有效果,但苹果系统提供了一个专属的标志<code>PT_DENY_ATTACH</code>.来阻止调试器附加程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void amibeingdebugged_3&#123;</span><br><span class="line">   ptrace(PT_DENY_ATTACH, 0, 0, 0);</span><br><span class="line">   printf(&quot;amibeingdebugged_3 ok\n&quot;);</span><br><span class="line">   return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PT_DENY_ATTACH</code>标志检测到程序被调试器附加后,没有返回结果给开发人员,而是直接退出程序。</p>
<p>单纯的使用一种方式来检测调试器是很容易被绕过的,拿<code>ptrace(</code>)调用来说,完全可以使用gdb或lldb载入要分析的程序,对该调用下断点,然后直接返回结果。</p>
<h4 id="Hook检测"><a href="#Hook检测" class="headerlink" title="Hook检测"></a>Hook检测</h4><p>逆向分析人员经常使用Hook技术来动态修改程序的逻辑,破坏程序原来的运行流程。 开发者有必要在程序中加入Hook检测代码,防止程序被恶意Hook.</p>
<h5 id="Method-Swizzing检测"><a href="#Method-Swizzing检测" class="headerlink" title="Method Swizzing检测"></a>Method Swizzing检测</h5><p>Objective-C代码被Hook的方案主要是Method Swizzing,检查方法是判断程序调用时的一个隐藏参数 <strong>cmd.当一个Objective-C方法被调用时,它表示的是当前方法的Selector实例,只需要判断</strong>cmd的方法名称与编译时指定的方法名称是否一致，就可以判断是否被swizzing.</p>
<h5 id="dyld-Hook检测"><a href="#dyld-Hook检测" class="headerlink" title="dyld Hook检测"></a>dyld Hook检测</h5><p>在运行程序时,使用的环境变量 <code>DYLD_INSERT_LIBRARIES</code> 指定插入的动态库方式,可以实现dyld的Hook技术。 判断程序是否被Hook,一种简单的方式就是在程序启动时检测环境变量列表中是否包含 <code>DYLD_INSERT_LIBRARIES</code> 如果它的值不为空,就说明程序是被Hook了。</p>
<p>获取程序启动时的环境变量可以使用getenv()，这是一个标准的C库函数，定义在stdlib.h中，使用该方法检测环境变量来判断Hook的方式,是跨平台通用的。</p>
<p>除了通过环境变量检测dyld Hook，还有一种方式可以阻止程序插入库方式的Hook,这依赖于dyld的工作方式，动态库加载时,会调用<code>processRestricted()</code>判断进程是否是受限的。</p>
<p><code>hasRestrictedSegment()</code>检测程序是否包含<code>__RESTRICT</code>,<code>__restric</code>节区，如果有就返回<code>restrictedBySegment()</code>。受限后的进程在加载时会忽略所有<code>DYLD_开头</code>的环境变量,<code>DYLD_INSERT_LIBRARIES</code>自然就会被忽略。 要创建这样的节区,可以在 Other Linker Flags后,在里面就如下面的命令行参数</p>
<p><code>-WL, -sectcreate, __RESTRICT,__restrict,/dev/null</code></p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Micah
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/" title="Mac软件安全与逆向分析">https://lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/lvchenqiang.github.io/tags/笔记/" rel="tag"># 笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/lvchenqiang.github.io/2017/08/19/Swift之Alamofire网络请求、取消请求/" rel="next" title="Swift之Alamofire网络请求、取消请求">
                <i class="fa fa-chevron-left"></i> Swift之Alamofire网络请求、取消请求
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/lvchenqiang.github.io/2017/11/10/installpython3/" rel="prev" title="mac下安装 python3">
                mac下安装 python3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/lvchenqiang.github.io/image/avatar.png" alt="Micah">
            
              <p class="site-author-name" itemprop="name">Micah</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/lvchenqiang.github.io/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/lvchenqiang.github.io/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/lvchenqiang.github.io/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lvchenqiang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/lvchenqiang_" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-csdn"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mac软件安全与逆向分析"><span class="nav-number">1.</span> <span class="nav-text">Mac软件安全与逆向分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何分析MacOS软件"><span class="nav-number">1.1.</span> <span class="nav-text">如何分析MacOS软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安装Clang"><span class="nav-number">1.1.1.</span> <span class="nav-text">安装Clang</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HT-Editor"><span class="nav-number">1.1.2.</span> <span class="nav-text">HT Editor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Homebrew"><span class="nav-number">1.1.3.</span> <span class="nav-text">Homebrew</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统安全架构"><span class="nav-number">1.2.</span> <span class="nav-text">系统安全架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#架构概述"><span class="nav-number">1.2.1.</span> <span class="nav-text">架构概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统调用"><span class="nav-number">1.2.2.</span> <span class="nav-text">系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间通信"><span class="nav-number">1.2.3.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全框架"><span class="nav-number">1.2.4.</span> <span class="nav-text">安全框架</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CommonCrypto"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">CommonCrypto</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Keychain"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">Keychain</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安全传输"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">安全传输</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统安全机制"><span class="nav-number">1.2.5.</span> <span class="nav-text">系统安全机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#File-Vault2"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">File Vault2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码签名"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">代码签名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ASLR-KASLR"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">ASLR/KASLR</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#沙盒"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">沙盒</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Rootless"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">Rootless</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Gatekeeper"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">Gatekeeper</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件的内幕"><span class="nav-number">1.3.</span> <span class="nav-text">软件的内幕</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Bundle"><span class="nav-number">1.3.1.</span> <span class="nav-text">Bundle</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通用二进制格式"><span class="nav-number">1.3.2.</span> <span class="nav-text">通用二进制格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mach-O文件格式"><span class="nav-number">1.3.3.</span> <span class="nav-text">Mach-O文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Mach-O简介"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Mach-O简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mach-O头部"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Mach-O头部</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#加载命令"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">加载命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LC-CODE-SIGNATURE"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">LC_CODE_SIGNATURE</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#代码签名验证流程"><span class="nav-number">1.3.3.4.1.</span> <span class="nav-text">代码签名验证流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#代码加密流程"><span class="nav-number">1.3.3.4.2.</span> <span class="nav-text">代码加密流程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LC-SEGMENT"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">LC_SEGMENT</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态库"><span class="nav-number">1.3.4.</span> <span class="nav-text">动态库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dyld"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">dyld</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态库的加载"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">动态库的加载</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态库"><span class="nav-number">1.3.5.</span> <span class="nav-text">静态库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#静态库的格式"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">静态库的格式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#框架"><span class="nav-number">1.3.6.</span> <span class="nav-text">框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pkg"><span class="nav-number">1.3.7.</span> <span class="nav-text">pkg</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dmg"><span class="nav-number">1.3.8.</span> <span class="nav-text">dmg</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件静态分析"><span class="nav-number">1.4.</span> <span class="nav-text">软件静态分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分析工具"><span class="nav-number">1.4.1.</span> <span class="nav-text">分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Radare2"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Radare2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IDA-Pro"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">IDA Pro</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hopper"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">Hopper</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码分析技术"><span class="nav-number">1.4.2.</span> <span class="nav-text">代码分析技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#行为分析"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">行为分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#资源分析"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">资源分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据分析"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">数据分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流量分析"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">流量分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件动态调试与跟踪"><span class="nav-number">1.5.</span> <span class="nav-text">软件动态调试与跟踪</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DTrace"><span class="nav-number">1.5.1.</span> <span class="nav-text">DTrace</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DTrace简介"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">DTrace简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DTrace示例"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">DTrace示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D脚本语言"><span class="nav-number">1.5.2.</span> <span class="nav-text">D脚本语言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#脚本的加载方式"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">脚本的加载方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调试器"><span class="nav-number">1.5.3.</span> <span class="nav-text">调试器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GDB"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">GDB</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LLDB-推荐"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">LLDB(推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IDA-PRO"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">IDA PRO</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Hopper-1"><span class="nav-number">1.5.3.3.1.</span> <span class="nav-text">Hopper</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#破解技术"><span class="nav-number">1.6.</span> <span class="nav-text">破解技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常见的保护类型"><span class="nav-number">1.6.1.</span> <span class="nav-text">常见的保护类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#试用版-amp-序列号"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">试用版&amp;序列号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#License"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">License</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#重启验证与暗桩"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">重启验证与暗桩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#防拷贝技术"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">防拷贝技术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#网咯验证"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">网咯验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#混合验证"><span class="nav-number">1.6.1.6.</span> <span class="nav-text">混合验证</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hook技术"><span class="nav-number">1.6.2.</span> <span class="nav-text">Hook技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DYLD-INSERT-LIBRARIES"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">DYLD_INSERT_LIBRARIES</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SymbolTable-Hook"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">SymbolTable Hook</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Inline-Hook"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">Inline Hook</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Method-Swizzing"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">Method Swizzing</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码注入"><span class="nav-number">1.6.3.</span> <span class="nav-text">代码注入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#静态注入"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">静态注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#动态注入"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">动态注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hook与注入框架"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">Hook与注入框架</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反破解技术"><span class="nav-number">1.7.</span> <span class="nav-text">反破解技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反破解技术类型"><span class="nav-number">1.7.1.</span> <span class="nav-text">反破解技术类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#校验保护"><span class="nav-number">1.7.2.</span> <span class="nav-text">校验保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码保护"><span class="nav-number">1.7.3.</span> <span class="nav-text">代码保护</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#代码混淆"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">代码混淆</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SMC"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">SMC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码校验"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">代码校验</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#壳保护"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">壳保护</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据保护"><span class="nav-number">1.7.4.</span> <span class="nav-text">数据保护</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据清除"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">数据清除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据存储"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">数据存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据传输"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">数据传输</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调试器对抗"><span class="nav-number">1.7.5.</span> <span class="nav-text">调试器对抗</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#调试器检测"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">调试器检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#反调试"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">反调试</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hook检测"><span class="nav-number">1.7.6.</span> <span class="nav-text">Hook检测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Method-Swizzing检测"><span class="nav-number">1.7.6.1.</span> <span class="nav-text">Method Swizzing检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#dyld-Hook检测"><span class="nav-number">1.7.6.2.</span> <span class="nav-text">dyld Hook检测</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Micah</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/lvchenqiang.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Micah.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://lvchenqiang.github.io/2017/09/17/Mac软件安全与逆向分析/';
          this.page.identifier = '2017/09/17/Mac软件安全与逆向分析/';
          this.page.title = 'Mac软件安全与逆向分析';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Micah.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  












  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'ob6xEevaCzifOdzvnfIrxSJ7-gzGzoHsz',
        appKey: 'ibWrHDRgAsLSxr5UnNH7Tb2n',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>

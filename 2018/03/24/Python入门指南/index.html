<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lvchenqiang.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lvchenqiang.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/lvchenqiang.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/lvchenqiang.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/lvchenqiang.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/lvchenqiang.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/lvchenqiang.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="笔记,">










<meta name="description" content="开篇Python 是一门非常容易上手的语言，网上也有很多的资源和教程。">
<meta name="keywords" content="笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Python入门指南">
<meta property="og:url" content="https://lvchenqiang.github.io/2018/03/24/Python入门指南/index.html">
<meta property="og:site_name" content="大前端之路">
<meta property="og:description" content="开篇Python 是一门非常容易上手的语言，网上也有很多的资源和教程。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2018/03/24/Python入门指南/metaclass.png">
<meta property="og:updated_time" content="2019-02-27T02:08:14.788Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python入门指南">
<meta name="twitter:description" content="开篇Python 是一门非常容易上手的语言，网上也有很多的资源和教程。">
<meta name="twitter:image" content="https://lvchenqiang.github.io/lvchenqiang.github.io/2018/03/24/Python入门指南/metaclass.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/lvchenqiang.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lvchenqiang.github.io/2018/03/24/Python入门指南/">





  <title>Python入门指南 | 大前端之路</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  

  <div class="container  page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/lvchenqiang.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大前端之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/lvchenqiang.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/lvchenqiang.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/lvchenqiang.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/lvchenqiang.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/lvchenqiang.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lvchenqiang.github.io/lvchenqiang.github.io/2018/03/24/Python入门指南/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micah">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/lvchenqiang.github.io/image/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大前端之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python入门指南</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T21:19:11+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/lvchenqiang.github.io/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/lvchenqiang.github.io/2018/03/24/Python入门指南/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/24/Python入门指南/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>Python 是一门非常容易上手的语言，网上也有很多的资源和教程。</p>
<a id="more"></a>
<p>但是python也是一门很难精通的语言，本文主要是实现对 Python 的整体知识结构形成初步的概念、了解 Python 特有的知识点，比如装饰器、上下文、生成器等等，不仅会写 Demo，还对背后的原理有一定了解等</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>请不要在学习 Python2 还是 Python3 之间犹豫了，除非你很明确自己只接触 Python2，否则就从 Python3 学起。</p>
<p>调试工具可以选择 PyCharm 、Visual Studio Code 、CodeRunner。推荐使用后面两者,比PyCharm轻量级，功能也很方便开发。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h5><p>如果要对数组中的所有内容做一些修改，可以用 for 循环或者 map 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> array: </span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">        small.append(n * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(small)  <span class="comment"># [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<p>比较地道的 Python 写法是使用列表推导：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = [n * <span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> array <span class="keyword">if</span> n &lt; <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><code>for in</code> 可以写两次，类似于嵌套的 for 循环，会得到一个笛卡尔积:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signs = [<span class="string">'+'</span>, <span class="string">'-'</span>]</span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">ascii = [<span class="string">'&#123;sign&#125;&#123;number&#125;'</span>.format(sign=sign, number=number) </span><br><span class="line">        <span class="keyword">for</span> sign <span class="keyword">in</span> signs <span class="keyword">for</span> number <span class="keyword">in</span> numbers]</span><br><span class="line"><span class="comment"># 得到：['+1', '+2', '-1', '-2']</span></span><br></pre></td></tr></table></figure>
<h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><p>元组可以简单的理解为不可变的数组，也就是没有 append、del 等方法，一旦创建，就无法新增或删除元素，元素自身的值也不能改变，但元素内部的属性是否可变并不受元组的影响，这一点符合其他语言中的常识。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, [])</span><br><span class="line">t[<span class="number">0</span>] = <span class="number">3</span>  <span class="comment"># 抛出错误 TypeError: 'tuple' object does not support item assignment</span></span><br><span class="line">t[<span class="number">1</span>].append(<span class="number">2</span>)  <span class="comment"># 正常运行，现在的 t 是 (1, [2])</span></span><br></pre></td></tr></table></figure>
<p>除了不可变性以外，有时候元组也会被当做不具名的数据结构，这时候元素的位置就不再是可有可无的了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coordinate = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>)</span><br><span class="line"><span class="comment"># coordinate 的第一个位置用来表示经度，第二个位置表示纬度</span></span><br></pre></td></tr></table></figure>
<p>在解析元组数据时，可以一一对应的写上变量名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, b = t <span class="comment"># a = 1, b = 2</span></span><br></pre></td></tr></table></figure>
<p>有时候变量名比较长， 但我只关心其中某一个，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, _ = t <span class="comment"># a = 1</span></span><br></pre></td></tr></table></figure>
<p>如果元组中元素特别多，即使挨个写下划线也比较累，可以用 <code>*</code> 来批量解包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">first, *middle, last = t</span><br><span class="line"><span class="comment"># first = 1</span></span><br><span class="line"><span class="comment"># middle = [2, 3, 4]</span></span><br><span class="line"><span class="comment"># last = 5</span></span><br></pre></td></tr></table></figure>
<p>当然，如果元素数量较多，含义较复杂，我还是建议使用具名元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">People = collections.namedtuple(<span class="string">'People'</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>])</span><br><span class="line">p = People(<span class="string">'betterswifter'</span>, <span class="string">'22'</span>)</span><br><span class="line">p.name <span class="comment"># betterswifter</span></span><br></pre></td></tr></table></figure>
<p>具名元组更像是一个不能定义方法的简化版的类，能提供友好的数据展示。</p>
<p>元组的一个小技巧是可以避免用临时变量来交换两个数的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = 1 </span><br><span class="line">b = 2</span><br><span class="line">a, b = b, a</span><br><span class="line"># a = 2, b = 1</span><br></pre></td></tr></table></figure>
<h5 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h5><p>切片的基本格式是 <code>array[start🔚step]</code>，表示对 array 在 start 到 end 之前以 step 为间隔取切片。注意这里的区间是 [start, end)，也就是左闭右开。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello'</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 表示取 s 的第 0、2、4 个字符，结果是 'hlo'</span></span><br></pre></td></tr></table></figure>
<p>再举几个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>:<span class="number">5</span>]  <span class="comment"># 不写 step 默认就是 1，因此得到 'hello'</span></span><br><span class="line">s[<span class="number">1</span>:]   <span class="comment"># 不写 end 默认到结尾，因此还是得到 'ello'</span></span><br><span class="line">s[n:]   <span class="comment"># 获取 s 的最后 len(s) - n 个元素</span></span><br><span class="line">s[:<span class="number">2</span>]   <span class="comment"># 不写 start 默认从 0 开始，因此得到 'he'</span></span><br><span class="line">s[:n]   <span class="comment"># 获取 s 的前 n 个元素</span></span><br><span class="line">s[:<span class="number">-1</span>]  <span class="comment"># 负数表示倒过来数，因此这会刨除最后一个字符，得到 'hell'</span></span><br><span class="line">s[<span class="number">-2</span>:]  <span class="comment"># 同上，表示获取最后两个字符，得到 'lo'</span></span><br><span class="line">s[::<span class="number">-1</span>] <span class="comment"># 获取字符串的倒序排列，相当于 reverse 函数</span></span><br></pre></td></tr></table></figure>
<p>step 和它前面的冒号要么同时写，要么同时不写，但 start 和 end 之间的冒号不能省，否则就不是切片而是获取元素了。再次强调 array[start:end] 表示的区间是 [a, b)，也许你会觉得这很难记，但同样的，这会得出以下美妙的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">array[:n] + array[n:] = array (0 &lt;= n &lt;= len(array))</span><br></pre></td></tr></table></figure>
<p>用代码来表示就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;hello&apos;</span><br><span class="line">s[:2] + s[2:] == s  </span><br><span class="line"># True，因为 s[:2] 是 &apos;he&apos;，s[2:] 是 &apos;llo&apos;</span><br></pre></td></tr></table></figure>
<p>切片不仅可以用来获取数组的一部分值，修改切片也可以直接修改数组的对应部分，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">a[1:3] = [22, 33, 44]</span><br><span class="line"># a = [1, 22, 33, 44, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<p>并没有人规定切片的新值必须和原来的长度一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">a[1:3] = [3]</span><br><span class="line"># a = [1, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">a[1:4] = []</span><br><span class="line"># a = [1, 6]，相当于删除了中间的三个数字</span><br></pre></td></tr></table></figure>
<p>但切片的新值必须也是可迭代的对象，比如这样写是不合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">a[1:3] = 3</span><br><span class="line"># TypeError: can only assign an iterable</span><br></pre></td></tr></table></figure>
<h5 id="循环与遍历"><a href="#循环与遍历" class="headerlink" title="循环与遍历"></a>循环与遍历</h5><p>一般来说，在 Python 中我们不会写出 for (int i = 0; i &lt; len(array); ++i) 这种风格的代码，而是使用 for in 这种语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in [1, 2, 3]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>虽然大家都知道 for in 语法，但它的某些灵活用法或许就不是那么众所周知了。有时候，我们会在 if 语句中对某个变量的值做多次判断，只要满足一个条件即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;bs&apos;</span><br><span class="line">if name == &apos;hello&apos; or name == &apos;hi&apos; or name == &apos;bs&apos; or name == &apos;admin&apos;:</span><br><span class="line">    print(&apos;Valid&apos;)</span><br></pre></td></tr></table></figure>
<p>这种情况推荐用 in 来代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;bs&apos;</span><br><span class="line">if name in (&apos;hello&apos;, &apos;hi&apos;, &apos;bs&apos;, &apos;admin&apos;):</span><br><span class="line">    print(&apos;Valid&apos;)</span><br></pre></td></tr></table></figure>
<p>有时候，如果我们想要把某件事重复固定的次数，用 for in 会显得有些啰嗦，这时候可以借助 range 类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(5):</span><br><span class="line">    print(&apos;Hi&apos;) # 打印五次 &apos;Hi&apos;</span><br></pre></td></tr></table></figure>
<p><code>range</code> 的语法和切片类似，比如我们需要访问数组所有奇数下标的元素，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5]</span><br><span class="line">for i in range(0, len(a), 2):</span><br><span class="line">    print(a[i])</span><br></pre></td></tr></table></figure>
<p>在这种写法中，我们不仅能获得元素，还能知道元素的下标，这与使用 enumerate(iterable [, start ]) 函数类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5]</span><br><span class="line">for i, n in enumerate(a):</span><br><span class="line">    print(i, n)</span><br></pre></td></tr></table></figure>
<h5 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h5><p>也许你已经注意到了，数组和字符串都支持切片，而且语法高度统一。这在某些强类型语言（比如我经常接触的 Objective-C 和 Java）中是不可能的，事实上，Python 能够支持这样统一的语法，并非巧合，而是因为所有用中括号进行下标访问的操作，其实都是调用这个类的 <code>__getitem__</code> 方法。</p>
<p>比如我们完全可以让自己的类也支持通过下标访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Book:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.chapters = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        return self.chapters[n]</span><br><span class="line"></span><br><span class="line">b = Book()</span><br><span class="line">print(b[1]) # 结果是 2</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这段代码几乎不会出问题（除非数组越界），这是因为我们直接把下标传到了内部的 self.chapters 数组上。但如果要自己处理下标，需要牢记它不一定是数字，也可以是切片，因此更完整的逻辑应该是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def __getitem__(self, n):</span><br><span class="line">    if isinstance(n, int): # n是索引</span><br><span class="line">        # 处理索引</span><br><span class="line">    if isinstance(n, slice): # n是切片</span><br><span class="line">        # 通过 n.start，n.stop 和 n.step 来处理切片</span><br></pre></td></tr></table></figure>
<p>与静态语言不同的是，任何实现了 <strong>getitem</strong> 都支持通过下标访问，而不用声明为实现了某个协议，这种特性也被称为 “鸭子类型”。鸭子类型并不要求某个类 是什么，仅仅要求这个类 能做什么。</p>
<p>顺便说一句，实现了 <code>__getitem__</code> 方法的类都是可迭代的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = Book()</span><br><span class="line">for c in b:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>
<p>后续的章节还会介绍更多 Python 中的魔术方法，这种方法的名称前后都有两个下划线，如果读作 “下划线-下划线-getitem” 会比较拗口，因此可以读作 “dunder-getitem” 或者 “双下-getitem”，类似的，我想每个人都能猜到 <code>__setitem__</code> 的作用和用法。</p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><h5 id="初始化字典"><a href="#初始化字典" class="headerlink" title="初始化字典"></a>初始化字典</h5><p>最简单的创建一个字典的方式就是直接写字面量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;a&apos;: 61, &apos;b&apos;: 62, &apos;c&apos;: 63, &apos;d&apos;: 64, &apos;e&apos;: 65&#125;</span><br></pre></td></tr></table></figure>
<p>字典字面量由大括号包住（注意区别于数组的中括号），键值对之间由逗号分割，每个键值对内部用冒号分割键和值。</p>
<p>如果数组的每个元素都是二元的元组，这个数组可以直接转成字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict([(&apos;a&apos;, 61), (&apos;b&apos;, 62), (&apos;c&apos;, 63), (&apos;d&apos;, 64), (&apos;e&apos;, 65)])</span><br></pre></td></tr></table></figure>
<p>就像数组可以推导一样，字典也可以推导：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [(&apos;a&apos;, 61), (&apos;b&apos;, 62), (&apos;c&apos;, 63), (&apos;d&apos;, 64), (&apos;e&apos;, 65)]</span><br><span class="line">d = &#123;letter: number for letter, number in a&#125; # 这里用到了元组拆包</span><br></pre></td></tr></table></figure>
<p>只要记得外面还是大括号就行了。</p>
<p>两个独立的数组可以被压缩成一个字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [61, 62, 63, 64, 65]</span><br><span class="line">letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">dict(zip(letters, numbers))</span><br></pre></td></tr></table></figure>
<p>正如 zip 的意思所表示的，超出长处的那部分数组会被抛弃。</p>
<h5 id="查询字典"><a href="#查询字典" class="headerlink" title="查询字典"></a>查询字典</h5><p>最简单方法是直接写键名，但如果键名不存在会抛出 KeyError：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;a&apos;: 61&#125;</span><br><span class="line">d[&apos;a&apos;] # 值是 61</span><br><span class="line">d[&apos;b&apos;] # KeyError: &apos;b&apos;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">可以用 if key in dict 的判断来检查键是否存在，甚至可以先 try 再 catch KeyError ，但更加优雅简洁一些的写法是用 get(k, default) 方法来提供默认值：</span><br></pre></td></tr></table></figure>
<p>d = {‘a’: 61}<br>d.get(‘a’, 62) # 得到 61<br>d.get(‘b’, 62) # 得到 62</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不过有时候，我们可能不仅仅要读出默认属性，更希望能把这个默认属性能写入到字典中，比如：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">## 我们想对字典中某个 Value 做操作，如果 Key 不存在，就先写入一个空值</span><br><span class="line">if &apos;list&apos; not in d:</span><br><span class="line">    d[&apos;list&apos;] = []</span><br><span class="line">d[&apos;list&apos;].append(1)</span><br></pre></td></tr></table></figure>
<p>这种情况下，<code>setdefault(key, default)</code> 函数或许更合适：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.setdefault(&apos;key&apos;, []).append(1)</span><br></pre></td></tr></table></figure>
<p>这个函数虽然名为 set，但作用其实是查找，仅仅在查找不到时才会把默认值写入字典</p>
<h5 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h5><p>直接遍历字典实际上是遍历了字典的键，因此也可以通过键获取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;a&apos;: 61, &apos;b&apos;: 62, &apos;c&apos;: 63, &apos;d&apos;: 64, &apos;e&apos;: 65&#125;</span><br><span class="line">for i in d:</span><br><span class="line">    print(i, d[i])</span><br><span class="line">#b 62</span><br><span class="line">#a 61</span><br><span class="line">#e 65</span><br><span class="line">#d 64</span><br><span class="line">#c 63</span><br></pre></td></tr></table></figure>
<p>我们也可以用字典的 keys() 或者 values() 方法显式的获取键和值。字典还有一个 items() 方法，它返回一个数组，每个元素都是由键和值组成的二元元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;a&apos;: 61, &apos;b&apos;: 62, &apos;c&apos;: 63, &apos;d&apos;: 64, &apos;e&apos;: 65&#125;</span><br><span class="line">for (k, v) in d.items():</span><br><span class="line">    print(k, v)</span><br><span class="line">#e 65</span><br><span class="line">#d 64</span><br><span class="line">#a 61</span><br><span class="line">#c 63</span><br><span class="line">#b 62</span><br></pre></td></tr></table></figure>
<p>可见 items() 方法和字典的构造方法互为逆操作，因为这个公式总是成立的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict(d.items()) == d</span><br></pre></td></tr></table></figure>
<h5 id="字典的魔术方法"><a href="#字典的魔术方法" class="headerlink" title="字典的魔术方法"></a>字典的魔术方法</h5><p>在 1.1.4 节中介绍过，通过下标访问最终都会由 <code>__getitem__</code> 这个魔术方法处理，因此字典的 d[key] 这种写法也不例外， 如果键不存在，则会走到 <code>__missing__</code> 方法，再给一次挽救的机会。比如我们可以实现一个字典， 自动忽略键的大小写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyDict(dict):</span><br><span class="line">    def __missing__(self, key):</span><br><span class="line">        if key.islower():</span><br><span class="line">            raise KeyError(key)</span><br><span class="line">        else:</span><br><span class="line">            return self[key.lower()]</span><br><span class="line"></span><br><span class="line">d = MyDict(&#123;&apos;a&apos;: 61&#125;)</span><br><span class="line">d[&apos;A&apos;] # 返回 61</span><br><span class="line">&apos;A&apos; in d # False</span><br></pre></td></tr></table></figure>
<p>这个字典比较简陋，比如 key 可能不是字符串，不过我没有处理太多情况，因为它主要是用来演示 <code>__missing__</code> 的用法，如果想要最后一行的 in 语法正确工作，需要重写 <code>__contains__</code> 这个魔术方法，过程类似，就不赘述了。</p>
<p>虽然通过自定义的函数也能实现相似的效果，不过这个自定义字典对用户更加透明，如果不在文档中说明，调用方很难察觉到字典的内部逻辑被修改了。 Python 有很多强大的功能，可以具备这种内部进行修改，但是对外保持透明的能力。这可能是我们第一次体会到，后续还会不断的经历。</p>
<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>集合更像是不会有重复元素的数组，但它的本质是以元素的哈希值作为 Key，从而实现去重的逻辑。因此，集合也可以推导，不过得用字典的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3,4,5,4,3,2,1]</span><br><span class="line">d = &#123;i for i in a if i &lt; 5&#125;</span><br><span class="line"># d = &#123;1, 2, 3, 4&#125;，注意这里的大括号</span><br></pre></td></tr></table></figure>
<p>回忆一下，二进制逻辑运算一共有三个运算符，按位或 |，按位与 &amp; 和异或 ^，这三个运算符也可以用在集合之间，而且含义变化不大。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1, 2, 3&#125;</span><br><span class="line">b = &#123;3, 4, 5&#125;</span><br><span class="line">c = a | b</span><br><span class="line"># c = &#123;1, 2, 3, 4, 5&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 | 运算表示并集，也就是 c 中的任意元素，要么在 a，要么在 b 集合中。类似的，按位与 &amp; 运算求的就是交集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1, 2, 3&#125;</span><br><span class="line">b = &#123;3, 4, 5&#125;</span><br><span class="line">c = a &amp; b</span><br><span class="line"># c = &#123;3&#125;</span><br></pre></td></tr></table></figure>
<p>而异或则表示那些只在 a 不在 b 或者只在 b 不在 a 的元素。或者换个说法，表示那些在集合 a 和 b 中出现了且仅出现了一次的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1, 2, 3&#125;</span><br><span class="line">b = &#123;3, 4, 5&#125;</span><br><span class="line">c = a ^ b</span><br><span class="line"># c = &#123;1, 2, 4, 5&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个差集运算 -，表示在集合 a 中但不在集合 b 中的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1, 2, 3&#125;</span><br><span class="line">b = &#123;3, 4, 5&#125;</span><br><span class="line">c = a - b</span><br><span class="line"># c = &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<p>回忆一下韦恩图，就会得到以下公式（虽然并没有什么卵用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A | B = (A ^ B) | (A &amp; B)</span><br><span class="line">A ^ B = (A - B) | (B - A)</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h5><p>用 Python 写过爬虫的人都应该感受过被字符串编码支配的恐惧。简单来说，编码指的是将可读的字符串转换成不太可读的数字，用来存储或者传输。解码则指的是将数字还原成字符串的过程。常见的编码有 ASCII、GBK 等。</p>
<p>ASCII 编码是一个相当小的字符集合，只有一百多个常用的字符，因此只用一个字节（8 位）就能表示，为了存储本国语言，各个国家都开发出了自己的编码，比如中文的 GBK。这就带来了一个问题，如果我想要在一篇文章中同时写中文和日文，就无法实现了，除非能对每个字符指定编码，这个成本高到无法接受。</p>
<p>Unicode 则是一个最全的编码方式，每个 Unicode 字符占据 6 个字节，可以表示出 2 ^ 48 种字符。但随之而来的是 Unicode 编码后的内容不适合存储和发送，因此诞生了基于 Unicode 的再次编码，目的是为了更高效的存储。</p>
<p>首先，编码的函数是 encode，它是字符串的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;hello&apos;</span><br><span class="line">s.encode()         # 得到 b&apos;hello&apos;</span><br><span class="line">s.encode(&apos;utf16&apos;)  # 得到 b&apos;\xff\xfeh\x00e\x00l\x00l\x00o\x00&apos;</span><br></pre></td></tr></table></figure>
<p>encode 函数有两个参数，第一个参数不写表示使用默认的 utf8 编码，理论上会输出二进制格式的编码结果，但在终端打印时，被自动还原回字符串了。如果用 utf16 进行编码，则会看到编码以后的二进制结果。</p>
<p>前面说过，编码是字符转到二进制的转化过程，有时候在某个编码规范中，并没有指定某个字符是如何编码的，也就是找不到对应的数字，这时候编码就会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">city = &apos;São Paulo&apos;</span><br><span class="line">b_city = city.encode(&apos;cp437&apos;)</span><br><span class="line"># UnicodeEncodeError: &apos;charmap&apos; codec can&apos;t encode character &apos;\xe3&apos; in position 1: character maps to &lt;undefined&gt;</span><br></pre></td></tr></table></figure>
<p>此时需要用到 encode 函数的第二个参数，用来指定遇到错误时的行为。它的值可以是 ‘ignore’，表示忽略这个不能编码的字符，也可以是 ‘replace’，表示用默认字符代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b_city = city.encode(&apos;cp437&apos;, errors=&apos;ignore&apos;) </span><br><span class="line"># b&apos;So Paulo&apos;</span><br><span class="line">b_city = city.encode(&apos;cp437&apos;, errors=&apos;replace&apos;)</span><br><span class="line"># b&apos;S?o Paulo&apos;</span><br></pre></td></tr></table></figure>
<p><code>decode</code> 完全是 <code>encode</code> 的逆操作，只有二进制类型才有这个函数。它的两个参数含义和 encode 函数完全一致，就不再介绍了。</p>
<p>从理论上来说，仅从编码后的内容上来看，是无法确定编码方式的，也无法解码出原来的字符。但不同的编码有各自的特点，虽然无法完全倒推，但可以从概率上来猜测，如果发现某个二进制内容，有 99% 的可能性是 utf8 编码生成的，我们就可以用 utf8 进行解码。Python 提供了一个强大的工具包 Chardet 来完成这一任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octets = b&apos;Montr\xe9al&apos;</span><br><span class="line">chardet.detect(octets)</span><br><span class="line"># &#123;&apos;encoding&apos;: &apos;ISO-8859-1&apos;, &apos;confidence&apos;: 0.73, &apos;language&apos;: &apos;&apos;&#125;</span><br><span class="line">octets.decode(&apos;ISO-8859-1&apos;)</span><br><span class="line"># Montréal</span><br></pre></td></tr></table></figure>
<p>返回结果中包含了猜测的编码方式，以及可信度。可信度越高，说明是这种编码方式的可能性越大。</p>
<p>有时候，我们拿到的是二进制的字符串字面量，比如 68 65 6c 6c 6f，前文说过只有二进制类型才有 decode 函数，所以需要通过二进制的字面量生成二进制变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;68 65 6c 6c 6f&apos;</span><br><span class="line">b = bytearray.fromhex(s)</span><br><span class="line">b.decode()  # hello</span><br></pre></td></tr></table></figure>
<h5 id="字符串的常用方法"><a href="#字符串的常用方法" class="headerlink" title="字符串的常用方法"></a>字符串的常用方法</h5><p>字符串的 split(sep, maxsplit) 方法可以以指定的分隔符进行分割，有点类似于 Shell 中的 awk -F ‘ ‘’，第一个 sep 参数表示分隔符，不填则为空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;a b c d e&apos;</span><br><span class="line">a = s.split()</span><br><span class="line"># a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure>
<p>第二个参数 maxsplit 表示最多分割多少次，因此返回数组的长度是 maxsplit + 1。举个例子说明下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;a;b;c;d;e&apos;</span><br><span class="line">a = s.split(&apos;;&apos;)</span><br><span class="line"># a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line"></span><br><span class="line">b = s.split(&apos;;&apos;, 2)</span><br><span class="line"># b = [&apos;a&apos;, &apos;b&apos;, &apos;c;d;e&apos;]</span><br></pre></td></tr></table></figure>
<p>如果想批量替换，则可以用 replace(old, new[, count]) 方法，由中括号括起来的参数表示选填</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &apos;a;b;c;d;e&apos;</span><br><span class="line">new = old.replace(&apos;;&apos;, &apos; &apos;, 3)</span><br><span class="line"># new = &apos;a b c d;e&apos;</span><br></pre></td></tr></table></figure>
<p>strip[chars] 用于移除指定的字符们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &quot;*****!!!Hello!!!*****&quot;</span><br><span class="line">new = old.strip(&apos;*&apos;)  # 得到 &apos;!!!Hello!!!&apos;</span><br><span class="line">new = old.strip(&apos;*！&apos;)  # 得到 &apos;Hello&apos;</span><br></pre></td></tr></table></figure>
<p>最后一个常用方法是 join，其实这个可以理解为字符串的构造方法，它可以把数组转换成字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = &apos;a b c d e&apos;.split() # 之前说过，结果是 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">s = &apos;;&apos;.join(array) # 以分号为连接符，把数组中的元素连接起来</span><br><span class="line"># s = &apos;a;b;c;d;e&apos;</span><br></pre></td></tr></table></figure>
<p>上面这些字符串处理的函数，大多返回的还是字符串，因此可以链式调用，避免使用临时变量和多行代码，但也要避免过长（超过 3 个）的链式调用，以免影响可读性。</p>
<h5 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h5><p>最初级的字符串格式化方法是使用 + 来拼接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;betterswifter&apos;</span><br><span class="line">        self.age = 22</span><br><span class="line">        self.sex = &apos;m&apos;</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">print(&apos;Name: &apos; + p.name + &apos;, Age: &apos; + str(p.age) + &apos;, Sex: &apos; + p.sex)</span><br><span class="line"># 输出：Name: betterswifter, Age: 22, Sex: m</span><br></pre></td></tr></table></figure>
<p>这里必须要把 int 类型的年龄转成字符串以后才能进行拼接，这是因为 Python 是强类型语言，不支持类型的隐式转换。</p>
<p>这种做法的缺点在于如果输出结构比较复杂，极容易出现引号匹配错误的问题，可读性非常低。</p>
<p>Python 2 中的做法是使用占位符，类似于 C 语言中 printf:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content = &apos;Name: %s, Age: %i, Sex: %c&apos; % (p.name, p.age, p.sex)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>
<p>从结构上看，要比上一种写法清楚得多， 但每个变量都需要指定类型，这和 Python 的简洁不符。实际上每个对象都可以通过 str() 函数转换成字符串，这个函数的背后是 <code>__str__</code> 魔术方法。</p>
<p>Python 3 中的写法是使用 format 函数，比如我们来实现一下 <code>__str__</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;betterswifter&apos;</span><br><span class="line">        self.age = 22</span><br><span class="line">        self.sex = &apos;m&apos;</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&apos;.format(user=self)</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">print(p)</span><br><span class="line"># 输出：Name: betterswifter, Age: 22, Sex: m</span><br></pre></td></tr></table></figure>
<p>除了把对象传给 format 函数并在字符串中展开以外， 也可以传入多个参数，并且通过下标访问他们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&#123;0&#125;, &#123;1&#125;, &#123;0&#125;&apos;.format(1, 2))</span><br><span class="line"># 输出：1, 2, 1，这里的 &#123;1&#125; 表示第二个参数</span><br></pre></td></tr></table></figure>
<h5 id="HereDoc"><a href="#HereDoc" class="headerlink" title="HereDoc"></a>HereDoc</h5><p>Heredoc 不是 Python 特有的概念， 命令行和各种脚本中都会见到，它表示一种所见即所得的文本。</p>
<p>假设我们在写一个 HTML 的模板，绝大多数字符串都是常量，只有有限的几个地方会用变量去替换，那这个字符串该如何表示呢？一种写法是直接用单引号去定义:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;\nFriends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;\n&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;\n&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;\n&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back\nONCLICK=\'window.history.back()\'&gt;&lt;/FORM&gt;\n&lt;/BODY&gt;&lt;/HTML&gt;'</span></span><br></pre></td></tr></table></figure>
<p>这段代码是自动生成的还好，如果是手动维护的，那么可读性就非常差，因为换行符和转义后的引号增加了理解的难度。如果用 heredoc 来写，就非常简单了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span></span><br><span class="line"><span class="string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span></span><br><span class="line"><span class="string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span></span><br><span class="line"><span class="string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span></span><br><span class="line"><span class="string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span></span><br><span class="line"><span class="string">ONCLICK='window.history.back()'&gt;&lt;/FORM&gt;</span></span><br><span class="line"><span class="string">&lt;/BODY&gt;&lt;/HTML&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>Heredoc 主要是用来书写大段的字符串常量，比如 HTML 模板，SQL语句等等</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h4><p>一等公民指的是 Python 的函数能够动态创建，能赋值给别的变量，能作为参传给函数，也能作为函数的返回值。总而言之，函数和普通变量并没有什么区别。</p>
<p>函数是一等公民，这是函数式编程的基础，然而 Python 中基本上不会使用 lambda 表达式，因为在 lambda 表达式的中仅能使用单纯的表达式，不能赋值，不能使用 while、try 等语句，因此 lambda 表达式要么难以阅读，要么根本无法写出。这极大的限制了 lambda 表达式的使用场景。</p>
<p>上文说过，函数和普通变量没什么区别，但普通变量并不是函数，因为这些变量无法调用。但如果某个类实现了 <code>__call__</code> 这个魔术方法，这个类的实例就都可以像函数一样被调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;betterswifter&apos;</span><br><span class="line">        self.age = 22</span><br><span class="line">        self.sex = &apos;m&apos;</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&apos;.format(user=self)</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p() # 等价于 print(p)</span><br></pre></td></tr></table></figure>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><h5 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h5><p>对于熟悉 C 系列语言的人来说，函数传参的方式一目了然。默认是拷贝传值，如果传指针是引用传值。我们先来看一段简单的 Python 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def foo(arg):</span><br><span class="line">    arg = 5</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">a = 1</span><br><span class="line">foo(a)</span><br><span class="line">print(a)</span><br><span class="line"># 输出 5 和 1</span><br></pre></td></tr></table></figure>
<p>这段代码的结果符合我们的预期，从这段代码来看，Python 也属于拷贝传值。但如果再看这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def foo(arg):</span><br><span class="line">    arg.append(1)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">a = [1]</span><br><span class="line">foo(a)</span><br><span class="line">print(a) # 输出两个 [1, 1]</span><br></pre></td></tr></table></figure>
<p>你会发现参数数组在函数内部被改变了。就像是 C 语言中传递了变量的指针一样。所以 Python 到底是拷贝传值还是引用传值呢？答案都是否定的！</p>
<p>Python 的传值方式可以被理解为混合传值。对于那些不可变的对象（比如 1.1.2 节中介绍过的元组，还有数字、字符串类型），传值方式是拷贝传值；对于那些可变对象（比如数组和字典）则是引用传值</p>
<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>Python 的函数可以有默认值，这个功能很好用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def foo(a, l=[]):</span><br><span class="line">    l.append(a)</span><br><span class="line">    return l</span><br><span class="line"></span><br><span class="line">foo(2,[1])  # 给数组 [1] 添加一个元素 2，得到 [1,2]</span><br><span class="line">foo(2)</span><br></pre></td></tr></table></figure>
<p>然而如果这样调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(2)  # 利用默认参数，得到 [2]</span><br><span class="line">foo(3)  # 竟然得到了 [2, 3]</span><br></pre></td></tr></table></figure>
<p>函数调用了两次以后，默认参数被改变了，也就是说函数调用产生了副作用。这是因为默认参数的存储并不像函数里的临时变量一样存储在栈上、随着函数调用结束而释放，而是存储在函数这个对象的内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.__defaults__  # 一开始确实是空数组</span><br><span class="line">foo(2)  # 利用默认参数，得到 [2]</span><br><span class="line">foo.__defaults__  # 如果打印出来看，已经变成 [2] 了</span><br><span class="line">foo(3)  # 再添加一个元素就得到了 [2, 3]</span><br></pre></td></tr></table></figure>
<p>因为函数 foo 作为一个对象，不会被释放，因此这个对象内部的属性也不会随着多次调用而自动重置，会一直保持上次发生的变化。基于这个前提，我们得出一个结论：函数的默认参数不允许是可变对象，比如这里的 foo 函数需要这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def foo(a, l=None):</span><br><span class="line">    if l is None:</span><br><span class="line">        l = []</span><br><span class="line">    l.append(a)</span><br><span class="line">    return l</span><br><span class="line"></span><br><span class="line">print(foo(2)) # 得到 [2]</span><br><span class="line">print(foo(3)) # 得到 [3]</span><br></pre></td></tr></table></figure>
<p>现在，给参数添加默认值的行为在函数体中完成，不会随着函数的多次调用而累积。</p>
<p>对于 Python 的默认参数来说:</p>
<blockquote>
<p>如果默认值是不可变的，可以直接设置默认值，否则要设置为 None 并在函数体中设置默认值。</p>
</blockquote>
<h5 id="多参数传递"><a href="#多参数传递" class="headerlink" title="多参数传递"></a>多参数传递</h5><p>当参数个数不确定时，可以在参数名前加一个 <code>*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def foo(*args):</span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line">foo(1, 2, 3)  # 输出 [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>如果直接把数组作为参数传入，它其实是单个参数，如果要把数组中所有元素都作为单独的参数传入，则在数组前面加上 <code>*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3]    </span><br><span class="line">foo(a)  # 会输出 ([1,2,3], )   因为只传了一个数组作为参数</span><br><span class="line">foo(*a) # 输出 [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>这里的单个 <em> 只能接收非关键字参数，也就是仅有参数值的哪些参数。如果想接受关键字参数，需要用 *</em> 来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def foo(*args, **kwargs):</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">foo(1,2,3, a=61, b=62)</span><br><span class="line"># 第一行输出：(1, 2, 3)</span><br><span class="line"># 第二行输出：&#123;&apos;a&apos;: 61, &apos;b&apos;: 62&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，字典变量传入函数只能作为单个参数，如果要想展开并被 <code>**kwargs 识别，需要在字典前面加上两个星号 **</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3]</span><br><span class="line">d = &#123;&apos;a&apos;: 61, &apos;b&apos;: 62&#125;</span><br><span class="line">foo(*a, **d)</span><br></pre></td></tr></table></figure>
<h5 id="参数分类"><a href="#参数分类" class="headerlink" title="参数分类"></a>参数分类</h5><p>Python 中函数的参数可以分为两大类：</p>
<ol>
<li>定位参数（Positional）：表示参数的位置是固定的。比如对于函数 foo(a, b) 来说，<code>foo(1, 2)</code> 和 <code>foo(2, 1)</code> 就是截然不同的，a 和 b 的位置是固定的，不可随意调换。</li>
<li>关键词参数（Keyword）：表示参数的位置不重要，但是参数名称很重要。比如 <code>foo(a = 1, b = 2)</code> 和 <code>foo(b = 2, a = 1)</code> 的含义相同。</li>
</ol>
<p>有一种参数叫做仅限关键字（Keyword-Only）参数，比如考虑这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def foo(*args, n=1, **kwargs):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<p>这个函数在调用时，如果参数 n 不指定名字，就会被前面的 <em>args 处理掉，如果指定的名字不是 n，又会被后面的 *</em>kwargs 处理掉，所以参数 n 必须精确的以 (n = xxx) 的形式出现，也就是 Keyworld-Only。</p>
<h4 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h4><p>在 2.2.2 节中，我们查看了函数变量的 <strong>defaults</strong> 属性，其实这就是一种内省，也就是在运行时动态的查看变量的信息。</p>
<p>前文说过，函数也是对象，因此函数的变量个数，变量类型都应该有办法获取到，如果你需要开发一个框架，也许会对函数有各种奇葩的检查和校验。</p>
<p>以下面这个函数为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = 1</span><br><span class="line">def foo(m, *args, n, **kwargs):</span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br></pre></td></tr></table></figure>
<p>首先可以获取函数名，函数所在模块的全局变量等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__globals__   # 全局变量，包含了 g = 1</span><br><span class="line">foo.__name__      # foo</span><br></pre></td></tr></table></figure>
<p>我们还可以看到函数的参数，函数内部的局部变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__code__.co_varnames  # (&apos;m&apos;, &apos;n&apos;, &apos;args&apos;, &apos;kwargs&apos;, &apos;a&apos;, &apos;b&apos;)</span><br><span class="line">foo.__code__.co_argcount  # 只计算参数个数，不考虑可变参数和仅限关键字参数，所以得到 1</span><br></pre></td></tr></table></figure>
<p>或者用 inspect 模块来查看更详细的信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">sig = inspect.signature(foo)  <span class="comment"># 获取函数签名</span></span><br><span class="line"></span><br><span class="line">sig.parameters[<span class="string">'m'</span>].kind      <span class="comment"># POSITIONAL_OR_KEYWORD 表示可以是定位参数或关键字参数</span></span><br><span class="line">sig.parameters[<span class="string">'args'</span>].kind   <span class="comment"># VAR_POSITIONAL 定位参数构成的数组</span></span><br><span class="line">sig.parameters[<span class="string">'n'</span>].kind      <span class="comment"># KEYWORD_ONLY 仅限关键字参数</span></span><br><span class="line">sig.parameters[<span class="string">'kwargs'</span>].kind <span class="comment"># VAR_KEYWORD 关键字参数构成的字典</span></span><br><span class="line">inspect.getfullargspec(foo)       </span><br><span class="line"><span class="comment"># 得到：ArgSpec(args=['m', 'n'], varargs='args', keywords='kwargs', defaults=None)</span></span><br></pre></td></tr></table></figure>
<p>本节的新 API 比较多，但并不要求记住这些 API 的用法。再次强调，本文的写作目的是为了建立读者对 Python 的总体认知，了解 Python 能做什么，至于怎么做，那是文档该做的事。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><h5 id="设计模式的消亡"><a href="#设计模式的消亡" class="headerlink" title="设计模式的消亡"></a>设计模式的消亡</h5><p>经典的设计模式有 23 个，虽然设计模式都是常用代码的总结，理论上来说与语法无关。但不得不承认的是，标准的设计模式在不同的语言中，有的因为语法的限制根本无法轻易实现（比如在 C 语言中实现组合模式），有的则因为语言的特定功能，变得冗余啰嗦。</p>
<p>以策略模式为例，有一个抽象的策略类，定义了策略的接口，然后使用者选择一个具体的策略类，构造他们的实例并且调用策略方法</p>
<p>然而这些对象本身并没有作用，它们仅仅是可以调用相同的方法而已，只不过在 Java 中，所有的任务都需要由对象来完成。即使策略本身就是一个函数，但也必须把它包裹在一个策略对象中。所以在 Python 中更优雅写法是直接把策略函数作为变量使用。不过这就引入一个问题，如何判断某个函数是个策略呢，毕竟在面向对象的写法中，只要检查它的父类是否是抽象的策略类即可。</p>
<p>也许你已经见过类似的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@strategy</span><br><span class="line">def strategyA(n):</span><br><span class="line">    print(n * 2)</span><br></pre></td></tr></table></figure>
<p>下面就开始介绍装饰器</p>
<h5 id="装饰器的基本原理"><a href="#装饰器的基本原理" class="headerlink" title="装饰器的基本原理"></a>装饰器的基本原理</h5><p>首先，装饰器是个函数，它的参数是被装饰的函数，返回值也是一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def decorate(origin_func):  # 这个参数是被装饰的函数</span><br><span class="line">    print(1)  # 先输出点东西</span><br><span class="line">    return origin_func  # 把原函数直接返回</span><br><span class="line"></span><br><span class="line">@decorate    # 注意这里不是函数调用，所以不用加括号，也不用加被修饰的函数名</span><br><span class="line">def sayHello():</span><br><span class="line">    print(&apos;Hello&apos;)</span><br><span class="line"></span><br><span class="line">sayHello()  # 如果没有装饰器，只会打印 &apos;Hello&apos;，实际结果是打印 1 再打印 &apos;Hello&apos;</span><br></pre></td></tr></table></figure>
<p>因此，使用装饰器的这种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@decorate</span><br><span class="line">def foo():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>和下面这种写法是完全等价的， 初学者可以把装饰器在心中默默的转换成下一种写法，以方便理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    pass</span><br><span class="line">foo = decorate(foo)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，装饰器函数 decorate 在模块被导入时就会执行，而被装饰的函数只在被调用时才会执行，也就是说即使不调用 sayHello 函数也会输出 1，但这样就不会输出 Hello 了。</p>
<p>有了装饰器，配合前面介绍的函数对象，函数内省，我们可以做很多有意思的事，至少判断上一节中某个函数是否是策略是非常容易的。在装饰器中，我们还可以把策略函数都保存到数组中， 然后提供一个“推荐最佳策略”的功能， 其实就是遍历执行所有的策略，然后选择最好的结果</p>
<h5 id="装饰器进阶"><a href="#装饰器进阶" class="headerlink" title="装饰器进阶"></a>装饰器进阶</h5><p>上一节中的装饰器主要是为了介绍工作原理，它的功能非常简单，并不会改变被装饰函数的运行结果，仅仅是在导入时装饰函数，然后输出一些内容。换句话说，即使不执行函数，也要执行装饰器中的 print 语句，而且因为直接返回函数的缘故，其实没有真正的起到装饰的效果。</p>
<p>如何做到装饰时不输出任何内容，仅在函数执行最初输出一些东西呢？这是常见的 AOP（面向切片编程） 的需求。这就要求我们不能再直接返回被装饰的函数，而是应该返回一个新的函数，所以新的装饰器需要这么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def decorate(origin_func):</span><br><span class="line">    def new_func():</span><br><span class="line">        print(1)</span><br><span class="line">        origin_func()</span><br><span class="line">    return new_func</span><br><span class="line"></span><br><span class="line">decorate</span><br><span class="line">def sayHello():</span><br><span class="line">    print(&apos;Hello&apos;)</span><br><span class="line"></span><br><span class="line">sayHello() # 运行结果不变，但是仅在调用函数 sayHello 时才会输出 1</span><br></pre></td></tr></table></figure>
<p>这个例子的工作原理是，sayHello 函数作为参数 origin_func 被传到装饰器中，经过装饰以后，它实际上变成了 new_func，会先输出 1 再执行原来的函数，也就是 sayHello。</p>
<p>这个例子很简陋，因为我们知道了 sayHello 函数没有参数，所以才能定义一个同样没有参数的替代者：nwe_func。如果我们在开发一个框架，要求装饰器能对任意函数生效，就需要用到 2.2.3 中介绍的 <em> 和 *</em> 这种不定参数语法了。</p>
<p>如果查看 sayHello 函数的名字，得到的结果将是 new_func：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello.__name__  # new_func</span><br></pre></td></tr></table></figure>
<p>这是很自然的，因为本质上其实执行的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_func = decorate(sayHello)</span><br></pre></td></tr></table></figure>
<p>而装饰器的返回结果是另一个函数 new_func，两者仅仅是运行结果类似，但两个对象并没有什么关联。</p>
<p>所以为了处理不定参数，并且不改变被装饰函数的外观（比如函数名），我们需要做一些细微的修补工作。这些工作都是模板代码，所以 Python 早就提供了封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def decorate(origin_func):</span><br><span class="line">    @functools.wraps(origin_func)  # 这是 Python 内置的装饰器</span><br><span class="line">    def new_func(*args, **kwargs):</span><br><span class="line">        print(1)</span><br><span class="line">        origin_func(*args, **kwargs)</span><br><span class="line">    return new_func</span><br></pre></td></tr></table></figure>
<h5 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h5><p>在 2.4.2 节的代码注释中我解释过，装饰器后面不要加括号，被装饰的函数自动作为参数，传递到装饰器函数中。如果加了括号和参数，就变成手动调用装饰器函数了，大多数时候这与预期不符（因为装饰器的参数一般都是被装饰的函数）。</p>
<p>不过装饰器可以接受自定义的参数，然后返回另一个装饰器，这样外面的装饰器实际上就是一个装饰器工厂，可以根据用户的参数，生成不同的装饰器。还是以上面的装饰器为例，我希望输出的内容不是固定的 1，而是用户可以指定的，代码就应该这么写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def decorate(content):                        # 这其实是一个装饰器工厂</span><br><span class="line">    def real_decorator(origin_func):          # 这才是刚刚的装饰器</span><br><span class="line">        @functools.wraps(origin_func)</span><br><span class="line">        def new_func():</span><br><span class="line">            print(&apos;You said &apos; + str(content)) # 现在输出内容可以由用户指定</span><br><span class="line">            origin_func()</span><br><span class="line">        return new_func                       # 在装饰器里，返回的是新的函数</span><br><span class="line">    return real_decorator</span><br></pre></td></tr></table></figure>
<p>装饰器工厂和装饰器的区别在于它可以接受参数，返回一个装饰器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@decorate(2017)</span><br><span class="line">def sayHello():</span><br><span class="line">    print(&apos;Hello&apos;)</span><br><span class="line"></span><br><span class="line">sayHello()</span><br></pre></td></tr></table></figure>
<p>其实还是等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real_decorator = decorate(2017)      # 通过装饰器工厂生成装饰器</span><br><span class="line">new_func = real_decorator(sayHello)  # 正常的装饰器工作逻辑</span><br><span class="line">new_func()</span><br></pre></td></tr></table></figure>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="对象内存管理"><a href="#对象内存管理" class="headerlink" title="对象内存管理"></a>对象内存管理</h4><h5 id="对象不是盒子"><a href="#对象不是盒子" class="headerlink" title="对象不是盒子"></a>对象不是盒子</h5><p>C 语言中我们定义变量用到的语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br></pre></td></tr></table></figure>
<p>这背后的含义是定义了一个 int 类型的变量 a，相当于申请了一个名为 a 的盒子（存储空间），里面装了数字 1</p>
<p>然后我们改变 a 的值：a = 2;，可以打印 a 的地址来证明它并没有发生变化。所以只是盒子里装的内容（指针指向的位置）发生了改变.</p>
<p>但是在 Python 中，变量不是盒子。比如同样的定义变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br></pre></td></tr></table></figure>
<p>这里就不能把 a 理解为 int 类型的变量了。因为在 Python 中，变量没有类型，值才有，或者说只有对象才有类型。因为即使是数字 1，也是 int 类的实例，而变量 a 更像是给这个对象贴的一个标签</p>
<p>如果执行赋值语句 a = 2，相当于把标签 a 贴在另一个对象上</p>
<p>基于这个认知，我们现在应该更容易理解 2.2.1 节中所说的函数传参规则了。如果传入的是不可变类型，比如 int，改变它的值实际上就是把标签挂在新的对象上，自然不会改变原来的参数。如果是可变类型，并且做了修改，那么函数中的变量和外面的变量都是指向同一个对象的标签，所以会共享变化。</p>
<h5 id="默认浅复制"><a href="#默认浅复制" class="headerlink" title="默认浅复制"></a>默认浅复制</h5><p>根据上一节的描述，直接把变量赋值给另一个变量， 还算不上复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3]</span><br><span class="line">b = a</span><br><span class="line">b == a   # True，等同性校验，会调用 __eq__ 函数，这里只判断内容是否相等</span><br><span class="line">b is a   # True，一致性校验，会检查是否是同一个对象，调用 hash() 函数，可以理解为比较指针</span><br></pre></td></tr></table></figure>
<p>可见不仅仅数组相同，就连变量也是相同的，可以把 b 理解为 a 的别名。</p>
<p>如果用切片，或者数组的构造函数来创建新的数组，得到的是原数组的浅拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3]</span><br><span class="line">b = list(a)</span><br><span class="line">b == a   # True，因为数组内容相同</span><br><span class="line">b is a   # False，现在 a 和 b 是两个变量，恰好指向同一个数组对象</span><br></pre></td></tr></table></figure>
<p>但如果数组中的元素是可变的，可以看到这些元素并没有被完全拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [[1], [2], [3]]</span><br><span class="line">b = list(a)</span><br><span class="line">b[0].append(2)</span><br><span class="line">a # 得到 [[1, 2], [2], [3]]，因为 a[0] 和 b[0] 其实还是挂在相同对象上的不同标签</span><br></pre></td></tr></table></figure>
<p>如果想要深拷贝，需要使用 copy 模块的 deepcopy 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy </span><br><span class="line"></span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">b[<span class="number">0</span>].append(<span class="number">2</span>)</span><br><span class="line">b  <span class="comment"># 变成了 [[1, 2], [2], [3]]</span></span><br><span class="line">a  <span class="comment"># 还是 [[1], [2], [3]]</span></span><br></pre></td></tr></table></figure>
<p>此时，不仅仅是每个元素的引用被拷贝，就连每个元素自己也被拷贝。所以现在的 <code>a[0]</code> 和 `现在的 ``是指向两个不同对象的两个不同变量（标签），自然就互不干扰了。</p>
<p>如果要实现自定义对象的深复制，只要实现 <code>__deepcopy__</code> 函数即可。这个概念在几乎所有面向对象的语言中都会存在，就不详细介绍了</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>Python 内存管理使用垃圾回收的方式，当没有指向对象的引用时，对象就会被回收。然而对象一直被持有也并非什么好事，比如我们要实现一个缓存，预期目标是缓存中的内容随着真正对象的存在而存在，随着真正对象的消失而消失。如果因为缓存的存在，导致被缓存的对象无法释放，就会导致内存泄漏。</p>
<p>Python 提供了语言级别的支持，我们可以使用 <code>weakref</code> 模块，它提供了 <code>ref</code> 模块，它提供了 weakref.WeakVa<code>这个弱引用字典来确保字典中的值不会被引用。如果想要获取某个对象的弱引用，可以使用</code>个对象的弱引用，可以使用 wea` 函数。</p>
<h4 id="Python-风格的对象"><a href="#Python-风格的对象" class="headerlink" title="Python 风格的对象"></a>Python 风格的对象</h4><h5 id="静态函数与类方法"><a href="#静态函数与类方法" class="headerlink" title="静态函数与类方法"></a>静态函数与类方法</h5><p>静态函数其实和类的方法没什么关系，它只是恰好定义在类的内部而已，所以这里我用函数（function) 来形容它。它可以没有参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    @staticmethod   # 用 staticmethod 这个修饰器来表明函数是静态的</span><br><span class="line">    def sayHello():</span><br><span class="line">        print(&apos;Hello&apos;)</span><br><span class="line"></span><br><span class="line">Person.sayHello() # 输出 &apos;Hello`</span><br></pre></td></tr></table></figure>
<p>静态函数的调用方式是类名加上函数名。类方法的调用方式也是这样，唯一的不同是需要用 <code>@staticmethod</code> 修饰器，而且方法的第一个参数必须是类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    @classmethod    # 用 classmethod 这个修饰器来表明这是一个类方法</span><br><span class="line">    def sayHi(cls):</span><br><span class="line">        print(&apos;Hi: &apos; + cls.__name__)</span><br><span class="line"></span><br><span class="line">Person.sayHi() # 输出 &apos;Hi: Person`</span><br></pre></td></tr></table></figure>
<p>类方法和静态函数的调用方法一致，在定义时除了修饰器不一样，唯一的区别就是类方法需要多声明一个参数。这样看起来比较麻烦，但静态函数无法引用到类对象，自然就无法访问类的任何属性。</p>
<p>于是问题来了，静态函数有何意义呢？有的人说类名可以提供命名空间的概念，但在我看来这种解释并不成立，因为每个 Python 文件都可以作为模块被别的模块引用，把静态函数从类里抽取出来，定义成全局函数，也是有命名空间的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 在 module1.py 文件中：</span><br><span class="line">def global():</span><br><span class="line">    pass </span><br><span class="line"></span><br><span class="line">class Util:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def helper():</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"># 在 module2.py 文件中：</span><br><span class="line">import module1</span><br><span class="line">module1.global()        # 调用全局函数</span><br><span class="line">module1.Util.helper()   # 调用静态函数</span><br></pre></td></tr></table></figure>
<p>从这个角度看，定义在类中的静态函数不仅不具备命名空间的优点，甚至调用语法还更加啰嗦。对此，我的理解是：静态函数可以被继承、重写，但全局函数不行，由于 Python 中的函数是一等公民，因此很多时候用函数替代类都会使代码更加简洁，但缺点就是无法继承，后面还会有更多这样的例子。</p>
<h5 id="属性-attribute"><a href="#属性-attribute" class="headerlink" title="属性 attribute"></a>属性 attribute</h5><p>Python （等多数动态语言）中的类并不像 C/OC/Java 这些静态语言一样，需要预先定义属性。我们可以直接在初始化函数中创建属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">bs = Person(&apos;betterswifter&apos;)</span><br><span class="line">bs.name  # 值是 &apos;betterswifter&apos;</span><br></pre></td></tr></table></figure>
<p>由于 <code>__init__</code> 函数是运行时调用的，所以我们可以直接给对象添加属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bs.age = 22</span><br><span class="line">bs.age  # 因为刚刚赋值了，所以现在取到的值是 22</span><br></pre></td></tr></table></figure>
<p>如果访问一个不存在的属性，将会抛出异常。从以上特性来看，对象其实和字典非常相似，但这种过于灵活的特性其实蕴含了潜在的风险。比如某个封装好的父类中定义了许多属性， 但是子类的使用者并不一定清楚这一点，他们很可能会不小心就重写了父类的属性。一种隐藏并保护属性的方式是在属性前面加上两个下划线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__name = <span class="string">'betterswifter'</span></span><br><span class="line"></span><br><span class="line">bs = Person()</span><br><span class="line"></span><br><span class="line">bs.__name          <span class="comment"># 这样是无法获取属性的</span></span><br><span class="line">bs._Person__name   <span class="comment"># 这样还是可以读取属性</span></span><br></pre></td></tr></table></figure>
<p>这是因为 Python 会自动处理以双下划线开头的属性，把他们重名为 <code>_Classname__attrname</code> 的格式。由于 Python 对象的所有属性都保存在实例的 <code>__dict__</code> 属性中，我们可以验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bs = Person()</span><br><span class="line">bs.__dict__ </span><br><span class="line"># 得到 &#123;&apos;_Person__name&apos;: &apos;betterswifter&apos;&#125;</span><br></pre></td></tr></table></figure>
<p>但很多人并不认可通过名称改写（name mangling) 的方式来存储私有属性，原因很简单，只要知道改写规则，依然很容易的就能读写私有属性。与其自欺欺人，不如采用更简单，更通用的方法，比如给私有属性前面加上单个下划线 _。</p>
<p>注意，以单个下划线开头的属性不会触发任何操作，完全靠自觉与共识。任何稍有追求的 Python 程序员，都不应该读写这些属性。</p>
<h5 id="特性-property"><a href="#特性-property" class="headerlink" title="特性 property"></a>特性 property</h5><p>使用过别的面向对象语言的读者应该都清楚属性的 getter 和 setter 函数的重要性。它们封装了属性的读写操作，可以添加一些额外的逻辑，比如校验新值，返回属性前做一些修饰等等。最简陋的 getter 和 setter 就是两个普通函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def get_name(self):</span><br><span class="line">        return self.name.upper()</span><br><span class="line"></span><br><span class="line">    def set_name(self, new_name):</span><br><span class="line">        if isinstance(new_name, str):</span><br><span class="line">            self.name = new_name.lower()</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">bs = Person(&apos;betterswifter&apos;)</span><br><span class="line">bs.get_name()   # 得到大写的名字： &apos;betterswifter&apos;</span><br><span class="line">bs.set_name(1)  # 由于新的名字不是字符串，所以无法赋值</span><br><span class="line">bs.get_name()   # 还是老的名字： &apos;betterswifter&apos;</span><br></pre></td></tr></table></figure>
<p>工作虽然完成了，但方法并不高明。在 1.2.3 节中我们就见识到了 Python 的一个特点：“内部高度封装，完全对外透明”。这里手动调用 getter 和 setter 方法显得有些愚蠢、啰嗦，比如对比下面的两种写法，在变量名和函数名很长的情况下，差距会更大：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bs.name += &apos;1995&apos;</span><br><span class="line">bs.set_name(bs.get_name() + &apos;1995&apos;)</span><br></pre></td></tr></table></figure>
<p>Python 提供了 @property 关键字来装饰 getter 和 setter 方法，这样的好处是可以直接使用点语法，了解 Objective-C 的读者对这一特性一定倍感亲切:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    @property                        # 定义 getter</span><br><span class="line">    def name(self):                  # 函数名就是点语法访问的属性名</span><br><span class="line">        return self._name.upper()    # 现在真正的属性是 _name 了</span><br><span class="line"></span><br><span class="line">    @name.setter                     # 定义 setter</span><br><span class="line">    def name(self, new_name):        # 函数名不变</span><br><span class="line">        if isinstance(new_name, str):</span><br><span class="line">            self._name = new_name.lower()  # 把值存到私有属性 _name 里</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">bs = Person(&apos;betterswifter&apos;)</span><br><span class="line">bs.name      # 其实调用了 name 函数，得到大写的名字： &apos;betterswifter&apos;</span><br><span class="line">bs.name = 1  # 其实调用了 name 函数，因为类型不符，无法赋值</span><br><span class="line">bs.name      # 还是老的名字： &apos;betterswifter&apos;</span><br></pre></td></tr></table></figure>
<p>我们已经在 2.4 节详细学习了装饰器，应该能意识到这里的 @property 和 @xxx.setter 都是装饰器。因此上述写法实际上等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def get_name(self):</span><br><span class="line">        return self._name.upper()</span><br><span class="line"></span><br><span class="line">    def set_name(self, new_name):</span><br><span class="line">        if isinstance(new_name, str):</span><br><span class="line">            self._name = new_name.lower()</span><br><span class="line">    # 以上是老旧的 getter 和 setter 定义</span><br><span class="line">    # 如果不用 @property，可以定义一个 property 类的实例</span><br><span class="line">    name = property(get_name, set_name)</span><br></pre></td></tr></table></figure>
<p>可见，特性的本质是给类创建了一个类属性，它是 property 类的实例，构造方法中需要把 getter、setter 等函数传入，我们可以打印一下类的 name 属性来证明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.name  # &lt;property object at 0x107c99868&gt;</span><br></pre></td></tr></table></figure>
<p>理解特性的工作原理至关重要。以这里的 name 特性为例，我们访问了对象的 name 属性，但是它并不存在，所以会尝试访问类的 name 属性，这个属性是 property 类的实例，会对读写操作做特殊处理。这也意味着，如果我们重写了类的 name 属性，那么对象的读写方法就不会生效了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bs = Person()</span><br><span class="line">Person.name = &apos;hello&apos;</span><br><span class="line">bs.name  # 实例并没有 name 属性，因此会访问到类的属性 name，现在的值是 &apos;hello` 了</span><br></pre></td></tr></table></figure>
<p>如果访问不存在的属性，默认会抛出异常，但如果实现了 <code>__getattr__</code> 函数，还有一次挽救的机会：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __getattr__(self, attr):</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">bs = Person(&apos;betterswifter&apos;)</span><br><span class="line">bs.name    # 直接访问属性</span><br><span class="line">bs.age     # 得到 0，这是 __getattr__ 方法提供的默认值</span><br><span class="line">bs.age = 1 # 动态给属性赋值</span><br><span class="line">bs.age     # 得到 1，注意！！！这时候就不会再调用 __getattr__ 方法了</span><br></pre></td></tr></table></figure>
<p>由于 <code>__getattr__</code> 只是兜底策略，处理一些异常情况，并非每次都能被调用，所以不能把重要的业务逻辑写在这个方法中.</p>
<h5 id="特性工厂"><a href="#特性工厂" class="headerlink" title="特性工厂"></a>特性工厂</h5><p>在上一节中，我们利用特性来封装 <code>getter</code> 和 <code>setter</code>，对外暴露统一的读写接口。但有些 <code>getter</code> 和 <code>setter</code> 的逻辑其实是可以复用的，比如商品的价格和剩余数量在赋值时，都必须是大于 0 的数字。这时候如果每次都要写一遍 <code>setter</code>，代码就显得很冗余，所以我们需要一个能批量生产特性的函数。由于我们已经知道了特性是 <code>property</code> 类的实例，而且是类的属性，所以代码可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def quantity(storage_name):  # 定义 getter 和 setter</span><br><span class="line">    def qty_getter(instance):</span><br><span class="line">        return instance.__dict__[storage_name]</span><br><span class="line">    def qty_setter(instance, value):</span><br><span class="line">        if value &gt; 0:</span><br><span class="line">            # 把值保存在实例的 __dict__ 字典中</span><br><span class="line">            instance.__dict__[storage_name] = value </span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&apos;value must be &gt; 0&apos;)</span><br><span class="line">    return property(qty_getter, qty_setter) # 返回 property 的实例</span><br></pre></td></tr></table></figure>
<p>有了这个特性工厂，我们可以这样来定义特性:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Item:</span><br><span class="line">    price = quantity(&apos;price&apos;)</span><br><span class="line">    number = quantity(&apos;number&apos;)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">i = Item()</span><br><span class="line">i.price = -1 </span><br><span class="line"># Traceback (most recent call last):</span><br><span class="line"># ...</span><br><span class="line"># ValueError: value must be &gt; 0</span><br></pre></td></tr></table></figure>
<p>作为追求简洁的程序员，我们不禁会问，在 <code>price = quantity(&#39;price&#39;)</code> 这行代码中，属性名重复了两次，能不能在 <code>quantity</code> 函数中自动读取左边的属性名呢，这样代码就可以简化成 <code>price = quantity()</code>了。</p>
<p>答案显然是否定的，因为右边的函数先被调用，然后才能把结果赋值给左边的变量。不过我们可以采用迂回策略，变相的实现上面的需求：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        quantity.count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        quantity.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    storage_name = <span class="string">'_&#123;&#125;:&#123;&#125;'</span>.format(<span class="string">'quantity'</span>, quantity.count)  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[storage_name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)</span><br></pre></td></tr></table></figure>
<p>这段代码中我们利用了两个技巧。首先函数是一等公民， 所以函数也是对象，自然就有属性。所以我们利用 try … except 很容易的就给函数工厂添加了一个计数器对象 count，它每次调用都会增加，然后再拼接成存储时用的键 storage_name ，并且可以保证不同 property 实例的存储键名各不相同.</p>
<p>其次，<code>storage_name</code> 在 <code>getter</code> 和 <code>setter</code> 函数中都被引用到，而这两个函数又被 <code>property</code> 的实例引用，所以 <code>storage_name</code> 会因为被持有而延长生命周期。这也正是闭包的一大特性：能够捕获自由变量并延长它的生命周期和作用域。</p>
<p>我们来验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Item:</span><br><span class="line">    price = quantity()</span><br><span class="line">    number = quantity()</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">i = Item()</span><br><span class="line">i.price = 1</span><br><span class="line">i.number = 2</span><br><span class="line">i.price     # 得到 1，可以正常访问</span><br><span class="line">i.number    # 得到 2，可以正常访问</span><br><span class="line">i.__dict__  # &#123;&apos;_quantity:0&apos;: 1, &apos;_quantity:1&apos;: 2&#125;</span><br></pre></td></tr></table></figure>
<p>可见现在存储的键名可以被正确地自动生成。</p>
<p>#####<br>文件描述符的作用和特性工厂一样，都是为了批量的应用特性。它的写法也和特性工厂非常类似:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Quantity:</span><br><span class="line">    def __init__(self, storage_name):</span><br><span class="line">        self.storage = storage_name</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">        return instance.__dict__[self.storage]</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">        if value &gt; 0:</span><br><span class="line">            instance.__dict__[self.storage] = value</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&apos;value must be &gt; 0&apos;)</span><br></pre></td></tr></table></figure>
<p>主要有以下几个改动：</p>
<ol>
<li>不用返回 <code>property</code> 类的实例了，因此 <code>getter</code> 和 <code>setter</code> 方法的名字是固定的，这样才能满足协议。</li>
<li><code>__get__</code> 方法的第一个参数是描述符类 <code>Quantity</code> 的实例，第二个参数 self 是要读取属性的实例，比如上面的 i，也被称作托管实例。第三个参数是托管类，也就是 Item。</li>
<li><code>__set__</code> 方法的前两个参数含义类似，第三个则是要读取的属性名，比如 price。</li>
</ol>
<p>和特性工厂类似，属性描述符也可以实现 storage_name 的自动生成，这里就不重复代码了。看起来属性描述符和特性工厂几乎一样，但由于属性描述符是类，它就可以继承。比如这里的 Quantity 描述符有两个功能：自动存储和值的校验。自动存储是一个非常通用的逻辑，而值的校验是可变的业务逻辑，所以我们可以先定义一个 AutoStorage 描述符来实现自动存储功能，然后留下一个空的 validate 函数交给子类去重写。</p>
<p>而特性工厂作为函数，自然就没有上述功能，这两者的区别类似于 3.2.1 节中介绍的静态函数与全局函数的区别。</p>
<h5 id="实例属性的查找顺序"><a href="#实例属性的查找顺序" class="headerlink" title="实例属性的查找顺序"></a>实例属性的查找顺序</h5><p>我们知道类的属性都会存储在 <code>__dict__</code> 字典中，即使没有显式的给属性赋值，但只要字典里面有这个字段，也是可以读取到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p.__dict__[&apos;name&apos;] = &apos;betterswifter&apos;</span><br><span class="line">p.name  # 不会报错，而是返回字典中的值，&apos;betterswifter&apos;</span><br></pre></td></tr></table></figure>
<p>但我们在特性工厂和属性描述符的实现中，都是直接把属性的值存储在 <code>__dict__</code>中，而且键就是属性名。之前我们还介绍过，特性的工作原理是没有直接访问实例的属性，而是读取了 property 的实例。那直接把值存在 <code>__dict__</code> 中，会不会导致特性失效，直接访问到原始内容呢？从之前的实践结果来看，答案是否定的，要解释这个问题，我们需要搞明白访问实例属性的查找顺序。</p>
<p>假设有这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o = cls()   # 假设 o 是 cls 类的实例</span><br><span class="line">o.attr      # 试图访问 o 的属性 attr</span><br></pre></td></tr></table></figure>
<p>再对上一节中的属性描述符做一个简单的分类：</p>
<ol>
<li>覆盖型描述符：定义了<code>__set__</code>方法的描述符</li>
<li>非覆盖型描述符：没有定义 <code>__set__</code> 方法的描述符</li>
</ol>
<p>在执行 o.attr 时，查找顺序如下：</p>
<ol>
<li>如果 attr 出现在 cls 或父类的 <code>__dict__</code> 中，且 attr 是覆盖型描述符，那么调用 <code>__get__</code>方法 </li>
<li>否则，如果 attr 出现在 o 的<code>__dict__</code> 中，返回 <code>o.__dict__[attr]</code></li>
<li>否则，如果<code>attr</code> 出现在 cls 或父类的<code>__dict__</code>中，如果 <code>attr</code> 是非覆盖型描述符，那么调用 <code>__get__</code> 方法。</li>
<li>否则，如果没有非覆盖型描述符，直接返回 <code>cls.__dict__[attr]</code></li>
<li>否则，如果 cls 实现了 <code>__getattr__</code> 方法，调用这个方法</li>
<li>抛出 <code>AttributeError</code></li>
</ol>
<p>所以，在访问类的属性时，覆盖型描述符的优先级是高于直接存储在 <code>__dict__</code> 中的值的。 </p>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><h5 id="多继承的必要性"><a href="#多继承的必要性" class="headerlink" title="多继承的必要性"></a>多继承的必要性</h5><p>很多语言类的书籍都会介绍，多继承是个危险的行为。诚然，狭义上的多继承在绝大多数情况下都是不合理的。这里所谓的 “狭义”，指的是一个类拥有多个父类。我们要明确一个概念：继承的目的不是代码复用，而是声明一种 is a 的关系，代码复用只是 is a 关系的一种外在表现。</p>
<p>因此，如果你需要狭义上的多继承，还是应该先问问自己，真的存在这么多 is a 的关系么？你是需要声明这种关系，还是为了代码复用。如果是后者，有很多更优雅的解决方案，因为多继承的一个直接问题就是菱形问题（Diamond Problem）。</p>
<p>但是广义上的多继承是必须的，不能因为害怕多继承的问题就忽略多继承的优点。广义多继承 指的是通过定义接口（Interface）以及接口方法的默认实现，形成“一个父类，多个接口”的模式，最终实现代码的复用。当然，不是每个语言都有接口的概念，比如 Python 里面叫 Mixin，会在 3.3.3 节中介绍。</p>
<p>广义上的多继承非常常见，有一些教科书式的例子，比如动物可以按照哺乳动物，爬行动物等分类，也可以按照有没有翅膀来分类。某一个具体的动物可能满足上述好几类。在实际的开发中也到处都是广义多继承的使用场景，比如 iOS 或者安卓开发中，系统控件的父类都是固定的，如果想让他们复用别的父类的代码，就会比较麻烦。 </p>
<h5 id="Python-的多继承"><a href="#Python-的多继承" class="headerlink" title="Python 的多继承"></a>Python 的多继承</h5><p>Python 语法直接支持多继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def foo(self):</span><br><span class="line">        print(&apos;A&apos;)</span><br><span class="line"></span><br><span class="line">class B(A):     # 继承自 A，重写 foo 方法</span><br><span class="line">    def foo(self):</span><br><span class="line">        print(&apos;B&apos;)</span><br><span class="line"></span><br><span class="line">class C(A):     # 继承自 A，重写 foo 方法</span><br><span class="line">    def foo(self):</span><br><span class="line">        print(&apos;C&apos;)</span><br><span class="line"></span><br><span class="line">class D(B, C):  # 多继承的语法，父类之间用逗号间隔</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo()         # 输出：&apos;B&apos;</span><br></pre></td></tr></table></figure>
<p>这就是著名的菱形问题，D 继承自 B 和 C，而 B 和 C 都继承自 A，他们的继承关系构成一个菱形。调用 D 类实例的 <code>foo</code> 方法会让人产生疑惑，它的父类们都实现了 <code>foo</code> 方法，到底以谁为准？</p>
<p>Python 有一套算法来计算遍历顺序，这个顺序叫做<code>方法解析顺序（Method Resolution Oder，MRO）</code>。这个算法叫做 C3 算法，可以参考这篇官方文档：<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">The Python 2.3 Method Resolution Order</a></p>
<p>不过在绝大多数情况下，除非你的代码极度依赖多继承，否则都不需要了解这个算法的具体工作原理。一方面，我们可以调用某个特定父类的方法。我们也许已经注意到两个事实，首先类中定义的方法其实都是类的属性，但调用者都是类的实例。其次，类方法的第一个参数都是 self，表示方法的调用者，但我们调用时并不需要传入实例。这是因为其实实例方法的正规调用方式是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C.foo(C())</span><br><span class="line"># 或者是</span><br><span class="line">C.foo(d)</span><br></pre></td></tr></table></figure>
<p>这种调用方式符合定义，而且能够解释上述的两个疑问。然而这种调用方式不仅写起来麻烦，还很不合理，因为我们不仅要实例对象，还需这个实例所属的类才能调用。因此，Python 的做法是将类中定义的方法绑定到每一个实例上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D.foo  # &lt;function B.foo at 0x10696c158&gt; 这个是真正的方法对象</span><br><span class="line">d      # &lt;__main__.D object at 0x1075fa400&gt;  这个是 D 的一个实例</span><br><span class="line">d.foo  # &lt;bound method B.foo of &lt;__main__.D object at 0x106967400&gt;&gt; 注意看地址和 d 是一致的</span><br><span class="line">d.foo.__self__ # &lt;__main__.D object at 0x1075fa400&gt;，通过 __self__ 引用绑定的实例</span><br></pre></td></tr></table></figure>
<p>可以清楚的从 <code>d.foo</code> 的输出结果看出来，它是绑定到 d 对象上的函数，第一个参数 self 就是 <code>d</code>.</p>
<p>另一方面，我们不仅可以调用任意父类的方法，还可以通过类的 <code>__mro__</code>属性查看父类的继承顺序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D.__mro__</span><br><span class="line"># (&lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure>
<p>所以，多继承的方法调用顺序一般情况下不会对开发代码造成太大的困扰。</p>
<h5 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h5><p>Mixin 不是 迷信 的拼音，它表示混入，可以方便的实现代码复用。在 Python 中，Mixin 是以多继承的形式实现的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class JSONable:</span><br><span class="line">    def to_json(self):</span><br><span class="line">         return str(self.__dict__)</span><br><span class="line"></span><br><span class="line">class DebugMixin:</span><br><span class="line">    def __repr__(self):</span><br><span class="line">         return &apos;&apos;</span><br><span class="line"></span><br><span class="line">class Controller(BaseController, JSONable, DebugMixin):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>Mixin 和多继承最大的区别在于它一般不产生菱形问题，但 Python 并没有语法层面的约束来保证这一点，所以对于 Mixin，我们一般需要遵守以下几个约定：</p>
<ol>
<li>一般命名以 Mixin、able、ible 结尾，明确表示混入，或者提供某种能力</li>
<li>一般不要有复杂的继承关系，尤其不要和被混入的类（比如上面的 Controller 类）有共同的父类，避免菱形问题</li>
<li>一般提供简单的功能，如果有多个功能，就写成多个 Mixin。</li>
<li>功能完备、独立，不要依赖被混入的类。</li>
<li>看到上述命名风格的类，不要实例化他们，仅用在多继承中</li>
</ol>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>有时候我们需要在父类定义一个方法，然后交给子类去实现。这种方法叫做抽象方法， 定义了抽象方法的类叫做抽象类。抽象类不应该被实例化，在 Java 中，Interface 就是抽象类，它不能被实例化，只有实现了协议的类才能创建实例.</p>
<p>在 Python 中，抽象类需要把自己的 metaclass 设置为 abc.ABCMeta，并且用装饰器去标记抽象函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import abc</span><br><span class="line"></span><br><span class="line">class Base:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class BaseItem(Base, metaclass=abc.ABCMeta):   # 需要标记 metaclass</span><br><span class="line">    @abc.abstractmethod                        # 抽象函数</span><br><span class="line">    def get_price(self):</span><br><span class="line">         &quot;&quot;&quot;Method that should do something.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">item = BaseItem()</span><br><span class="line"># Traceback (most recent call last):</span><br><span class="line"># ...</span><br><span class="line"># TypeError: Can&apos;t instantiate abstract class BaseItem with abstract methods get_price</span><br></pre></td></tr></table></figure>
<p>如果设置了 <code>metaclass</code> 并且标记了抽象函数，那么任何没有实现抽象函数的子类（包括抽象类自己）都无法实例化。</p>
<h4 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h4><h5 id="类工厂函数"><a href="#类工厂函数" class="headerlink" title="类工厂函数"></a>类工厂函数</h5><p>有些类的功能很单一，仅仅用来存储数据。但如果先声明一个长长的 <code>__init__</code>函数，再挨个写 <code>self.xxx = xxx</code> 这种模板代码，就显得很啰嗦。其实也可以自己实现一个 1.1.2 节中的具名元组。具名元zu组是一个函数，它返回一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">People = collections.namedtuple(&apos;People&apos;, [&apos;name&apos;, &apos;age&apos;])</span><br><span class="line">p = People(&apos;betterswifter&apos;, &apos;22&apos;)</span><br></pre></td></tr></table></figure>
<p><code>namedtuple</code> 这种函数可以称为类工厂函数，因为它可以根据传入的参数，动态的生成类，我们来实现一个简化版的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def my_tuple(cls, names):</span><br><span class="line">    names = names.split(&apos; &apos;)   # 这里会得到属性的数组</span><br><span class="line">    def __init__(self, *args):</span><br><span class="line">        for (name, value) in zip(self.__slots__, args):</span><br><span class="line">            # slots 是属性名，args 是初始化的参数，一一对应起来用 setattr 给实例的属性赋值</span><br><span class="line">            setattr(self, name, value)  </span><br><span class="line"></span><br><span class="line">    cls_attrs = dict(__slots__ = names, __init__ = __init__)</span><br><span class="line">    return type(cls, (object, ), cls_attrs)</span><br><span class="line"></span><br><span class="line">People = my_tuple(&apos;People&apos;, &apos;name age&apos;)</span><br><span class="line">p = People(&apos;betterswifter&apos;, &apos;22&apos;)</span><br><span class="line">p.name   # &apos;betterswifter&apos;</span><br><span class="line">p.age    # 22</span><br></pre></td></tr></table></figure>
<p>这个类工厂非常简陋，比如不支持关键字参数，但用来演示类工厂的原理是已经足够了。类工厂的核心原理在于 type 函数，它不仅可以传入一个实例，返回实例的类型，也可以像这里的使用一样，传入三个参数，构造一个类。第一个参数表示类名，第二个参数是继承关系，最后一个则是类的属性.</p>
<h5 id="元类的概念"><a href="#元类的概念" class="headerlink" title="元类的概念"></a>元类的概念</h5><p>元类和类工厂函数的区别就像属性描述符和特性工厂函数的区别一样，前者是类，可以继承，后者不行。就像我们上一节中用 type 来生成类一样，Python 中的类都是 type 类的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;betterswifter&apos;.__class__  # &lt;class &apos;str&apos;&gt;，字符串都是 str 类的实例</span><br><span class="line">str.__class__            # &lt;class &apos;type&apos;&gt; str 类是 type 类的实例</span><br><span class="line">int.__class__            # &lt;class &apos;type&apos;&gt; int 也是 type 类的实例</span><br><span class="line">type.__class__           # &lt;class &apos;type&apos;&gt; type 类是自己的实例，防止死循环</span><br></pre></td></tr></table></figure>
<p>需要说明的是，<code>__class__</code> 表示的是元类，而不是父类，父类可以通过 3.3.2 节中介绍的 <code>__mro__</code> 属性来查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int.__mro__  # (&lt;class &apos;int&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br><span class="line">str.__mro__  # (&lt;class &apos;str&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure>
<p>可见 int 和 str 这些内置类的父类都是 objcet，我们可以认为 object 是所有类的父类，而 type 是所有类的元类，这个规则在这两个类之间也适用，可以验证一下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.__class__   # &lt;class &apos;type&apos;&gt;</span><br><span class="line">type.__mro__       # (&lt;class &apos;type&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure>
<p>可见 <code>object</code> 是 <code>type</code> 类构建出来的实例，<code>type</code> 是 <code>object</code> 类的元类，而 <code>object</code> 则是 <code>type</code> 类的父类。如下图所示:</p>
<p><img src="/lvchenqiang.github.io/2018/03/24/Python入门指南/metaclass.png" alt=""></p>
<p>这里介绍元类和父类并非是为了烧脑，除了描述最基本的概念以外，我们应该意识到，类是由元类的 <code>__init__</code> 方法构造出来的实例，如果我们继承元类并且重写 <code>__init__</code> 方法，就可以控制类的初始化方法。</p>
<h5 id="元类的使用示例"><a href="#元类的使用示例" class="headerlink" title="元类的使用示例"></a>元类的使用示例</h5><p>在介绍属性描述符时，我们用计数器来实现 <code>storage_name</code> 的自动生成，从而避免冗余的代码，但代码的可读性会下降，因为属性的名称无法获得，只能用递增的数字来区别。利用元类，我们可以在不影响可读性的前提下，实现存储名称的自动生成:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">    __counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        cls = self.__class__</span><br><span class="line">        self.storage = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(cls.__name__, cls.__counter)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[self.storage]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            instance.__dict__[self.storage] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"><span class="comment"># Quantity 类是可以自动生成 storage 名称的描述符类，和之前的逻辑基本类似，可以不用关注</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承自 type 类，是一个自定义的元类    </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuantityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attr_dict)</span>:</span> </span><br><span class="line">        <span class="comment"># name 表示类名，bases 是继承关系，attr_dict 则是属性列表，和 type 方法的参数含义一致</span></span><br><span class="line">        super().__init__(name, bases, attr_dict)</span><br><span class="line">        <span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():</span><br><span class="line">            <span class="comment"># 注意，类有很多属性，但只有描述符类型的属性才需要修改</span></span><br><span class="line">            <span class="keyword">if</span> isinstance(attr, Quantity):</span><br><span class="line">                type_name = type(attr).__name__</span><br><span class="line">                <span class="comment"># 这里的 key 就是原来的属性名，比如 price、number</span></span><br><span class="line">                attr.storage = <span class="string">'_&#123;&#125;#&#123;&#125;'</span>.format(type_name, key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了避免让用户知道太多元类的细节，我们创建一个基类 Entity，并把它的元类设置为 QuantityMeta</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=QuantityMeta)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在用户的类只要继承自 Entity 就可以了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span><span class="params">(Entity)</span>:</span></span><br><span class="line">    price = Quantity()</span><br><span class="line">    number = Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">i = Item()</span><br><span class="line">i.price = <span class="number">1</span></span><br><span class="line">print(i.__dict__)  <span class="comment"># 得到 &#123;'_Quantity#price': 1&#125;，可读性良好</span></span><br><span class="line"><span class="comment">#i.price = -1      # 抛出异常</span></span><br></pre></td></tr></table></figure>
<p>虽然代码比较长，但其实核心很简单，在元类的 <code>__init__</code> 方法中，我们可以获取将要生成的类的名称、父类和属性，就像在类工厂函数中传给 type 类的那些参数一样。有了这些信息，我们可以把当初用计数器生成的临时存储名称给改正为可读性更高的名称。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="else"><a href="#else" class="headerlink" title="else"></a>else</h4><p>除了最常见的 <code>if ... else ...</code> 语句外，还有很多地方都会用到 else，它的用法各不相同，但如果灵活使用，会使代码更简洁， 更具可读性。</p>
<h5 id="for-else"><a href="#for-else" class="headerlink" title="for else"></a>for else</h5><p>for 语句的末尾可以加上 else，仅当 for 循环没有因为 break 而终止，顺利运行完以后才运行。这个用法看起来怪怪的，毕竟其他 for 循环后面的代码，也会正常执行。所以这个规则应该反过来理解：如果 for 循环因为 break 而终止，else 代码块就不会执行。</p>
<p>有过一些编程经验的读者应该经常会写出这样的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">found = False</span><br><span class="line">for i in array:</span><br><span class="line">    if some_judge(i):  # 只要找到一个满足条件的，就把 found 置为 True</span><br><span class="line">        found = True</span><br><span class="line">        break</span><br><span class="line">if not found:          # 如果全都不符合条件，执行某个逻辑</span><br><span class="line">    print(&apos;Nothing found&apos;)</span><br></pre></td></tr></table></figure>
<p>如果用 else 语句，代码就会简化:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in array:</span><br><span class="line">    if some_judge(i):</span><br><span class="line">        break</span><br><span class="line">else:</span><br><span class="line">    print(&apos;Nothing found&apos;)</span><br></pre></td></tr></table></figure>
<p>如果 if 判断成立了，就会进入 break，于是 else 的代码就不会执行，否则就会输出 Nothing found。和上面的例子相比，使用 else 的代码更简洁，而且不需要再用一个变量来标记了。</p>
<h5 id="while-else"><a href="#while-else" class="headerlink" title="while else"></a>while else</h5><p>仅当 while 循环因为判断条件不成立而退出，而不是因为 <code>break</code> 才退出时，才会执行 <code>else</code> 代码块，用法和 <code>for ... else ...</code> 基本一致。</p>
<h5 id="try-else"><a href="#try-else" class="headerlink" title="try else"></a>try else</h5><p>仅当 <code>try</code> 代码块中没有抛出异常时才会执行 <code>else</code>。为了理解 <code>try ... else</code> 的使用场景，我们先看一个常见的场景。</p>
<p>一个很常见的错误是为了处理异常，把一大段代码都放在 <code>try</code> 语句中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    # 写了几十行毫无问题的代码</span><br><span class="line">    # ...</span><br><span class="line">    some_dangarous_operation()</span><br><span class="line">    # ...</span><br><span class="line">    # 下面跟了几十行毫无问题的代码</span><br><span class="line">except Exception as e:</span><br><span class="line">    # 处理异常</span><br></pre></td></tr></table></figure>
<p>这种写法非常不负责任，<code>try</code> 不是防止崩溃的银弹，而是应该用在真正可能导致异常的函数上，所以要保证 <code>try</code> 的代码块尽可能简单，突出要尝试执行的代码。以这段代码为例，<code>some_dangarous_operation</code> 函数之前的代码可以放在 <code>try</code> 代码块上面写，但如果 <code>some_dangarous_operation</code> 函数之后的代码依赖于这个函数的正确执行，就不太好独立出来了。这时候就该 <code>try ... else</code> 发挥作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># some_dangarous_operation 之前的安全代码写在这里</span><br><span class="line"># ...</span><br><span class="line">try:</span><br><span class="line">    some_dangarous_operation()</span><br><span class="line">except Exception as e:</span><br><span class="line">    # 处理异常</span><br><span class="line">else:</span><br><span class="line">    # ...</span><br><span class="line">    # 依赖于 some_dangarous_operation 的安全代码</span><br></pre></td></tr></table></figure>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h5 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h5><p>迭代器接口定义了两个方法，<code>__next__</code> 方法没有参数，用于返回序列的下一个元素，如果没有元素就抛出 <code>StopIteration</code> 异常，<code>__iter__</code>方法返回自己。</p>
<p>根据鸭子类型的定义，一个类不用声明为迭代器，只要它实现了迭代器接口中定义的两个方法，就可以迭代：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MyIterator:</span><br><span class="line">    index = 0</span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.index &gt; 2:</span><br><span class="line">            raise  StopIteration</span><br><span class="line">        else:</span><br><span class="line">            self.index += 1</span><br><span class="line">            return self.index</span><br><span class="line">    def __iter__():</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">i = MyIterator()</span><br><span class="line">next(i) # 得到 1，i 的 index 为 1</span><br><span class="line">next(i) # 得到 1，i 的 index 为 2</span><br><span class="line">next(i) # 得到 1，i 的 index 为 3</span><br><span class="line">next(i) # 根据 if 判断的条件，抛出 StopIteration 异常，迭代结束</span><br></pre></td></tr></table></figure>
<p>next 函数的参数是迭代器，用于获取迭代器中的下一个元素。</p>
<h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><p>用 <code>next</code> 函数去迭代一个迭代器对象，不仅语法繁琐，每次还要用 <code>try catch</code> 来处理随时都有可能发生的 <code>StopIteration</code>异常，这种写法实在是太啰嗦了。所以我们平时都用 <code>for in</code> 语法来遍历字符串、数组等可迭代对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for c in &apos;betterswifter&apos;:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>
<p>这种写法其实是对迭代器的封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it = iter(&apos;betterswifter&apos;)</span><br><span class="line">while True:</span><br><span class="line">    try:</span><br><span class="line">        print(next(it))</span><br><span class="line">    except StopIteration:</span><br><span class="line">        del it</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>
<p>可见 <code>for in</code> 语法省略了大量的模板代码。可以看到这里的字符串是可迭代对象，在用 <code>for in</code> 遍历时，其实是通过 <code>iter</code> 函数获取了可迭代对象的迭代器，然后用 <code>next</code> 函数去遍历这个迭代器，这揭示了迭代器和可迭代对象之间重要的关系：<code>Python 用 iter 函数从可迭代对象中获取迭代器</code>。</p>
<h5 id="iter-方法"><a href="#iter-方法" class="headerlink" title="__iter__ 方法"></a><code>__iter__</code> 方法</h5><p>能够用 <code>for in</code> 语法遍历的对象必须是可迭代的，除了内置的数组、元组等类型外，自定义的类型也有办法变成可迭代的，因为 <code>iter</code> 函数最终会调用对象的 <code>__iter</code> 方法。我们只要能实现这个方法，返回适当的迭代器，就可以让对象变成可迭代的，并支持 <code>for in</code> 语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return iter([1, 2, 3])</span><br><span class="line"></span><br><span class="line">for i in Foo():</span><br><span class="line">    print(i) # 共三行输出，分别是 1、2 和 3</span><br></pre></td></tr></table></figure>
<p>没实现 <code>__iter__</code> 方法，但是实现了<code>__getitem__</code>方法的对象也是可迭代的，这个函数在 1.1.5 节中已经介绍过，用来处理下标访问。Python 会创建一个迭代器，并且用从 0 开始的整数调用 <code>__getitem__</code>方法作为迭代器的 next 值。如果实现了 <code>__len__</code> 是最好，<code>Python</code> 解释器只会调用指定次数的 <code>__getitem__</code>，否则会在越界时自动停止。</p>
<p>再次总结下，可迭代对象和迭代器是两个概念，写在 <code>for in</code> 中的是可迭代对象，它需要实现 <code>__iter__</code> 方法为 <code>iter</code> 方法提供一个迭代器。迭代器需要满足迭代器接口， 也就是两个函数。无参数的<code>__next__</code> 方法提供下一个元素或者抛出异常，<strong>iter</strong> 函数返回自己。从这个角度看，迭代器都是可迭代对象。</p>
<h5 id="标准迭代器"><a href="#标准迭代器" class="headerlink" title="标准迭代器"></a>标准迭代器</h5><p>有了上述知识作为铺垫，我们来尝试实现一个定义的可迭代对象。它只需要实现一个 <code>__iter__</code> 方法，返回迭代器即可，一个常见的写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class MyCollection:</span><br><span class="line">    count = 0</span><br><span class="line">    _private_data = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.count &lt; len(self._private_data):</span><br><span class="line">            temp = self._private_data[self.count]</span><br><span class="line">            self.count += 1</span><br><span class="line">            return temp</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration</span><br><span class="line"></span><br><span class="line">c = MyCollection()</span><br><span class="line">for i in c:</span><br><span class="line">    print(i) # 输出三行，分别是 1，2 和 3</span><br></pre></td></tr></table></figure>
<p>这段代码中，<code>__iter__</code> 函数返回了自己，并且自己实现了迭代器的接口，一切运行正常。</p>
<p>并且这段代码向我们展示了迭代器的第一个特点：<strong>屏蔽内部的存取细节， 对外提供统一的访问逻辑</strong></p>
<p>很可惜的是，这段代码是标标准准的错误写法，因为可迭代对象的迭代器一定不能是自己，或者说可迭代对象一定不能实现<code>__next__</code> 方法，理由很简单，看一眼 4.2.1 节中的迭代器，它是一次性的，遍历完以后就回不去了。这里也是同理，如果我们再执行一次 for in，就得不到输出了。换个角度思考，上一节的结论告诉我们，同时实现了 <code>__iter__</code> 和 <code>__iter__</code> 方法的是迭代器，而迭代器是不能用于 for in 语句的。</p>
<p>正确的写法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyCollection:</span><br><span class="line">    _private_data = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return MyCollectionIterator(self._private_data)</span><br><span class="line"></span><br><span class="line">class MyCollectionIterator:</span><br><span class="line">    count = 0</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        if self.count &lt; len(self.data):</span><br><span class="line">            temp = self.data[self.count]</span><br><span class="line">            self.count += 1</span><br><span class="line">            return temp</span><br><span class="line">        else:</span><br><span class="line">            raise StopIteration</span><br><span class="line"></span><br><span class="line">for i in MyCollection():</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>代码很长，但思路很简单，就是遵守迭代器和可迭代对象的定义，把一次性的迭代工作交给可以重复创建实例的 MyCollectionIterator 类完成。</p>
<p>这也正是迭代器模式的另一个特点，<code>对象能够正确保存多次迭代的进度，支持多次迭代</code>。</p>
<h5 id="初识生成器"><a href="#初识生成器" class="headerlink" title="初识生成器"></a>初识生成器</h5><p>稍有追求的程序员都难以容忍这么多模板代码（两个<code>__iter__</code>， 一个 <code>__next__</code>），好在 Python 的生成器可以简化上述代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MyCollection:</span><br><span class="line">    _private_data = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        for i in self._private_data:</span><br><span class="line">            yield i</span><br></pre></td></tr></table></figure>
<p>从直观上看，这里用 yield 关键字替换了 return，打破了 “可迭代对象不能实现 <code>__next__</code> ” 的规定，但却能够支持多次遍历，这段代码的工作原理会在介绍完生成器以后解释。</p>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><h5 id="生成器的定义"><a href="#生成器的定义" class="headerlink" title="生成器的定义"></a>生成器的定义</h5><p>先给出生成器的定义:</p>
<ol>
<li>只要函数体中有 yield 关键字，这个函数就是生成器函数</li>
<li>调用生成器函数，会得到<code>生成器</code>，生成器函数可以理解为生成器的工厂</li>
<li>调用 <code>next</code> 函数会激发生成器的下一个值</li>
</ol>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def gen():</span><br><span class="line">    print(&apos;Start&apos;)</span><br><span class="line">    yield 1</span><br><span class="line">    print(&apos;Continue&apos;)</span><br><span class="line">    yield 2</span><br><span class="line">    yield 3</span><br><span class="line"></span><br><span class="line">g = gen()       # 注意，这里没有输出！！！</span><br><span class="line">print(next(g))  # 输出两行，start 和 1</span><br><span class="line">print(next(g))  # 输出两行，Continue 和 2</span><br><span class="line">print(next(g))  # 输出 2</span><br><span class="line">print(next(g))  # 抛出异常 StopIteration</span><br></pre></td></tr></table></figure>
<p>从输出内容中可以看出，调用生成器函数会返回一个生成器对象，但生成器函数中的代码不会执行。在调用 <code>next(g)</code> 函数时才会执行生成器函数的代码，阻塞在 <code>yield x</code> 这一行，并且<code>next(g)</code> 函数的返回值就是 x。第几次调用 <code>next</code> 函数，就会阻塞在第几个 <code>yield</code> 处。如果是第一次接触生成器，这个逻辑需要反复体会几次。</p>
<p>生成器的使用方式和迭代器一致，我们可以认为生成器都是迭代器，都实现了迭代器接口。因此 4.2.5 节中的代码就很容易解释了。当外部调用 <code>iter()</code> 函数时，实际上 <code>__iter__</code> 方法中的代码并没有被立刻执行，而是返回了一个生成器.</p>
<h5 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h5><p>我们在文章开头的 1.1.1 节中介绍了数组推导，生成器表达式可以理解为惰性版的数组推导：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = [1, 2, 3]</span><br><span class="line">[x * 2 for x in array] # 数组推导</span><br><span class="line">(x * 2 for x in array) # 生成器表达式</span><br></pre></td></tr></table></figure>
<p>两者的写法非常类似，只是把数组的大括号换成了圆括号，区别在于前者生成了一个新的数组，如果原来的数组占用 M 兆内存，现在两个数组就会占用 2 * M 兆内存。而生成器是懒计算的，并不增加内存占用。</p>
<p>生成器表达式对于大容量的数组，或者无尽数组特别适用，比如可以写一个斐波那契数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fib():</span><br><span class="line">    a = 0</span><br><span class="line">    b = 1</span><br><span class="line">    while True:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"># fib() 可以被当成无尽队列，我们只取前 10 个元素        </span><br><span class="line">for i, n in enumerate(fib()):</span><br><span class="line">    if i &lt; 10:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure>
<h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>上一节中介绍的生成器有两个小缺点：</p>
<ol>
<li>这段代码无法正常退出，因为 <code>fib</code> 函数是个死循环，最终会停在第 11 个 <code>yield</code> 上，等待外部的 <code>next</code> 函数</li>
<li>现在的数据传递都是单向的，只有生成器给调用方传值，调用方无法给生成器传值</li>
</ol>
<p>实际上，生成器函数都是协程，我们可以利用协程的特性解决这两个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fibs = fib()</span><br><span class="line">for i, n in enumerate(fibs):</span><br><span class="line">    if i &lt; 10:</span><br><span class="line">        print(n)</span><br><span class="line">    else:</span><br><span class="line">        fibs.close()</span><br></pre></td></tr></table></figure>
<p>只要在遍历完以后调用生成器的 <code>close</code> 方法，就可以结束生成器并正确的退出了。如果需要向生成器中传值，需要调用生成器对象的 <code>send</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def fib():</span><br><span class="line">    a = 0</span><br><span class="line">    b = 1</span><br><span class="line">    i = 0</span><br><span class="line">    while True:</span><br><span class="line">        i = yield &apos;第&#123;0&#125;个数是: &#123;1&#125;&apos;.format(i, b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line">fibs = fib()</span><br><span class="line">next(fibs)</span><br><span class="line">for i in range(10):</span><br><span class="line">    print(fibs.send(i))</span><br></pre></td></tr></table></figure>
<p>此时，<code>yield</code> 表达式左边的值就是 <code>send</code> 函数中的参数，而 <code>send</code> 函数的返回值则是 yield 关键字右边的结果。</p>
<p>协程的用法并不复杂，但它是异步编程的基础，比如 ES 7 中的 async/await 语法，能将异步回调变成同步的写法，它就是依靠协程实现的.</p>
<h5 id="预激协程"><a href="#预激协程" class="headerlink" title="预激协程"></a>预激协程</h5><p>在创建生成器时，并不会执行生成器函数中的代码，第一次调用 <code>next(g)</code>函数时会执行到第一个 <code>yield</code> 处。而协程的 send 函数用来给 <code>yield</code> 左侧的变量赋值。所以在调用 <code>send</code> 函数之前一定要确保已经调用过 <code>next()</code> 函数，这样协程才会停留在 <code>yield</code> 处而不是停留在刚创建的状态。这一步操作叫做协程的预激，上一节的代码中已经演示了这一点.</p>
<p>在使用协程时，一般都需要预激，也就是说 next(g) 其实是一个模板代码，可以被优化掉。要想改变一个函数的运行逻辑，最好的方法是使用装饰器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def coroutine(original_coroutine):       </span><br><span class="line">    @functools.wraps(original_coroutine)</span><br><span class="line">    def activate(*args, **kwargs):  # 用 active 函数替换被装饰的 fib 函数</span><br><span class="line">        gen = original_coroutine(*args, **kwargs)  # 调用 fib 函数</span><br><span class="line">        next(gen)  # 预激协程</span><br><span class="line">        return gen   # 像 fib 函数一样，返回预激过的协程</span><br><span class="line">    return activate  # 被装饰的函数 fib 现在替换为了 active 函数，会自动预激</span><br><span class="line"></span><br><span class="line">@coroutine</span><br><span class="line">def fib():</span><br><span class="line">    a = 0</span><br><span class="line">    b = 1</span><br><span class="line">    i = 0</span><br><span class="line">    while True:</span><br><span class="line">        i = yield &apos;第&#123;0&#125;个数是: &#123;1&#125;&apos;.format(i, b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line">fibs = fib()</span><br><span class="line">for i in range(10):</span><br><span class="line">    print(fibs.send(i))</span><br></pre></td></tr></table></figure>
<p>温故一下装饰器的定义，被 <code>coroutine</code> 装饰的 <code>fib</code> 函数等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_fib = coroutine(fib)</span><br><span class="line"># 根据 coroutine 函数的定义，coroutine(fib) 实际上会返回下面这个函数</span><br><span class="line">def activate():</span><br><span class="line">    gen = fib()</span><br><span class="line">    next(gen)</span><br><span class="line">    return gen</span><br></pre></td></tr></table></figure>
<h5 id="标准库中的生成器函数"><a href="#标准库中的生成器函数" class="headerlink" title="标准库中的生成器函数"></a>标准库中的生成器函数</h5><p><code>itertools</code> 模块提供了很多生成器函数，这些函数处理可迭代的对象，并且返回生成器（节省内存，可迭代）。想要了解生成器函数，唯一可能的知识来源就是这篇<a href="https://docs.python.org/3/library/itertools.html#module-itertools" target="_blank" rel="noopener">官方文档</a>，本节会做简单的翻译和解释。它把生成器函数分为三大类</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>参数</th>
<th>返回结果</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>count()</td>
<td>start, [step]</td>
<td>start, start+step, start+2*step, …</td>
<td><code>count(10) --&gt; 10 11 12 13 14 ...</code></td>
</tr>
<tr>
<td>cycle()</td>
<td>p（数组）</td>
<td>p0, p1, …， pn, p0, p1, …</td>
<td><code>cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D ...</code></td>
</tr>
<tr>
<td>repeat()</td>
<td>elem [,n]</td>
<td>elem, elem, elem, … 无尽队列或最多 n 次</td>
<td><code>repeat(10, 3) --&gt; 10 10 10</code></td>
</tr>
</tbody>
</table>
<p>这三个函数的注释都说明得清楚了，配合示例应该非常容易理解。</p>
<p>第二类函数返回的是有限生成器，长度和传入的可迭代对象有关，我选择几个比较常用的列出来 ：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>参数</th>
<th>返回结果</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>accumulate()</td>
<td>p [,func]</td>
<td>p0, func(p0, p1), func(p1, p2), func(p2, p3) …</td>
<td><code>accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</code></td>
</tr>
<tr>
<td>chain()</td>
<td>p, q, …</td>
<td>p0, p1, … plast, q0, q1, …</td>
<td><code>chain(&#39;ABC&#39;, &#39;DEF&#39;) --&gt; A B C D E F</code></td>
</tr>
<tr>
<td>compress()</td>
<td>data, selectors</td>
<td>(d[0] if s[0]), (d[1] if s[1]), …</td>
<td><code>compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&gt; A C E F</code></td>
</tr>
<tr>
<td>dropwhile()</td>
<td>pred, seq</td>
<td>假设 pred 在第 n 个元素开始不成立：seq[n], seq[n+1]</td>
<td><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</code></td>
</tr>
<tr>
<td>tee()</td>
<td>it, n</td>
<td>产出 n 各元素的数组，每个元素可以看做 it 的备份，相当于把 it 复制了 n 份</td>
<td><code>tee(&#39;ABC&#39;, 2) --&gt; g1, g2(迭代 g1 和 g2 都会得到 A、B、C)</code></td>
</tr>
</tbody>
</table>
<p>最后一类是可以实现排列组合操作的生成器函数：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>参数</th>
<th>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>product()</td>
<td>p, q, … [repeat=1]</td>
<td>生成各个可迭代对象的笛卡尔积，n 表示每个可迭代对象对象重复几次</td>
</tr>
<tr>
<td>permutations()</td>
<td>p[, r]</td>
<td>序列 p 所有长度为 r 的无重复元素排列</td>
</tr>
<tr>
<td>combinations()</td>
<td>p, [r]</td>
<td>序列 p 所有长度为 r 的无重复元素有序排列</td>
</tr>
<tr>
<td>combinations_with_replacement()</td>
<td>p, [r]</td>
<td>序列 p 所有长度为 r 的有重复元素有序排列</td>
</tr>
</tbody>
</table>
<p>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from itertools import *</span><br><span class="line"></span><br><span class="line"># ABC 和 12 的笛卡尔积，所以共有 6 个元素</span><br><span class="line"># 得到：A1、A2、B1、B2、C1、C2</span><br><span class="line">l1 = list(product(&apos;ABC&apos;, &apos;12&apos;))</span><br><span class="line"></span><br><span class="line"># 相当于 product(&apos;AB&apos;, &apos;AB&apos;)</span><br><span class="line"># 得到：AA、AB、BA、BB</span><br><span class="line">l2 = list(product(&apos;AB&apos;, repeat=2))</span><br><span class="line"></span><br><span class="line"># ABCD 所有所有长度为 2 的无重复、无序子排列</span><br><span class="line"># 每个元素可以和除了自己的另外三个元素组合，因此有 4 * 3 个</span><br><span class="line"># 得到：AB、AC、AD、BA、BC、BD、CA、CB、CD、DA、DB、DC</span><br><span class="line">l3 = list(permutations(&apos;ABCD&apos;, 2))</span><br><span class="line"></span><br><span class="line"># ABCD 所有所有长度为 2 的无重复、有序子排列</span><br><span class="line"># AB 和 BA 会被认为是相同的，所以只有 12 / 2 = 6 个</span><br><span class="line"># AB、AC、AD、BC、BD、CD</span><br><span class="line">l4 = list(combinations(&apos;ABCD&apos;, 2))</span><br><span class="line"></span><br><span class="line"># ABCD 所有所有长度为 2 的有重复、有序子排列</span><br><span class="line"># AA、BB 这样的也合法，所以有 6 + 4 = 10 个</span><br><span class="line"># 得到：AA、AB、AC、AD、BB、BC、BD、CC、CD、DD</span><br><span class="line">l5 = list(combinations_with_replacement(&apos;ABCD&apos;, 2))</span><br></pre></td></tr></table></figure>
<p>本节仅列出了一部分常用的生成器函数，他们是系统库提供的轮子。因此在自己实现关于序列的操作以前，应该思考下这是否是常见操作，系统是否已经提供了轮子。在官方文档的最后一节 还有一些基于上述生成器函数的拓展，通过简单的封装了 itertools 模块中的生成器函数，提供了更多常见的函数，比如 take、tail、consume、nth、flatten 等等，强烈建议阅读一遍并且形成基本印象!</p>
<h4 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h4><h5 id="with-块"><a href="#with-块" class="headerlink" title="with 块"></a>with 块</h5><p><code>with</code> 代码块的一个常见用法是用于打开文件，有经验的 Python 程序员不会建议你写出这样的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(file_path)</span><br><span class="line">data = f.readlines()</span><br><span class="line"># 处理 data</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>用 <code>with</code> 块的写法则是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(file_path) as f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    # 处理 data</span><br></pre></td></tr></table></figure>
<p>这样写的好处不仅仅是不用在最后关闭文件。试想一下，如果在处理文件的过程中有多个地方有可能会抛出异常，那么在所有 <code>try catch</code> 语法的最后都要写上 <code>finally</code> 以便关闭文件。如果放到 <code>with</code> 块中写，则不需要在这么多代码。</p>
<h5 id="自定义上下文"><a href="#自定义上下文" class="headerlink" title="自定义上下文"></a>自定义上下文</h5><p><code>with</code> 块的本质是为了简化 <code>try finally</code> 语句，以上一节的代码为例，跟在 <code>with</code> 后面的<code>open()</code> 函数会返回一个对象，它是 TextIOWrapper 类的实例，我们把它称为上下文管理器，上下文管理器需要实现 <code>__enter__</code> 和 <code>__exit__</code> 方法。</p>
<p><code>__enter__</code> 方法的返回值可以用 as 来引用，这里上下文管理器的 <code>__enter__</code> 方法的返回值是 self，所以以下两种写法中的文件句柄 <code>fp</code> 是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp = open(file_path)</span><br><span class="line">with open(file_path) as fp</span><br></pre></td></tr></table></figure>
<p>第一行中的 <code>fp</code> 可以理解为第二行中的上下文管理器，也就是 with 后面表达式的返回值。而 <code>as</code> 后面的 <code>fp</code> 则是上下文管理器的 <code>__enter__</code> 方法的返回值，由于这里返回的是 <code>self</code>，所以两者恰好相同。</p>
<p>无论以哪种方式退出 with 块（正常结束或者因为抛出异常而退出），都会调用上下文管理器的 <code>__exit__</code> 方法。注意，这里不是 <code>__enter__</code> 方法返回值的 <code>__exit__</code> 方法。这一点很好理解，因为前者一定实现了 <code>__enter__</code> 方法，但后者不一定。</p>
<p>了解了上下文的概念后，我们可以自定义一个上下文，其实也就是定义一个实现了 <code>__enter__</code> 和<code>__exit__</code> 方法的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class Reverse():</span><br><span class="line">    def reverse_write(self, content):</span><br><span class="line">        self.original_write(content[::-1])</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        self.original_write = sys.stdout.write</span><br><span class="line">        sys.stdout.write = self.reverse_write</span><br><span class="line">        return &apos;Enter context&apos;[::-1]  # 这个字符串会被倒序打印，所以先倒序一次</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_value, traceback):</span><br><span class="line">        sys.stdout.write = self.original_write</span><br><span class="line">        print(exc_type, exc_value, traceback)</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">with Reverse() as r:</span><br><span class="line">    print(r)  # 因为字符串已经被倒序过，所以这里输出 &apos;Enter context&apos;</span><br><span class="line">    print(&apos;betterswifter&apos;) # 输出 &apos;retfiwstseb&apos;</span><br><span class="line">    raise AttributeError # 输出 &lt;class &apos;AttributeError&apos;&gt;  &lt;traceback object at 0x10bcb45c8&gt;</span><br><span class="line">    print(&apos;will not be print&apos;)  # 因为发生了异常，所以不会执行这一行</span><br></pre></td></tr></table></figure>
<p>在进入上下文的时候，我们用自定义的方法替换了系统的标准输出，所以上下文中所有的输出都是倒序的。直到上下文结束时才换回来。</p>
<p><code>__exit__</code> 方法有三个参数，分别表示异常的类型，异常的实例，以及发生异常处的调用栈。如果在 <code>with</code> 块中发生了异常，异常处后面的代码都不会执行。<code>__exit__</code> 方法如果返回 <code>True</code>，表示异常已经被正确处理，否则异常会向上冒泡到 <code>with</code> 代码块外面。</p>
<h5 id="标准库中的上下文"><a href="#标准库中的上下文" class="headerlink" title="标准库中的上下文"></a>标准库中的上下文</h5><p>使用标准库中的装饰器可以节省一些模板代码，<code>__enter__</code> 和 <code>__exit__</code> 方法可以写在一起，以 <code>yield</code> 为分界线：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@contextlib.contextmanager</span><br><span class="line">def Reverse():</span><br><span class="line">    def reverse_write(content):</span><br><span class="line">        original_write(content[::-1])</span><br><span class="line"></span><br><span class="line">    original_write = sys.stdout.write</span><br><span class="line">    sys.stdout.write = reverse_write</span><br><span class="line">    yield &apos;Enter context&apos;[::-1] # 下一行开始，是 __exit__ 的逻辑</span><br><span class="line">    sys.stdout.write = original_write</span><br></pre></td></tr></table></figure>
<p><code>@contextlib.contextmanager</code> 的缺点是无法通过 <code>return True/False</code> 来控制是否需要冒泡异常，必须把 <code>yield</code> 代码放到 <code>try catch</code> 中。</p>
<h3 id="其他-Python-特色"><a href="#其他-Python-特色" class="headerlink" title="其他 Python 特色"></a>其他 Python 特色</h3><h4 id="多线程与GIL"><a href="#多线程与GIL" class="headerlink" title="多线程与GIL"></a>多线程与GIL</h4><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><p>多线程操作一般通过 <code>threading</code> 模块来完成，启动一个线程其实就是把线程要执行的函数传递到 <code>Thread</code> 类的初始化方法中，然后调用 <code>Thread</code> 实例的 <code>start</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">def think():</span><br><span class="line">    print(&apos;start thinking in thread: &apos; + threading.current_thread().name)</span><br><span class="line">    sleep(1)</span><br><span class="line">    print(&apos;end thinking&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(3):</span><br><span class="line">    t = threading.Thread(target = think)</span><br><span class="line">    t.start()</span><br><span class="line">print(&apos;Exit&apos;)</span><br><span class="line"># start thinking in thread: Thread-1</span><br><span class="line"># start thinking in thread: Thread-2</span><br><span class="line"># start thinking in thread: Thread-3</span><br><span class="line"># Exit</span><br><span class="line"># end thinking</span><br><span class="line"># end thinking</span><br><span class="line"># end thinking</span><br></pre></td></tr></table></figure>
<p>从输出结果来看，<code>Python</code> 的线程都是异步执行，如果要同步执行某个线程，需要调用线程的 <code>join</code> 方法，表示阻塞当前线程，直到整个线程退出为止：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for i in range(3):</span><br><span class="line">    t = threading.Thread(target = think)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">print(&apos;Exit&apos;)</span><br><span class="line"># start thinking in thread: Thread-1</span><br><span class="line"># end thinking</span><br><span class="line"># start thinking in thread: Thread-2</span><br><span class="line"># end thinking</span><br><span class="line"># start thinking in thread: Thread-3</span><br><span class="line"># end thinking</span><br><span class="line"># Exit</span><br></pre></td></tr></table></figure>
<h5 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h5><p>像 <code>a += 1</code> 这样的语句，是线程不安全的，因为它不是原子性操作。如果想保证某段代码最多同时被一个线程执行，可以给它加锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def think():</span><br><span class="line">    global i</span><br><span class="line">    lock.acquire()</span><br><span class="line">    i += 1</span><br><span class="line">    lock.release()</span><br></pre></td></tr></table></figure>
<p>注意到这里的加锁和释放锁又是上下对应的模板代码，这类代码都可以用 with 块配合上下文解决。Python 提供了现成的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">def think():</span><br><span class="line">    global i</span><br><span class="line">    with lock:</span><br><span class="line">        i += 1</span><br></pre></td></tr></table></figure>
<p>在 threading.Lock 类的 <code>__exit__</code>方法中会自动释放锁.</p>
<h5 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h5><p>我们知道 Python 这种动态语言是由解释器在运行时动态解释并执行的，如果有多个线程同时执行，就意味着有多个解释器也在运行。为了保证解释器自己的线程安全性，有些 Python 解释器（比如最常见的 CPython）采用了一种很暴力的解决方式：<strong>全局锁</strong>，也就是 Global Interpreter Lock， GIL。再次声明，GIL 不是 Python 的特性，仅仅是特定解释器的特性，比如另一个解释器 JPython 就没有 GIL，不过 CPython 是绝大多数场景下默认的 Python 的解释器，所以有人可能会把 GIL 与 Python 混为一谈。</p>
<p>GIL 最直接的副作用就是严重影响多线程的性能，因为同一时刻只有一个线程能获得锁。GIL 可以用如下伪代码表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    acquire GIL</span><br><span class="line">    for i in range(1000):</span><br><span class="line">        do_something()</span><br><span class="line">    release GIL</span><br></pre></td></tr></table></figure>
<p>当某个线程因为睡眠、IO 或超时释放 GIL 后，从代码中可以看到，它距离再次获得 GIL 仅有一条指令。所以在实际运行时，有很大可能是一个线程不断的释放、获取 GIL，而别的线程一直在等待。由于线程上下文切换存在一定的开销，多个 CPU 密集型的线程同时运行，性能反而比在同一个线程内运行要低。</p>
<p>如果是多个 IO 密集型的线程同时运行，GIL 不会影响性能，因为线程在执行 IO 操作时会主动释放 GIL 锁，因此会出现没有线程获取 GIL 锁（因为大家都在 IO），谁结束了 IO 谁就使用线程的情况。不过需要注意的是，多个 IO 密集型的线程和一个 CPU 密集型线程同时执行时，性能也会受到影响。因为之前解释过，CPU 密集型的线程倾向于一直占有 GIL，导致 IO 密集型线程在 IO 结束后无法立刻获取 GIL，空等一段时间。</p>
<p>具体的测试结果可以参考：<a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank" rel="noopener">Python的GIL是什么鬼，多线程性能究竟如何。</a></p>
<p>如果想要避免 GIL 对性能的影响，有以下几种思路:</p>
<ol>
<li>多个 IO 密集型线程不受影响，但不要混入 CPU 密集型线程</li>
<li>使用 JPython 这样的解释器代替 CPython，但这样做就无法再使用社区已有的 C 语言模块</li>
<li>使用多进程，多个进程有多个 GIL，自然就互不干扰</li>
</ol>
<h5 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h5><p>Python 中实现多进程非常简单，因为接口与多线程基本一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def run_proc(i):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">for i in range(5):</span><br><span class="line">    p = multiprocessing.Process(target=run_proc, args=(i,))</span><br><span class="line">    p.start()</span><br><span class="line">print(&apos;End&apos;)</span><br></pre></td></tr></table></figure>
<p>多进程中没有锁的概念，因为不同的线程可以共享进程的堆，而不同的进程就没有应用层面可以共享的内容了，只能依赖于操作系统提供的 API，比如共享内存、socket、管道、消息队列等。</p>
<p>以消息队列为例，简单展示下进程间共享数据:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process, Queue</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line"></span><br><span class="line">def run_proc(q):</span><br><span class="line">    for t in range(10):</span><br><span class="line">        i = q.get()</span><br><span class="line">        i += 1</span><br><span class="line">        q.put(i)</span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line">q = Queue()</span><br><span class="line">q.put(0)</span><br><span class="line"></span><br><span class="line">p1 = Process(target=run_proc, args=(q,))</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p2 = Process(target=run_proc, args=(q,))</span><br><span class="line">p2.start()</span><br></pre></td></tr></table></figure>
<p>每个进程都会从消息队列中读取变量，加一后放回队列，所以输出结果是 1 到 20。如果不用消息队列来共享，每个进程的变量 <code>i</code> 都是独立的，会输出两次 1 到 10。</p>
<h4 id="我眼中的-Python"><a href="#我眼中的-Python" class="headerlink" title="我眼中的 Python"></a>我眼中的 Python</h4><h5 id="Python-是动态强类型语言"><a href="#Python-是动态强类型语言" class="headerlink" title="Python 是动态强类型语言"></a>Python 是动态强类型语言</h5><p>这句话其实说了两个概念： <code>Python 是动态类型语言</code>，以及 <code>Python 是强类型语言</code>，很多人会把这两组概念混淆。</p>
<p>首先，动/静态类型语言的区别在于类型被确认的时机。以 C 这类语言来说，编译器会检查变量的类型，比如 <code>int a = &quot;hello&quot;;</code> 就无法通过编译，这就说明 C 语言是静态类型语言。而对于 Python 来说，<code>a = &quot;hello&quot;</code> 直到运行时，才会确定 a 引用的对象的类型是 str。</p>
<p>动态类型语言并非看上去没有类型标记那么简单，一方面，Swift 这样的语言支持类型推导，所以支持 <code>var s = &quot;hello&quot;</code> 这种写法，但这并不意味着 Swift 就是动态类型语言了，因为它的类型判断还是在编译期完成的，只不过编译器更加智能，可以推导出来而已。</p>
<p>另一方面，不在编译期检查类型并不意味着动态类型语言对类型的校验就是宽松的，这是另一个维度的衡量指标。如果语言对类型的校验很宽松，支持隐式转换，我们就称这种语言是 <code>“弱类型语言”</code>，否则就是<code>强类型语言</code>。强类型语言更严格，一定程度上语法会更啰嗦，弱类型语言代码更简单，更脚本化。以输出 <code>&quot;My age is 22&quot;</code> 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = 22</span><br><span class="line">string = &apos;My age is &apos;</span><br><span class="line">print(string + str(number))</span><br></pre></td></tr></table></figure>
<p>这里必须把数字先转为字符串，才能和别的字符串拼接，这是因为 <code>str</code> 类的 <code>__add__</code> 函数只支持 str 类型的参数。可以看到，虽然数字（或者其他实现了 <code>__str__</code> 方法的自定义类）可以转为字符串，但这种转换必须是显式写明的，Python 并不支持隐式转换。</p>
<p>但用别的语言，比如 JavaScript 来实现类似的逻辑就非常简单了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = 22</span><br><span class="line">string = &apos;My age is &apos;</span><br><span class="line">console.log(string + number);</span><br></pre></td></tr></table></figure>
<p>可见，JavaScript 支持从数字到字符串的隐式转换。但这种隐式的转换也不一定是好事，比如再举一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = 22</span><br><span class="line">string = &apos;2&apos;</span><br><span class="line">console.log(string + number)</span><br></pre></td></tr></table></figure>
<p>它的输出结果是 ‘222’，可见是把数字隐式的转成了字符串，然而如果我的本意是要把字符串转数字呢，比如这段代码在 PHP 中的输出就是 24：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $n = 22;</span><br><span class="line">    $s = &quot;2&quot;;</span><br><span class="line">    print $s + $n</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>因此，关于语言的强/弱类型，我想可以总结两点：</p>
<ol>
<li>类型的强弱是一个相对的概念，不像动态/静态类型那样有明确的判断标准。因为隐式转换可以发生在很多地方，有的语言支持的隐式转换场景很多，有的支持的场景很少，所以一般来说我们只能说某个语言的类型比较强（弱）或者说某个语言的类型比另一个语言更强（弱）。</li>
<li>强弱类型没有优劣之分，强类型语言更严谨，不容易出现 Bug，但是代码复杂，书写成本高。弱类型语言更脚本化，写起来很简单，但很多规则并不那么显然，增加了学习成本.</li>
</ol>
<h5 id="开发效率高"><a href="#开发效率高" class="headerlink" title="开发效率高"></a>开发效率高</h5><p>Python 中到处都是<code>鸭子类型</code>的实践：不关注一个类的类型本身，而是关注这个类具有什么能力。比如我们会发现，数组和字符串的下标访问高度类似，这在很多静态类型语言中是几乎不可能发生的。很多自定义类因为使用了多继承、迭代器、双下方法，使用起来与内置的数据类型基本上没有区别。</p>
<p>此外，脚本语言的一个主要特色就是 handy，理论上来说 Python 能做的事，没什么是 C 做不到的。然而我们希望用简单的 API，用文本编辑器花上一两分钟就写出来一个脚本，而不是查阅手册，打开 IDE，编译以后再执行。所以 Python 提供了很多语言层面的支持，比如推导、else 块、切片和功能强大的内置函数等。</p>
<p>另外，Python 具备强大的元编程能力，装饰器、高阶函数、函数内省、元类具有非常强的内省和动态能力。内省帮助我们在运行时获取足够多的信息，动态性帮助我们实现很多很有意思的能力。因此我们看到 Python 中很少有模板代码，虽然内部实现有时候相对晦涩难懂，但对外的接口则是高度统一。</p>
<h5 id="对新人不是很友好"><a href="#对新人不是很友好" class="headerlink" title="对新人不是很友好"></a>对新人不是很友好</h5><p>开发效率高的背后也有隐患，简洁高效的语法可能意味着过度封装，因此 Python 的性能经常遭到抨击（但是脚本语言并不应该考虑这一点）。</p>
<p>鸭子类型容易带来太多的魔术方法。在 Java 中，一切都有迹可循，某个类能调用方法，一定是因为它自己实现了方法，或者从接口、父类那里继承来了。而 Python 不一样，方法的调用和方法的真正实现之间也许没有语言层面的直接关联，而是依靠文档规范、魔术方法或者约定。这给新手阅读 Python 代码带来了极大的困难，通常无从下手，连搜索什么关键字都不知道，这也是本文写作的目的之一。</p>
<p>元编程能力允许用户直接享受到大牛们封装好的库和能力，但也容易被滥用。元编程学习门槛高，而且通常实现一个需求有不止一种方法。如果大家各自造轮子，很可能质量参差不齐，互相理解起来也比较困难.</p>
<h4 id="其它-Python-技巧"><a href="#其它-Python-技巧" class="headerlink" title="其它 Python 技巧"></a>其它 Python 技巧</h4><p>很多时候我们从网上摘抄下来的代码仅仅刚好能工作，但对它的细节却不是很了解。本节主要列出一些常用的 Python 代码或者技巧并用实际的例子解释各处细节，持续更新中。</p>
<h5 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h5><p>读取文件时，一般会这样写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;path_to_file&apos;, &apos;r&apos;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line)</span><br><span class="line"># first line</span><br><span class="line"></span><br><span class="line"># second line</span><br><span class="line"></span><br><span class="line"># third line</span><br></pre></td></tr></table></figure>
<p><code>open</code> 函数的第二个参数表示打开模式，<code>r</code> 表示读取，<code>w</code> 表示写入，会删除原来的所有内容，<code>a</code> 表示在文件后面追加写入。</p>
<p>一般来说不要用 readlines 读取文件，因为如果文件特别大， 读出来的数组可能会非常占用内存。我们会看到输出结果一般都有多个空行，这是因为每行的结尾都有 ‘\n’ 换行符，而且 <code>print</code> 函数自己就会换行。如果想要更美观的输出，可以用 <code>replace</code> 或者 <code>rstrip</code> 函数干掉换行符。</p>
<p>如果我们用 <code>open(&#39;path_to_file&#39;. &#39;rb&#39;)</code> 来打开文件，就可以读取到原来的二进制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;file_to_path&apos;, &apos;rb&apos;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line)</span><br><span class="line"># b&apos;first line\n&apos;</span><br><span class="line"># b&apos;second line\n&apos;</span><br><span class="line"># b&apos;third line\n&apos;</span><br></pre></td></tr></table></figure>
<p>这里我们本来应该看到的是各个字母的 UTF-8 编码后的二进制，不过在打印的时候被系统自动转成字母了。在文件不是UTF-8 编码时，一定要用二进制格式去打开文件并且自行解码，否则 Python 会尝试用 UTF-8 去解码，极有可能会因为无法解码而导致报错。</p>
<p>我们可以试着把二进制写入到文件中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;hello world&apos;</span><br><span class="line">b = [x.encode(&apos;utf16&apos;) for x in s]</span><br><span class="line"></span><br><span class="line">with open(&apos;path_to_file&apos;, &apos;wb&apos;) as f:</span><br><span class="line">    f.writelines(b)</span><br></pre></td></tr></table></figure>
<p><code>writelines</code> 函数的参数是数组，相当于对数组中的每个元素调用了 <code>write()</code> 方法。</p>
<p>感兴趣的读者可以试着分别用 <code>r</code> 和 <code>rb</code> 去打开文件，感受其中的区别。</p>
<h5 id="JSON-读写"><a href="#JSON-读写" class="headerlink" title="JSON 读写"></a>JSON 读写</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">d = &#123;&apos;name&apos;: &apos;betterswifter&apos;, &apos;age&apos;: 22&#125;</span><br><span class="line">json.dumps(d)  # 返回字符串：&#123;&quot;name&quot;: &quot;betterswifter&quot;, &quot;age&quot;: 22&#125;</span><br></pre></td></tr></table></figure>
<p>最简单的对象转 JSON 通过 <code>json</code> 模块的 <code>dumps</code> 函数来完成，最后一个字母 s 表示生成字符串，也可以用 <code>dump(data, fp)</code> 来把内容写入文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">d = &#123;&apos;name&apos;: &apos;betterswifter&apos;, &apos;age&apos;: 22&#125;</span><br><span class="line">with opne(&apos;path_to_file&apos;, &apos;w&apos;) as f:</span><br><span class="line">    json.dump(d, f)</span><br></pre></td></tr></table></figure>
<p>调用 <code>dumps</code> 参数时，有几个命令可能会派上作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">d = &#123;&apos;name&apos;: &apos;betterswifter&apos;, &apos;age&apos;: 22&#125;</span><br><span class="line">json.dumps(d, skipkeys=True, sort_keys=True, indent=4)</span><br><span class="line"></span><br><span class="line">#&#123;</span><br><span class="line">#    &quot;age&quot;: 22,</span><br><span class="line">#    &quot;name&quot;: &quot;betterswifter&quot;</span><br><span class="line">#&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>sort_keys</code> 表示对字典的键排序，这样输出结果一定是固定的，indent 用于控制多少个空格缩进，可以增加可读性。skipkeys 表示如果字典的键不是字符串，就忽略这一条记录。</p>
<p><code>JSON</code> 支持的类型很有限，只有 <code>None</code> ， <code>bool</code> ， <code>int</code> ， <code>float</code> 和 <code>str</code> 这五种基本类型和包含这些类型的字典或者数组。自定义的对象如果转成 <code>JSON</code> 默认会报错，我们可以实现一个通用函数，读取任意对象的 <code>__dict__</code>，这样就可以用于 <code>JSON</code> 化了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">def serialize_instance(obj):</span><br><span class="line">    d = &#123; &apos;class&apos; : type(obj).__name__ &#125;</span><br><span class="line">    d.update(vars(obj))</span><br><span class="line">    return d</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">bs = Person(&apos;betterswifter&apos;, 22)</span><br><span class="line"></span><br><span class="line"># 直接 dumps(bs) 会得到这个报错：</span><br><span class="line"># TypeError: Object of type &apos;Person&apos; is not JSON serializable</span><br><span class="line"></span><br><span class="line">json.dumps(serialize_instance(bs), skipkeys=True, sort_keys=True, indent=4)</span><br><span class="line"></span><br><span class="line">#&#123;</span><br><span class="line">#    &quot;age&quot;: 22,</span><br><span class="line">#    &quot;class&quot;: &quot;Person&quot;,</span><br><span class="line">#    &quot;name&quot;: &quot;betterswifter&quot;</span><br><span class="line">#&#125;</span><br></pre></td></tr></table></figure>
<p>或者更优雅的做法是使用 3.3.3 节中介绍的 Mixin：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line"># 注意 Mixin 的原则，功能要单一，实现上不能依赖子类</span><br><span class="line">class Serializable:</span><br><span class="line">    def serialize(self):</span><br><span class="line">        d = &#123; &apos;class&apos; : type(self).__name__ &#125;</span><br><span class="line">        d.update(vars(self))</span><br><span class="line">        return d</span><br><span class="line"></span><br><span class="line"># 混入 Serializable 立刻就有了转字典的能力，或者也可以重写</span><br><span class="line">class Person(Serializable):</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">bs = Person(&apos;betterswifter&apos;, 22)</span><br><span class="line"></span><br><span class="line">json.dumps(bs.serialize())</span><br></pre></td></tr></table></figure>
<p>解析 JSON 字符串的方法也是类似的，调用 <code>json.loads()</code> 函数即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">s = &apos;&#123;&quot;name&quot;: &quot;betterswifter&quot;, &quot;age&quot;: 22&#125;&apos;</span><br><span class="line">d = json.loads(s)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>
<p>这里的 <code>loads</code> 表示从字符串中读取 <code>JSON</code>，也可以用 <code>load</code> 函数从文件中读取。不过有时候我们更希望把读取出来的字典直接转成对象。这需要调用者提供一个函数，把字典转换成对象，一般需要用到元编程。下面是一个简单的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">class Deserializable:</span><br><span class="line">    @classmethod</span><br><span class="line">    def deserialize(cls, d):</span><br><span class="line">        clsname = d.pop(&apos;classname&apos;, None)</span><br><span class="line">        if clsname:</span><br><span class="line">            obj = cls.__new__(cls)</span><br><span class="line">            for key, value in d.items():</span><br><span class="line">                setattr(obj, key, value)</span><br><span class="line">            return obj</span><br><span class="line">        else:</span><br><span class="line">            return d</span><br><span class="line"></span><br><span class="line">class Person(Deserializable):</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">s = &apos;&#123;&quot;age&quot;: 22, &quot;name&quot;: &quot;betterswifter&quot;&#125;&apos;</span><br><span class="line">bs = json.loads(s, object_hook = Person.deserialize)</span><br><span class="line">print(bs)</span><br></pre></td></tr></table></figure>
<p><code>Person</code> 类通过混入 <code>Deserializable</code> 具备了反序列化的能力，只要把这个函数传入 <code>loads</code> 方法中即可，<code>deserialize</code> 函数的第一个参数是调用类，第二个参数是解析出来的字典。这段代码其实等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = json.loads(s)</span><br><span class="line">bs = Person.deserialize(d)</span><br></pre></td></tr></table></figure>
<h5 id="执行-Shell"><a href="#执行-Shell" class="headerlink" title="执行 Shell"></a>执行 Shell</h5><p>Python 中调用 <code>Shell</code> 命令的方法有很多种，我最常用的是 <code>os.popen</code>函数，它的返回结果是文件句柄，因此可以调用 <code>readlines</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">r = os.popen(&apos;pwd&apos;)</span><br><span class="line">print(r.readlines())</span><br><span class="line"># 输出 [&apos;/Users/zxy/Desktop\n&apos;]</span><br></pre></td></tr></table></figure>
<p>这个结果表示 Shell 命令的输出只有一行，且内容是 <code>/Users/zxy/Desktop。</code></p>
<h4 id="Python-模块化"><a href="#Python-模块化" class="headerlink" title="Python 模块化"></a>Python 模块化</h4><h5 id="Python-中的模块"><a href="#Python-中的模块" class="headerlink" title="Python 中的模块"></a>Python 中的模块</h5><p>Python 不仅可以用来编写短小精悍的脚本文件，也能用来开发大型项目，这就需要把代码合理的写在各个模块中，确保<code>高内聚、低耦合</code>。</p>
<p>每一个 Python 文件都是一个模块，我们知道 <code>import</code> 关键字可以导入系统模块，也可以用 <code>import module_name</code> 的写法导入别的模块。</p>
<p>假设文件路径如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package</span><br><span class="line">|-- main.py</span><br><span class="line">|-- module.py</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># In module.py</span><br><span class="line">def add(a, b):</span><br><span class="line">    return a + b</span><br><span class="line"></span><br><span class="line"># In main.py</span><br><span class="line">import module</span><br><span class="line">modul1.add(1, 2) # 返回 3</span><br></pre></td></tr></table></figure>
<h5 id="模块查找顺序"><a href="#模块查找顺序" class="headerlink" title="模块查找顺序"></a>模块查找顺序</h5><p>对于被 <code>import</code> 的模块，Python 首先会检查它是不是内置的模块，比如我们把刚刚的 <code>module.py</code> 文件重命名为 <code>time.py</code>，再引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">time.add(1, 2)</span><br><span class="line"># 报错：AttributeError: module &apos;time&apos; has no attribute &apos;add&apos;</span><br></pre></td></tr></table></figure>
<p>这是因为 Python 最先查找内置的模块，我们打印 time 模块就可以看到 <code>&lt;module &#39;time&#39; (built-in)&gt;</code>，说明这是一个内置模块。<code>PS：string</code> 模块不是内置模块，坑了我一晚上。</p>
<p>如果导入的不是内置模块，Python 会依次在 <code>sys.path</code> 这个数组中的每个路径中寻找。按照查找优先级，它由三个部分组成：</p>
<ol>
<li>Python 执行的入口文件（比如这里的 main.py）所在的路径</li>
<li>系统的环境变量 $PYTHONPATH 所表示的目录</li>
<li>site 路径，也就是 /usr/local/lib/python3.5/site-packages 这种</li>
</ol>
<p>如果我们把 <code>time.py</code> 改名为 <code>string.py</code> 就会得到正常结果，这是因为它属于第一部分，而 <code>Python</code> 默认的 <code>string</code> 模块位于第三部分，优先级比较低.</p>
<p>一般来说，<code>Python</code> 工程中的文件都能在第一部分被找到，而 <code>pip</code> 安装的第三方库位于第三部分。环境变量 <code>PYTHONPATH</code> 一般都是空，但不排除某些 <code>IDE</code>，比如 <code>PyCharm</code> 会修改它。这种行为很危险，因为能在 <code>PyCharm</code> 中编译通过很可能是借助环境变量才找到了模块，一旦迁移到别的环境就无法编译，我似乎遇到过这个坑，将本地可以运行的代码上传到 <code>VPS</code> 以后就找不到模块了</p>
<h5 id="包与-init-py"><a href="#包与-init-py" class="headerlink" title="包与 __init__.py"></a>包与 <code>__init__.py</code></h5><p>当代码量进一步膨胀时，可能多个模块也无法合理的拆分逻辑了，我们可以把实现某个特定功能的若干个模块组合起来，形成一个包。包在逻辑上可以理解为若干个模块的组合， 在物理上讲，包都是文件夹，模块都是文件。</p>
<p>注意，<strong>文件夹不都是包，只有存在 <code>__init__.py</code> 文件的文件夹才是模块！</strong></p>
<p>在导入时，我们可以导入类，也可以导入类里面的全局变量或者全局函数，还可以导入包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import package</span><br><span class="line">import module</span><br></pre></td></tr></table></figure>
<p>如果类名和变量名太长，可以用 as 关键字重命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import module.var as v</span><br><span class="line">import module.func as f</span><br></pre></td></tr></table></figure>
<p>一般来说导入包并没有太大的作用，后续还是需要导入包中的模块。如果确实需要直接用到包中的函数或者变量，可以把它定义在 <code>__init__.py</code> 文件中。</p>
<p><code>__init__.py</code> 用于把一个目录标记为包，如果没有这个文件，目录又和 Python 模块重名，就会调用到 <code>Python</code> 的模块，假设文件层级如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">|-- main.py</span><br><span class="line">|-- string</span><br><span class="line">  |-- module1.py</span><br></pre></td></tr></table></figure>
<p>我们尝试在 <code>main.py</code> 中导入包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import string</span><br><span class="line">print(string)</span><br><span class="line"># &lt;module &apos;string&apos; from &apos;/usr/local/Cellar/python3/3.5.2_3/Frameworks/Python.framework/Versions/3.5/lib/python3.5/string.py&apos;&gt;</span><br></pre></td></tr></table></figure>
<p>会发现导入的其实是模块。虽然这里 <code>string</code> 目录如果是一个文件，它的查找优先级会高于 Python 中的非内置模块，但如果当做包来导入，Python 就无法识别了。解决方案也很简单，给 string 目录添加一个 <code>__init__.py</code> 文件，把 <code>string</code>目录标记为包即可。</p>
<p>除了标记目录为包以外，<code>__init__.py</code> 文件还可以定义一个<code>__all__</code>变量，用于批量导入，假设目录层级如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">|-- main.py</span><br><span class="line">|-- string</span><br><span class="line">  |-- module1.py</span><br><span class="line">  |-- module2.py</span><br><span class="line">  |-- module3.py</span><br></pre></td></tr></table></figure>
<p>先在 <code>__init__</code> 文件中定义要批量导入的模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># In __init__.py</span><br><span class="line">__all__ = [&apos;module1&apos;, &apos;module2&apos;]</span><br></pre></td></tr></table></figure>
<p>然后在 main.py 文件中用星号 * 批量导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from string import *</span><br><span class="line">print(module1) # &lt;module &apos;string.module1&apos; from &apos;/Users/zxy/Desktop/string/module1.py&apos;&gt;</span><br><span class="line">print(module2) # &lt;module &apos;string.module1&apos; from &apos;/Users/zxy/Desktop/string/module1.py&apos;&gt;</span><br><span class="line">print(module3) # NameError: name &apos;module3&apos; is not defined</span><br></pre></td></tr></table></figure>
<p>在打印 <code>module3</code> 的时候会报错，这是因为<code>__all__</code> 变量没有暴露它，需要我们手动导入。</p>
<h5 id="相对导入和绝对导入"><a href="#相对导入和绝对导入" class="headerlink" title="相对导入和绝对导入"></a>相对导入和绝对导入</h5><p>接上面的例子，假设我们在 <code>module2</code> 中要引用 <code>module1</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import string.module1</span><br></pre></td></tr></table></figure>
<p>这样写没有问题，因为有 <code>__init__.py</code> 文件把目录标记为包，所以可以正确识别。然而如果我们的入口不是 <code>main.py</code>，而是直接执行 <code>python3 module2.py</code>，就无法识别到父目录里面的 <code>__init__.py</code> 文件了。此时可以采用相对导入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import module1</span><br></pre></td></tr></table></figure>
<p>一个点表示当前的包，两个点就表示上一个包，以此类推……；相对导入只能使用 <code>from import</code> 的语法，而绝对路径导入则不受限制，两种写法皆可。</p>
<p>相对路径的缺点在于容易丢失命名空间，比较这两种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from foo import bar</span><br><span class="line">bar()     # bar 在哪里定义？</span><br><span class="line">import foo.bar</span><br><span class="line">foo.bar() # 在 foo 模块中定义</span><br></pre></td></tr></table></figure>
<p>前者丢失了 bar 的来源，而后一种写法不会.</p>
<h5 id="运行-Python-脚本"><a href="#运行-Python-脚本" class="headerlink" title="运行 Python 脚本"></a>运行 Python 脚本</h5><p>每个 Python 脚本既可以直接用 <code>python xxx.py</code> 命令执行，也可以被别的 Python 文件当做模块引入。对于一个项目来说，入口文件只有一个（就像 C 语言的 <code>main.c</code> 文件一样），其他的文件都作为模块对外提供功能。</p>
<p>我们也可以用 python 命令执行一个文件夹，此时会自动运行文件夹中的 <code>__main__.py</code> 文件。</p>
<p>假设我们写了一个函数，可以爬取给定 URL 的标题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def getTitle(url):</span><br><span class="line">    # ...</span><br><span class="line">    # return html.title</span><br><span class="line"></span><br><span class="line">getTitle(&apos;https://baidu.com&apos;)</span><br></pre></td></tr></table></figure>
<p>直接执行或者在别的模块中导入这个文件都会调用 <code>getTitle</code> 函数，然而我们希望的效果是只有直接执行这个文件时才执行函数，被导入时只要提供方法即可。或者可以通过判断全局变量 <code>__name__</code> 来完成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def getTitle(url):</span><br><span class="line">    # ...</span><br><span class="line">    # return html.title</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(getTitle(&apos;https://baidu.com&apos;))</span><br></pre></td></tr></table></figure>
<p>只有当直接运行文件时，全局变量<code>__name__</code> 的值才是 <code>__main__</code>，因此当这个模块被导入时，if 语句中的代码就不会被调用。</p>
<p><code>python</code> 作为一个 <code>Shell</code> 命令，可以和其他系统命令通过管道联系在一起，比如实现一个 <code>show_file.py</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">for file in sys.stdin:</span><br><span class="line">    print(file)</span><br></pre></td></tr></table></figure>
<p>然后执行命令行脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | python3 show_file.py</span><br></pre></td></tr></table></figure>
<p>将会打印出当前目录中所有文件的名字。每个 Shell 脚本都有返回值， 用于表示脚本是否成功，通过命令 <code>echo $?</code> 可以查看上一条命令的返回结果，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./create_file.sh</span><br><span class="line">if [ $? = 0 ] ; then  # 只有成功创建文件，才会写入内容</span><br><span class="line">    ./write_to_file.sh</span><br><span class="line">else</span><br><span class="line">    echo &quot;error&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>由于脚本命令的返回值具有重要的参考价值，因此我们的 Python 脚本也要遵循这一规范，这样别的命令可以很容易的知道 Python 脚本的执行情况。因此，标准的入口文件总是应该套用这个模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 执行某些逻辑</span><br><span class="line">    # 如果发生错误</span><br><span class="line">    # sys.exit(1)</span><br><span class="line">    return 0</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure>
<h4 id="venv"><a href="#venv" class="headerlink" title="venv"></a>venv</h4><h5 id="什么是-venv"><a href="#什么是-venv" class="headerlink" title="什么是 venv"></a>什么是 venv</h5><p>假设我们开发程序 A 是用到了 <code>pip install module1==1.0</code>，也就是安装了 module1 这个第三方库的 1.0 版本，同时开发程序 B 用到了这个第三方库的 2.0 版本，但是在 <code>/usr/local/lib/python3.5/site-packages</code> 这个目录下只能留一份，那么 A 和 B 就无法分别使用两个版本的第三方库了。</p>
<p>于是诞生了虚拟环境（virtualenv，简称 venv）的概念，它会为每个应用单独提供一份 Python 的运行环境，从而起到隔离的效果。</p>
<p>执行以下命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenv</span><br><span class="line">virtualenv test</span><br></pre></td></tr></table></figure>
<p>这首先会安装 <code>virtualenv</code> 这个工具模块，然后在当前目录下新建一个虚拟环境 test，其实也就是一个目录。</p>
<h5 id="venv-结构初探"><a href="#venv-结构初探" class="headerlink" title="venv 结构初探"></a>venv 结构初探</h5><p>观察目录的组成可以发现，主要是有三个文件夹：bin、include 和 lib。</p>
<p>bin 目录下主要是一些可执行文件，比如虚拟环境的激活与退出，以及 Python 和 pip 的可执行文件。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source bin/active</span><br><span class="line"># 现在开始，虚拟环境已经生效，安装的模块都在这个文件夹内部</span><br><span class="line">pip instal module1</span><br><span class="line">pip instal module2</span><br><span class="line"># ...</span><br><span class="line">deactive</span><br></pre></td></tr></table></figure>
<p><code>inlcude</code> 目录下的会通过软连接，导入一些 C 语言的头文件，暂时不清楚作用。</p>
<p>lib 目录下引用了 Python 自带的一些模块，以及第三方包 <code>site-packages</code> 文件夹的拷贝。如果执行的是 <code>virtualenv --no-site-packages test</code> 将会得到一个不含第三方包，纯净的虚拟环境。</p>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>其实 venv 的工作原理非常简单，完全集中在 bin/active 这个简单的脚本中，它的核心部分如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deactive () &#123;</span><br><span class="line">    # 恢复环境</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VIRTUAL_ENV=&quot;/Users/zxy/Desktop/testvenv&quot;</span><br><span class="line">export VIRTUAL_ENV</span><br><span class="line"></span><br><span class="line">_OLD_VIRTUAL_PATH=&quot;$PATH&quot;</span><br><span class="line">PATH=&quot;$VIRTUAL_ENV/bin:$PATH&quot;</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>
<p>可见它把当前目录标记为 <code>VIRTUAL_ENV</code>，然后添加到系统的 PATH 最前面，这样我们执行 pip 命令时，第三方的包就会被安装虚拟环境内的 <code>site-packages</code> 文件夹中，不会与系统的干扰。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="http://www.cnblogs.com/xybaby/p/6270551.html" target="_blank" rel="noopener">python属性查找 深入理解（attribute lookup）</a></li>
<li><a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">The Python 2.3 Method Resolution Order</a></li>
<li><a href="http://www.bjhee.com/python-mixin.html" target="_blank" rel="noopener">关于Python的Mixin模式</a></li>
<li><a href="https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods" target="_blank" rel="noopener">The definitive guide on how to use static, class or abstract meth</a></li>
<li><a href="异步与回调的设计哲学">异步与回调的设计哲学</a></li>
<li><a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank" rel="noopener">Python的GIL是什么鬼，多线程性能究竟如何</a></li>
<li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p02_read-write_json_data.html" target="_blank" rel="noopener">读写JSON数据</a></li>
<li><a href="https://loggerhead.me/posts/python-de-import-ji-zhi.html#_1" target="_blank" rel="noopener">Python 的 import 机制</a></li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Micah
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://lvchenqiang.github.io/2018/03/24/Python入门指南/" title="Python入门指南">https://lvchenqiang.github.io/2018/03/24/Python入门指南/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/lvchenqiang.github.io/tags/笔记/" rel="tag"># 笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/lvchenqiang.github.io/2018/02/06/Hexo-Git-pages-免费搭建个人博客详解/" rel="next" title="Hexo + Git pages 免费搭建个人博客详解">
                <i class="fa fa-chevron-left"></i> Hexo + Git pages 免费搭建个人博客详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/lvchenqiang.github.io/2018/04/22/setting-bundle/" rel="prev" title="Setting.bundle 的简单使用">
                Setting.bundle 的简单使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/lvchenqiang.github.io/image/avatar.png" alt="Micah">
            
              <p class="site-author-name" itemprop="name">Micah</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/lvchenqiang.github.io/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/lvchenqiang.github.io/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/lvchenqiang.github.io/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lvchenqiang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/lvchenqiang_" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-csdn"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#开篇"><span class="nav-number">1.</span> <span class="nav-text">开篇</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">3.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#列表推导"><span class="nav-number">3.1.1.</span> <span class="nav-text">列表推导</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#元组"><span class="nav-number">3.1.2.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组切片"><span class="nav-number">3.1.3.</span> <span class="nav-text">数组切片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#循环与遍历"><span class="nav-number">3.1.4.</span> <span class="nav-text">循环与遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#魔术方法"><span class="nav-number">3.1.5.</span> <span class="nav-text">魔术方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字典"><span class="nav-number">3.2.</span> <span class="nav-text">字典</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化字典"><span class="nav-number">3.2.1.</span> <span class="nav-text">初始化字典</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查询字典"><span class="nav-number">3.2.2.</span> <span class="nav-text">查询字典</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历字典"><span class="nav-number">3.2.3.</span> <span class="nav-text">遍历字典</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字典的魔术方法"><span class="nav-number">3.2.4.</span> <span class="nav-text">字典的魔术方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#集合"><span class="nav-number">3.2.5.</span> <span class="nav-text">集合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">3.3.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串编码"><span class="nav-number">3.3.1.</span> <span class="nav-text">字符串编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串的常用方法"><span class="nav-number">3.3.2.</span> <span class="nav-text">字符串的常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串格式化"><span class="nav-number">3.3.3.</span> <span class="nav-text">字符串格式化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HereDoc"><span class="nav-number">3.3.4.</span> <span class="nav-text">HereDoc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">4.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数是一等公民"><span class="nav-number">4.1.</span> <span class="nav-text">函数是一等公民</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数参数"><span class="nav-number">4.2.</span> <span class="nav-text">函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数传参"><span class="nav-number">4.2.1.</span> <span class="nav-text">函数传参</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默认参数"><span class="nav-number">4.2.2.</span> <span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多参数传递"><span class="nav-number">4.2.3.</span> <span class="nav-text">多参数传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#参数分类"><span class="nav-number">4.2.4.</span> <span class="nav-text">参数分类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数内省"><span class="nav-number">4.3.</span> <span class="nav-text">函数内省</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰器"><span class="nav-number">4.4.</span> <span class="nav-text">装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#设计模式的消亡"><span class="nav-number">4.4.1.</span> <span class="nav-text">设计模式的消亡</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#装饰器的基本原理"><span class="nav-number">4.4.2.</span> <span class="nav-text">装饰器的基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#装饰器进阶"><span class="nav-number">4.4.3.</span> <span class="nav-text">装饰器进阶</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#装饰器工厂"><span class="nav-number">4.4.4.</span> <span class="nav-text">装饰器工厂</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象"><span class="nav-number">5.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象内存管理"><span class="nav-number">5.1.</span> <span class="nav-text">对象内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象不是盒子"><span class="nav-number">5.1.1.</span> <span class="nav-text">对象不是盒子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默认浅复制"><span class="nav-number">5.1.2.</span> <span class="nav-text">默认浅复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#弱引用"><span class="nav-number">5.1.3.</span> <span class="nav-text">弱引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python-风格的对象"><span class="nav-number">5.2.</span> <span class="nav-text">Python 风格的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#静态函数与类方法"><span class="nav-number">5.2.1.</span> <span class="nav-text">静态函数与类方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#属性-attribute"><span class="nav-number">5.2.2.</span> <span class="nav-text">属性 attribute</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特性-property"><span class="nav-number">5.2.3.</span> <span class="nav-text">特性 property</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特性工厂"><span class="nav-number">5.2.4.</span> <span class="nav-text">特性工厂</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#实例属性的查找顺序"><span class="nav-number">5.2.5.</span> <span class="nav-text">实例属性的查找顺序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多继承"><span class="nav-number">5.3.</span> <span class="nav-text">多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#多继承的必要性"><span class="nav-number">5.3.1.</span> <span class="nav-text">多继承的必要性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Python-的多继承"><span class="nav-number">5.3.2.</span> <span class="nav-text">Python 的多继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Mixin"><span class="nav-number">5.3.3.</span> <span class="nav-text">Mixin</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#抽象类"><span class="nav-number">5.3.4.</span> <span class="nav-text">抽象类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#元编程"><span class="nav-number">5.4.</span> <span class="nav-text">元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类工厂函数"><span class="nav-number">5.4.1.</span> <span class="nav-text">类工厂函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#元类的概念"><span class="nav-number">5.4.2.</span> <span class="nav-text">元类的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#元类的使用示例"><span class="nav-number">5.4.3.</span> <span class="nav-text">元类的使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程控制"><span class="nav-number">6.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#else"><span class="nav-number">6.1.</span> <span class="nav-text">else</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#for-else"><span class="nav-number">6.1.1.</span> <span class="nav-text">for else</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#while-else"><span class="nav-number">6.1.2.</span> <span class="nav-text">while else</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#try-else"><span class="nav-number">6.1.3.</span> <span class="nav-text">try else</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代器"><span class="nav-number">6.2.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#迭代器-1"><span class="nav-number">6.2.1.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可迭代对象"><span class="nav-number">6.2.2.</span> <span class="nav-text">可迭代对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#iter-方法"><span class="nav-number">6.2.3.</span> <span class="nav-text">__iter__ 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标准迭代器"><span class="nav-number">6.2.4.</span> <span class="nav-text">标准迭代器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#初识生成器"><span class="nav-number">6.2.5.</span> <span class="nav-text">初识生成器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器"><span class="nav-number">6.3.</span> <span class="nav-text">生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#生成器的定义"><span class="nav-number">6.3.1.</span> <span class="nav-text">生成器的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#生成器表达式"><span class="nav-number">6.3.2.</span> <span class="nav-text">生成器表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#协程"><span class="nav-number">6.3.3.</span> <span class="nav-text">协程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#预激协程"><span class="nav-number">6.3.4.</span> <span class="nav-text">预激协程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标准库中的生成器函数"><span class="nav-number">6.3.5.</span> <span class="nav-text">标准库中的生成器函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#上下文管理器"><span class="nav-number">6.4.</span> <span class="nav-text">上下文管理器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#with-块"><span class="nav-number">6.4.1.</span> <span class="nav-text">with 块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义上下文"><span class="nav-number">6.4.2.</span> <span class="nav-text">自定义上下文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#标准库中的上下文"><span class="nav-number">6.4.3.</span> <span class="nav-text">标准库中的上下文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他-Python-特色"><span class="nav-number">7.</span> <span class="nav-text">其他 Python 特色</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程与GIL"><span class="nav-number">7.1.</span> <span class="nav-text">多线程与GIL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#多线程"><span class="nav-number">7.1.1.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程锁"><span class="nav-number">7.1.2.</span> <span class="nav-text">线程锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GIL"><span class="nav-number">7.1.3.</span> <span class="nav-text">GIL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多进程"><span class="nav-number">7.1.4.</span> <span class="nav-text">多进程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#我眼中的-Python"><span class="nav-number">7.2.</span> <span class="nav-text">我眼中的 Python</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Python-是动态强类型语言"><span class="nav-number">7.2.1.</span> <span class="nav-text">Python 是动态强类型语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#开发效率高"><span class="nav-number">7.2.2.</span> <span class="nav-text">开发效率高</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对新人不是很友好"><span class="nav-number">7.2.3.</span> <span class="nav-text">对新人不是很友好</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它-Python-技巧"><span class="nav-number">7.3.</span> <span class="nav-text">其它 Python 技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#文件读写"><span class="nav-number">7.3.1.</span> <span class="nav-text">文件读写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSON-读写"><span class="nav-number">7.3.2.</span> <span class="nav-text">JSON 读写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#执行-Shell"><span class="nav-number">7.3.3.</span> <span class="nav-text">执行 Shell</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Python-模块化"><span class="nav-number">7.4.</span> <span class="nav-text">Python 模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Python-中的模块"><span class="nav-number">7.4.1.</span> <span class="nav-text">Python 中的模块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#模块查找顺序"><span class="nav-number">7.4.2.</span> <span class="nav-text">模块查找顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#包与-init-py"><span class="nav-number">7.4.3.</span> <span class="nav-text">包与 __init__.py</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#相对导入和绝对导入"><span class="nav-number">7.4.4.</span> <span class="nav-text">相对导入和绝对导入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#运行-Python-脚本"><span class="nav-number">7.4.5.</span> <span class="nav-text">运行 Python 脚本</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#venv"><span class="nav-number">7.5.</span> <span class="nav-text">venv</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#什么是-venv"><span class="nav-number">7.5.1.</span> <span class="nav-text">什么是 venv</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#venv-结构初探"><span class="nav-number">7.5.2.</span> <span class="nav-text">venv 结构初探</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#工作原理"><span class="nav-number">7.5.3.</span> <span class="nav-text">工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">8.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Micah</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lvchenqiang.github.io/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/lvchenqiang.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/lvchenqiang.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Micah.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://lvchenqiang.github.io/2018/03/24/Python入门指南/';
          this.page.identifier = '2018/03/24/Python入门指南/';
          this.page.title = 'Python入门指南';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Micah.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  












  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'ob6xEevaCzifOdzvnfIrxSJ7-gzGzoHsz',
        appKey: 'ibWrHDRgAsLSxr5UnNH7Tb2n',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>

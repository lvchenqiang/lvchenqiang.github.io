<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="笔记," />










<meta name="description" content="开篇Python 是一门非常容易上手的语言，网上也有很多的资源和教程。">
<meta name="keywords" content="笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Python入门指南">
<meta property="og:url" content="https://lvchenqiang.github.io/2018/03/24/Python入门指南/index.html">
<meta property="og:site_name" content="大前端之路">
<meta property="og:description" content="开篇Python 是一门非常容易上手的语言，网上也有很多的资源和教程。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-24T15:28:33.933Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python入门指南">
<meta name="twitter:description" content="开篇Python 是一门非常容易上手的语言，网上也有很多的资源和教程。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lvchenqiang.github.io/2018/03/24/Python入门指南/"/>





  <title>Python入门指南 | 大前端之路</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  

  <div class="container  page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大前端之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lvchenqiang.github.io/2018/03/24/Python入门指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micah">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/image/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大前端之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Python入门指南</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T21:19:11+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/03/24/Python入门指南/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/03/24/Python入门指南/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>Python 是一门非常容易上手的语言，网上也有很多的资源和教程。</p>
<a id="more"></a>
<p>但是python也是一门很难精通的语言，本文主要是实现对 Python 的整体知识结构形成初步的概念、了解 Python 特有的知识点，比如装饰器、上下文、生成器等等，不仅会写 Demo，还对背后的原理有一定了解等</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>请不要在学习 Python2 还是 Python3 之间犹豫了，除非你很明确自己只接触 Python2，否则就从 Python3 学起。</p>
<p>调试工具可以选择 PyCharm 、Visual Studio Code 、CodeRunner。推荐使用后面两者,比PyCharm轻量级，功能也很方便开发。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h5><p>如果要对数组中的所有内容做一些修改，可以用 for 循环或者 map 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> array: </span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">        small.append(n * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(small)  <span class="comment"># [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<p>比较地道的 Python 写法是使用列表推导：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = [n * <span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> array <span class="keyword">if</span> n &lt; <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><code>for in</code> 可以写两次，类似于嵌套的 for 循环，会得到一个笛卡尔积:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signs = [<span class="string">'+'</span>, <span class="string">'-'</span>]</span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">ascii = [<span class="string">'&#123;sign&#125;&#123;number&#125;'</span>.format(sign=sign, number=number) </span><br><span class="line">        <span class="keyword">for</span> sign <span class="keyword">in</span> signs <span class="keyword">for</span> number <span class="keyword">in</span> numbers]</span><br><span class="line"><span class="comment"># 得到：['+1', '+2', '-1', '-2']</span></span><br></pre></td></tr></table></figure>
<h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><p>元组可以简单的理解为不可变的数组，也就是没有 append、del 等方法，一旦创建，就无法新增或删除元素，元素自身的值也不能改变，但元素内部的属性是否可变并不受元组的影响，这一点符合其他语言中的常识。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, [])</span><br><span class="line">t[<span class="number">0</span>] = <span class="number">3</span>  <span class="comment"># 抛出错误 TypeError: 'tuple' object does not support item assignment</span></span><br><span class="line">t[<span class="number">1</span>].append(<span class="number">2</span>)  <span class="comment"># 正常运行，现在的 t 是 (1, [2])</span></span><br></pre></td></tr></table></figure>
<p>除了不可变性以外，有时候元组也会被当做不具名的数据结构，这时候元素的位置就不再是可有可无的了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coordinate = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>)</span><br><span class="line"><span class="comment"># coordinate 的第一个位置用来表示经度，第二个位置表示纬度</span></span><br></pre></td></tr></table></figure>
<p>在解析元组数据时，可以一一对应的写上变量名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, b = t <span class="comment"># a = 1, b = 2</span></span><br></pre></td></tr></table></figure>
<p>有时候变量名比较长， 但我只关心其中某一个，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, _ = t <span class="comment"># a = 1</span></span><br></pre></td></tr></table></figure>
<p>如果元组中元素特别多，即使挨个写下划线也比较累，可以用 <code>*</code> 来批量解包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">first, *middle, last = t</span><br><span class="line"><span class="comment"># first = 1</span></span><br><span class="line"><span class="comment"># middle = [2, 3, 4]</span></span><br><span class="line"><span class="comment"># last = 5</span></span><br></pre></td></tr></table></figure>
<p>当然，如果元素数量较多，含义较复杂，我还是建议使用具名元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">People = collections.namedtuple(<span class="string">'People'</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>])</span><br><span class="line">p = People(<span class="string">'bestswifter'</span>, <span class="string">'22'</span>)</span><br><span class="line">p.name <span class="comment"># bestswifter</span></span><br></pre></td></tr></table></figure>
<p>具名元组更像是一个不能定义方法的简化版的类，能提供友好的数据展示。</p>
<p>元组的一个小技巧是可以避免用临时变量来交换两个数的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = 1 </span><br><span class="line">b = 2</span><br><span class="line">a, b = b, a</span><br><span class="line"># a = 2, b = 1</span><br></pre></td></tr></table></figure>
<h5 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h5><p>切片的基本格式是 <code>array[start🔚step]</code>，表示对 array 在 start 到 end 之前以 step 为间隔取切片。注意这里的区间是 [start, end)，也就是左闭右开。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'hello'</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 表示取 s 的第 0、2、4 个字符，结果是 'hlo'</span></span><br></pre></td></tr></table></figure>
<p>再举几个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>:<span class="number">5</span>]  <span class="comment"># 不写 step 默认就是 1，因此得到 'hello'</span></span><br><span class="line">s[<span class="number">1</span>:]   <span class="comment"># 不写 end 默认到结尾，因此还是得到 'ello'</span></span><br><span class="line">s[n:]   <span class="comment"># 获取 s 的最后 len(s) - n 个元素</span></span><br><span class="line">s[:<span class="number">2</span>]   <span class="comment"># 不写 start 默认从 0 开始，因此得到 'he'</span></span><br><span class="line">s[:n]   <span class="comment"># 获取 s 的前 n 个元素</span></span><br><span class="line">s[:<span class="number">-1</span>]  <span class="comment"># 负数表示倒过来数，因此这会刨除最后一个字符，得到 'hell'</span></span><br><span class="line">s[<span class="number">-2</span>:]  <span class="comment"># 同上，表示获取最后两个字符，得到 'lo'</span></span><br><span class="line">s[::<span class="number">-1</span>] <span class="comment"># 获取字符串的倒序排列，相当于 reverse 函数</span></span><br></pre></td></tr></table></figure>
<p>step 和它前面的冒号要么同时写，要么同时不写，但 start 和 end 之间的冒号不能省，否则就不是切片而是获取元素了。再次强调 array[start:end] 表示的区间是 [a, b)，也许你会觉得这很难记，但同样的，这会得出以下美妙的公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">array[:n] + array[n:] = array (0 &lt;= n &lt;= len(array))</span><br></pre></td></tr></table></figure>
<p>用代码来表示就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;hello&apos;</span><br><span class="line">s[:2] + s[2:] == s  </span><br><span class="line"># True，因为 s[:2] 是 &apos;he&apos;，s[2:] 是 &apos;llo&apos;</span><br></pre></td></tr></table></figure>
<p>切片不仅可以用来获取数组的一部分值，修改切片也可以直接修改数组的对应部分，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">a[1:3] = [22, 33, 44]</span><br><span class="line"># a = [1, 22, 33, 44, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<p>并没有人规定切片的新值必须和原来的长度一致：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">a[1:3] = [3]</span><br><span class="line"># a = [1, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">a[1:4] = []</span><br><span class="line"># a = [1, 6]，相当于删除了中间的三个数字</span><br></pre></td></tr></table></figure>
<p>但切片的新值必须也是可迭代的对象，比如这样写是不合法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">a[1:3] = 3</span><br><span class="line"># TypeError: can only assign an iterable</span><br></pre></td></tr></table></figure>
<h5 id="循环与遍历"><a href="#循环与遍历" class="headerlink" title="循环与遍历"></a>循环与遍历</h5><p>一般来说，在 Python 中我们不会写出 for (int i = 0; i &lt; len(array); ++i) 这种风格的代码，而是使用 for in 这种语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in [1, 2, 3]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>虽然大家都知道 for in 语法，但它的某些灵活用法或许就不是那么众所周知了。有时候，我们会在 if 语句中对某个变量的值做多次判断，只要满足一个条件即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;bs&apos;</span><br><span class="line">if name == &apos;hello&apos; or name == &apos;hi&apos; or name == &apos;bs&apos; or name == &apos;admin&apos;:</span><br><span class="line">    print(&apos;Valid&apos;)</span><br></pre></td></tr></table></figure>
<p>这种情况推荐用 in 来代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;bs&apos;</span><br><span class="line">if name in (&apos;hello&apos;, &apos;hi&apos;, &apos;bs&apos;, &apos;admin&apos;):</span><br><span class="line">    print(&apos;Valid&apos;)</span><br></pre></td></tr></table></figure>
<p>有时候，如果我们想要把某件事重复固定的次数，用 for in 会显得有些啰嗦，这时候可以借助 range 类型:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i in range(5):</span><br><span class="line">    print(&apos;Hi&apos;) # 打印五次 &apos;Hi&apos;</span><br></pre></td></tr></table></figure>
<p><code>range</code> 的语法和切片类似，比如我们需要访问数组所有奇数下标的元素，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5]</span><br><span class="line">for i in range(0, len(a), 2):</span><br><span class="line">    print(a[i])</span><br></pre></td></tr></table></figure>
<p>在这种写法中，我们不仅能获得元素，还能知道元素的下标，这与使用 enumerate(iterable [, start ]) 函数类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3, 4, 5]</span><br><span class="line">for i, n in enumerate(a):</span><br><span class="line">    print(i, n)</span><br></pre></td></tr></table></figure>
<h5 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h5><p>也许你已经注意到了，数组和字符串都支持切片，而且语法高度统一。这在某些强类型语言（比如我经常接触的 Objective-C 和 Java）中是不可能的，事实上，Python 能够支持这样统一的语法，并非巧合，而是因为所有用中括号进行下标访问的操作，其实都是调用这个类的 <code>__getitem__</code> 方法。</p>
<p>比如我们完全可以让自己的类也支持通过下标访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Book:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.chapters = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, n):</span><br><span class="line">        return self.chapters[n]</span><br><span class="line"></span><br><span class="line">b = Book()</span><br><span class="line">print(b[1]) # 结果是 2</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这段代码几乎不会出问题（除非数组越界），这是因为我们直接把下标传到了内部的 self.chapters 数组上。但如果要自己处理下标，需要牢记它不一定是数字，也可以是切片，因此更完整的逻辑应该是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def __getitem__(self, n):</span><br><span class="line">    if isinstance(n, int): # n是索引</span><br><span class="line">        # 处理索引</span><br><span class="line">    if isinstance(n, slice): # n是切片</span><br><span class="line">        # 通过 n.start，n.stop 和 n.step 来处理切片</span><br></pre></td></tr></table></figure>
<p>与静态语言不同的是，任何实现了 <strong>getitem</strong> 都支持通过下标访问，而不用声明为实现了某个协议，这种特性也被称为 “鸭子类型”。鸭子类型并不要求某个类 是什么，仅仅要求这个类 能做什么。</p>
<p>顺便说一句，实现了 <code>__getitem__</code> 方法的类都是可迭代的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = Book()</span><br><span class="line">for c in b:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>
<p>后续的章节还会介绍更多 Python 中的魔术方法，这种方法的名称前后都有两个下划线，如果读作 “下划线-下划线-getitem” 会比较拗口，因此可以读作 “dunder-getitem” 或者 “双下-getitem”，类似的，我想每个人都能猜到 <code>__setitem__</code> 的作用和用法。</p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><h5 id="初始化字典"><a href="#初始化字典" class="headerlink" title="初始化字典"></a>初始化字典</h5><p>最简单的创建一个字典的方式就是直接写字面量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;a&apos;: 61, &apos;b&apos;: 62, &apos;c&apos;: 63, &apos;d&apos;: 64, &apos;e&apos;: 65&#125;</span><br></pre></td></tr></table></figure>
<p>字典字面量由大括号包住（注意区别于数组的中括号），键值对之间由逗号分割，每个键值对内部用冒号分割键和值。</p>
<p>如果数组的每个元素都是二元的元组，这个数组可以直接转成字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict([(&apos;a&apos;, 61), (&apos;b&apos;, 62), (&apos;c&apos;, 63), (&apos;d&apos;, 64), (&apos;e&apos;, 65)])</span><br></pre></td></tr></table></figure>
<p>就像数组可以推导一样，字典也可以推导：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [(&apos;a&apos;, 61), (&apos;b&apos;, 62), (&apos;c&apos;, 63), (&apos;d&apos;, 64), (&apos;e&apos;, 65)]</span><br><span class="line">d = &#123;letter: number for letter, number in a&#125; # 这里用到了元组拆包</span><br></pre></td></tr></table></figure>
<p>只要记得外面还是大括号就行了。</p>
<p>两个独立的数组可以被压缩成一个字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [61, 62, 63, 64, 65]</span><br><span class="line">letters = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">dict(zip(letters, numbers))</span><br></pre></td></tr></table></figure>
<p>正如 zip 的意思所表示的，超出长处的那部分数组会被抛弃。</p>
<h5 id="查询字典"><a href="#查询字典" class="headerlink" title="查询字典"></a>查询字典</h5><p>最简单方法是直接写键名，但如果键名不存在会抛出 KeyError：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;a&apos;: 61&#125;</span><br><span class="line">d[&apos;a&apos;] # 值是 61</span><br><span class="line">d[&apos;b&apos;] # KeyError: &apos;b&apos;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">可以用 if key in dict 的判断来检查键是否存在，甚至可以先 try 再 catch KeyError ，但更加优雅简洁一些的写法是用 get(k, default) 方法来提供默认值：</span><br></pre></td></tr></table></figure>
<p>d = {‘a’: 61}<br>d.get(‘a’, 62) # 得到 61<br>d.get(‘b’, 62) # 得到 62</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不过有时候，我们可能不仅仅要读出默认属性，更希望能把这个默认属性能写入到字典中，比如：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">## 我们想对字典中某个 Value 做操作，如果 Key 不存在，就先写入一个空值</span><br><span class="line">if &apos;list&apos; not in d:</span><br><span class="line">    d[&apos;list&apos;] = []</span><br><span class="line">d[&apos;list&apos;].append(1)</span><br></pre></td></tr></table></figure>
<p>这种情况下，<code>setdefault(key, default)</code> 函数或许更合适：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.setdefault(&apos;key&apos;, []).append(1)</span><br></pre></td></tr></table></figure>
<p>这个函数虽然名为 set，但作用其实是查找，仅仅在查找不到时才会把默认值写入字典</p>
<h5 id="遍历字典"><a href="#遍历字典" class="headerlink" title="遍历字典"></a>遍历字典</h5><p>直接遍历字典实际上是遍历了字典的键，因此也可以通过键获取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;a&apos;: 61, &apos;b&apos;: 62, &apos;c&apos;: 63, &apos;d&apos;: 64, &apos;e&apos;: 65&#125;</span><br><span class="line">for i in d:</span><br><span class="line">    print(i, d[i])</span><br><span class="line">#b 62</span><br><span class="line">#a 61</span><br><span class="line">#e 65</span><br><span class="line">#d 64</span><br><span class="line">#c 63</span><br></pre></td></tr></table></figure>
<p>我们也可以用字典的 keys() 或者 values() 方法显式的获取键和值。字典还有一个 items() 方法，它返回一个数组，每个元素都是由键和值组成的二元元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;a&apos;: 61, &apos;b&apos;: 62, &apos;c&apos;: 63, &apos;d&apos;: 64, &apos;e&apos;: 65&#125;</span><br><span class="line">for (k, v) in d.items():</span><br><span class="line">    print(k, v)</span><br><span class="line">#e 65</span><br><span class="line">#d 64</span><br><span class="line">#a 61</span><br><span class="line">#c 63</span><br><span class="line">#b 62</span><br></pre></td></tr></table></figure>
<p>可见 items() 方法和字典的构造方法互为逆操作，因为这个公式总是成立的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict(d.items()) == d</span><br></pre></td></tr></table></figure>
<h5 id="字典的魔术方法"><a href="#字典的魔术方法" class="headerlink" title="字典的魔术方法"></a>字典的魔术方法</h5><p>在 1.1.4 节中介绍过，通过下标访问最终都会由 <code>__getitem__</code> 这个魔术方法处理，因此字典的 d[key] 这种写法也不例外， 如果键不存在，则会走到 <code>__missing__</code> 方法，再给一次挽救的机会。比如我们可以实现一个字典， 自动忽略键的大小写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyDict(dict):</span><br><span class="line">    def __missing__(self, key):</span><br><span class="line">        if key.islower():</span><br><span class="line">            raise KeyError(key)</span><br><span class="line">        else:</span><br><span class="line">            return self[key.lower()]</span><br><span class="line"></span><br><span class="line">d = MyDict(&#123;&apos;a&apos;: 61&#125;)</span><br><span class="line">d[&apos;A&apos;] # 返回 61</span><br><span class="line">&apos;A&apos; in d # False</span><br></pre></td></tr></table></figure>
<p>这个字典比较简陋，比如 key 可能不是字符串，不过我没有处理太多情况，因为它主要是用来演示 <code>__missing__</code> 的用法，如果想要最后一行的 in 语法正确工作，需要重写 <code>__contains__</code> 这个魔术方法，过程类似，就不赘述了。</p>
<p>虽然通过自定义的函数也能实现相似的效果，不过这个自定义字典对用户更加透明，如果不在文档中说明，调用方很难察觉到字典的内部逻辑被修改了。 Python 有很多强大的功能，可以具备这种内部进行修改，但是对外保持透明的能力。这可能是我们第一次体会到，后续还会不断的经历。</p>
<h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5><p>集合更像是不会有重复元素的数组，但它的本质是以元素的哈希值作为 Key，从而实现去重的逻辑。因此，集合也可以推导，不过得用字典的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3,4,5,4,3,2,1]</span><br><span class="line">d = &#123;i for i in a if i &lt; 5&#125;</span><br><span class="line"># d = &#123;1, 2, 3, 4&#125;，注意这里的大括号</span><br></pre></td></tr></table></figure>
<p>回忆一下，二进制逻辑运算一共有三个运算符，按位或 |，按位与 &amp; 和异或 ^，这三个运算符也可以用在集合之间，而且含义变化不大。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1, 2, 3&#125;</span><br><span class="line">b = &#123;3, 4, 5&#125;</span><br><span class="line">c = a | b</span><br><span class="line"># c = &#123;1, 2, 3, 4, 5&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 | 运算表示并集，也就是 c 中的任意元素，要么在 a，要么在 b 集合中。类似的，按位与 &amp; 运算求的就是交集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1, 2, 3&#125;</span><br><span class="line">b = &#123;3, 4, 5&#125;</span><br><span class="line">c = a &amp; b</span><br><span class="line"># c = &#123;3&#125;</span><br></pre></td></tr></table></figure>
<p>而异或则表示那些只在 a 不在 b 或者只在 b 不在 a 的元素。或者换个说法，表示那些在集合 a 和 b 中出现了且仅出现了一次的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1, 2, 3&#125;</span><br><span class="line">b = &#123;3, 4, 5&#125;</span><br><span class="line">c = a ^ b</span><br><span class="line"># c = &#123;1, 2, 4, 5&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个差集运算 -，表示在集合 a 中但不在集合 b 中的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;1, 2, 3&#125;</span><br><span class="line">b = &#123;3, 4, 5&#125;</span><br><span class="line">c = a - b</span><br><span class="line"># c = &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>
<p>回忆一下韦恩图，就会得到以下公式（虽然并没有什么卵用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A | B = (A ^ B) | (A &amp; B)</span><br><span class="line">A ^ B = (A - B) | (B - A)</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h5><p>用 Python 写过爬虫的人都应该感受过被字符串编码支配的恐惧。简单来说，编码指的是将可读的字符串转换成不太可读的数字，用来存储或者传输。解码则指的是将数字还原成字符串的过程。常见的编码有 ASCII、GBK 等。</p>
<p>ASCII 编码是一个相当小的字符集合，只有一百多个常用的字符，因此只用一个字节（8 位）就能表示，为了存储本国语言，各个国家都开发出了自己的编码，比如中文的 GBK。这就带来了一个问题，如果我想要在一篇文章中同时写中文和日文，就无法实现了，除非能对每个字符指定编码，这个成本高到无法接受。</p>
<p>Unicode 则是一个最全的编码方式，每个 Unicode 字符占据 6 个字节，可以表示出 2 ^ 48 种字符。但随之而来的是 Unicode 编码后的内容不适合存储和发送，因此诞生了基于 Unicode 的再次编码，目的是为了更高效的存储。</p>
<p>首先，编码的函数是 encode，它是字符串的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;hello&apos;</span><br><span class="line">s.encode()         # 得到 b&apos;hello&apos;</span><br><span class="line">s.encode(&apos;utf16&apos;)  # 得到 b&apos;\xff\xfeh\x00e\x00l\x00l\x00o\x00&apos;</span><br></pre></td></tr></table></figure>
<p>encode 函数有两个参数，第一个参数不写表示使用默认的 utf8 编码，理论上会输出二进制格式的编码结果，但在终端打印时，被自动还原回字符串了。如果用 utf16 进行编码，则会看到编码以后的二进制结果。</p>
<p>前面说过，编码是字符转到二进制的转化过程，有时候在某个编码规范中，并没有指定某个字符是如何编码的，也就是找不到对应的数字，这时候编码就会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">city = &apos;São Paulo&apos;</span><br><span class="line">b_city = city.encode(&apos;cp437&apos;)</span><br><span class="line"># UnicodeEncodeError: &apos;charmap&apos; codec can&apos;t encode character &apos;\xe3&apos; in position 1: character maps to &lt;undefined&gt;</span><br></pre></td></tr></table></figure>
<p>此时需要用到 encode 函数的第二个参数，用来指定遇到错误时的行为。它的值可以是 ‘ignore’，表示忽略这个不能编码的字符，也可以是 ‘replace’，表示用默认字符代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b_city = city.encode(&apos;cp437&apos;, errors=&apos;ignore&apos;) </span><br><span class="line"># b&apos;So Paulo&apos;</span><br><span class="line">b_city = city.encode(&apos;cp437&apos;, errors=&apos;replace&apos;)</span><br><span class="line"># b&apos;S?o Paulo&apos;</span><br></pre></td></tr></table></figure>
<p><code>decode</code> 完全是 <code>encode</code> 的逆操作，只有二进制类型才有这个函数。它的两个参数含义和 encode 函数完全一致，就不再介绍了。</p>
<p>从理论上来说，仅从编码后的内容上来看，是无法确定编码方式的，也无法解码出原来的字符。但不同的编码有各自的特点，虽然无法完全倒推，但可以从概率上来猜测，如果发现某个二进制内容，有 99% 的可能性是 utf8 编码生成的，我们就可以用 utf8 进行解码。Python 提供了一个强大的工具包 Chardet 来完成这一任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octets = b&apos;Montr\xe9al&apos;</span><br><span class="line">chardet.detect(octets)</span><br><span class="line"># &#123;&apos;encoding&apos;: &apos;ISO-8859-1&apos;, &apos;confidence&apos;: 0.73, &apos;language&apos;: &apos;&apos;&#125;</span><br><span class="line">octets.decode(&apos;ISO-8859-1&apos;)</span><br><span class="line"># Montréal</span><br></pre></td></tr></table></figure>
<p>返回结果中包含了猜测的编码方式，以及可信度。可信度越高，说明是这种编码方式的可能性越大。</p>
<p>有时候，我们拿到的是二进制的字符串字面量，比如 68 65 6c 6c 6f，前文说过只有二进制类型才有 decode 函数，所以需要通过二进制的字面量生成二进制变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;68 65 6c 6c 6f&apos;</span><br><span class="line">b = bytearray.fromhex(s)</span><br><span class="line">b.decode()  # hello</span><br></pre></td></tr></table></figure>
<h5 id="字符串的常用方法"><a href="#字符串的常用方法" class="headerlink" title="字符串的常用方法"></a>字符串的常用方法</h5><p>字符串的 split(sep, maxsplit) 方法可以以指定的分隔符进行分割，有点类似于 Shell 中的 awk -F ‘ ‘’，第一个 sep 参数表示分隔符，不填则为空格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;a b c d e&apos;</span><br><span class="line">a = s.split()</span><br><span class="line"># a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br></pre></td></tr></table></figure>
<p>第二个参数 maxsplit 表示最多分割多少次，因此返回数组的长度是 maxsplit + 1。举个例子说明下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;a;b;c;d;e&apos;</span><br><span class="line">a = s.split(&apos;;&apos;)</span><br><span class="line"># a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line"></span><br><span class="line">b = s.split(&apos;;&apos;, 2)</span><br><span class="line"># b = [&apos;a&apos;, &apos;b&apos;, &apos;c;d;e&apos;]</span><br></pre></td></tr></table></figure>
<p>如果想批量替换，则可以用 replace(old, new[, count]) 方法，由中括号括起来的参数表示选填</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &apos;a;b;c;d;e&apos;</span><br><span class="line">new = old.replace(&apos;;&apos;, &apos; &apos;, 3)</span><br><span class="line"># new = &apos;a b c d;e&apos;</span><br></pre></td></tr></table></figure>
<p>strip[chars] 用于移除指定的字符们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &quot;*****!!!Hello!!!*****&quot;</span><br><span class="line">new = old.strip(&apos;*&apos;)  # 得到 &apos;!!!Hello!!!&apos;</span><br><span class="line">new = old.strip(&apos;*！&apos;)  # 得到 &apos;Hello&apos;</span><br></pre></td></tr></table></figure>
<p>最后一个常用方法是 join，其实这个可以理解为字符串的构造方法，它可以把数组转换成字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = &apos;a b c d e&apos;.split() # 之前说过，结果是 [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;]</span><br><span class="line">s = &apos;;&apos;.join(array) # 以分号为连接符，把数组中的元素连接起来</span><br><span class="line"># s = &apos;a;b;c;d;e&apos;</span><br></pre></td></tr></table></figure>
<p>上面这些字符串处理的函数，大多返回的还是字符串，因此可以链式调用，避免使用临时变量和多行代码，但也要避免过长（超过 3 个）的链式调用，以免影响可读性。</p>
<h5 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h5><p>最初级的字符串格式化方法是使用 + 来拼接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;bestswifter&apos;</span><br><span class="line">        self.age = 22</span><br><span class="line">        self.sex = &apos;m&apos;</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">print(&apos;Name: &apos; + p.name + &apos;, Age: &apos; + str(p.age) + &apos;, Sex: &apos; + p.sex)</span><br><span class="line"># 输出：Name: bestswifter, Age: 22, Sex: m</span><br></pre></td></tr></table></figure>
<p>这里必须要把 int 类型的年龄转成字符串以后才能进行拼接，这是因为 Python 是强类型语言，不支持类型的隐式转换。</p>
<p>这种做法的缺点在于如果输出结构比较复杂，极容易出现引号匹配错误的问题，可读性非常低。</p>
<p>Python 2 中的做法是使用占位符，类似于 C 语言中 printf:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content = &apos;Name: %s, Age: %i, Sex: %c&apos; % (p.name, p.age, p.sex)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>
<p>从结构上看，要比上一种写法清楚得多， 但每个变量都需要指定类型，这和 Python 的简洁不符。实际上每个对象都可以通过 str() 函数转换成字符串，这个函数的背后是 <code>__str__</code> 魔术方法。</p>
<p>Python 3 中的写法是使用 format 函数，比如我们来实现一下 <code>__str__</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;bestswifter&apos;</span><br><span class="line">        self.age = 22</span><br><span class="line">        self.sex = &apos;m&apos;</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&apos;.format(user=self)</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">print(p)</span><br><span class="line"># 输出：Name: bestswifter, Age: 22, Sex: m</span><br></pre></td></tr></table></figure>
<p>除了把对象传给 format 函数并在字符串中展开以外， 也可以传入多个参数，并且通过下标访问他们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;&#123;0&#125;, &#123;1&#125;, &#123;0&#125;&apos;.format(1, 2))</span><br><span class="line"># 输出：1, 2, 1，这里的 &#123;1&#125; 表示第二个参数</span><br></pre></td></tr></table></figure>
<h5 id="HereDoc"><a href="#HereDoc" class="headerlink" title="HereDoc"></a>HereDoc</h5><p>Heredoc 不是 Python 特有的概念， 命令行和各种脚本中都会见到，它表示一种所见即所得的文本。</p>
<p>假设我们在写一个 HTML 的模板，绝大多数字符串都是常量，只有有限的几个地方会用变量去替换，那这个字符串该如何表示呢？一种写法是直接用单引号去定义:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;\nFriends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;\n&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;\n&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;\n&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back\nONCLICK=\'window.history.back()\'&gt;&lt;/FORM&gt;\n&lt;/BODY&gt;&lt;/HTML&gt;'</span></span><br></pre></td></tr></table></figure>
<p>这段代码是自动生成的还好，如果是手动维护的，那么可读性就非常差，因为换行符和转义后的引号增加了理解的难度。如果用 heredoc 来写，就非常简单了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span></span><br><span class="line"><span class="string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span></span><br><span class="line"><span class="string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span></span><br><span class="line"><span class="string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span></span><br><span class="line"><span class="string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span></span><br><span class="line"><span class="string">ONCLICK='window.history.back()'&gt;&lt;/FORM&gt;</span></span><br><span class="line"><span class="string">&lt;/BODY&gt;&lt;/HTML&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>Heredoc 主要是用来书写大段的字符串常量，比如 HTML 模板，SQL语句等等</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h4><p>一等公民指的是 Python 的函数能够动态创建，能赋值给别的变量，能作为参传给函数，也能作为函数的返回值。总而言之，函数和普通变量并没有什么区别。</p>
<p>函数是一等公民，这是函数式编程的基础，然而 Python 中基本上不会使用 lambda 表达式，因为在 lambda 表达式的中仅能使用单纯的表达式，不能赋值，不能使用 while、try 等语句，因此 lambda 表达式要么难以阅读，要么根本无法写出。这极大的限制了 lambda 表达式的使用场景。</p>
<p>上文说过，函数和普通变量没什么区别，但普通变量并不是函数，因为这些变量无法调用。但如果某个类实现了 <code>__call__</code> 这个魔术方法，这个类的实例就都可以像函数一样被调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &apos;bestswifter&apos;</span><br><span class="line">        self.age = 22</span><br><span class="line">        self.sex = &apos;m&apos;</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print(self)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &apos;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&apos;.format(user=self)</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p() # 等价于 print(p)</span><br></pre></td></tr></table></figure>
<h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><h5 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h5><p>对于熟悉 C 系列语言的人来说，函数传参的方式一目了然。默认是拷贝传值，如果传指针是引用传值。我们先来看一段简单的 Python 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def foo(arg):</span><br><span class="line">    arg = 5</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">a = 1</span><br><span class="line">foo(a)</span><br><span class="line">print(a)</span><br><span class="line"># 输出 5 和 1</span><br></pre></td></tr></table></figure>
<p>这段代码的结果符合我们的预期，从这段代码来看，Python 也属于拷贝传值。但如果再看这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def foo(arg):</span><br><span class="line">    arg.append(1)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">a = [1]</span><br><span class="line">foo(a)</span><br><span class="line">print(a) # 输出两个 [1, 1]</span><br></pre></td></tr></table></figure>
<p>你会发现参数数组在函数内部被改变了。就像是 C 语言中传递了变量的指针一样。所以 Python 到底是拷贝传值还是引用传值呢？答案都是否定的！</p>
<p>Python 的传值方式可以被理解为混合传值。对于那些不可变的对象（比如 1.1.2 节中介绍过的元组，还有数字、字符串类型），传值方式是拷贝传值；对于那些可变对象（比如数组和字典）则是引用传值</p>
<h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><p>Python 的函数可以有默认值，这个功能很好用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def foo(a, l=[]):</span><br><span class="line">    l.append(a)</span><br><span class="line">    return l</span><br><span class="line"></span><br><span class="line">foo(2,[1])  # 给数组 [1] 添加一个元素 2，得到 [1,2]</span><br><span class="line">foo(2)</span><br></pre></td></tr></table></figure>
<p>然而如果这样调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(2)  # 利用默认参数，得到 [2]</span><br><span class="line">foo(3)  # 竟然得到了 [2, 3]</span><br></pre></td></tr></table></figure>
<p>函数调用了两次以后，默认参数被改变了，也就是说函数调用产生了副作用。这是因为默认参数的存储并不像函数里的临时变量一样存储在栈上、随着函数调用结束而释放，而是存储在函数这个对象的内部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.__defaults__  # 一开始确实是空数组</span><br><span class="line">foo(2)  # 利用默认参数，得到 [2]</span><br><span class="line">foo.__defaults__  # 如果打印出来看，已经变成 [2] 了</span><br><span class="line">foo(3)  # 再添加一个元素就得到了 [2, 3]</span><br></pre></td></tr></table></figure>
<p>因为函数 foo 作为一个对象，不会被释放，因此这个对象内部的属性也不会随着多次调用而自动重置，会一直保持上次发生的变化。基于这个前提，我们得出一个结论：函数的默认参数不允许是可变对象，比如这里的 foo 函数需要这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def foo(a, l=None):</span><br><span class="line">    if l is None:</span><br><span class="line">        l = []</span><br><span class="line">    l.append(a)</span><br><span class="line">    return l</span><br><span class="line"></span><br><span class="line">print(foo(2)) # 得到 [2]</span><br><span class="line">print(foo(3)) # 得到 [3]</span><br></pre></td></tr></table></figure>
<p>现在，给参数添加默认值的行为在函数体中完成，不会随着函数的多次调用而累积。</p>
<p>对于 Python 的默认参数来说:</p>
<blockquote>
<p>如果默认值是不可变的，可以直接设置默认值，否则要设置为 None 并在函数体中设置默认值。</p>
</blockquote>
<h5 id="多参数传递"><a href="#多参数传递" class="headerlink" title="多参数传递"></a>多参数传递</h5><p>当参数个数不确定时，可以在参数名前加一个 <code>*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def foo(*args):</span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line">foo(1, 2, 3)  # 输出 [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>如果直接把数组作为参数传入，它其实是单个参数，如果要把数组中所有元素都作为单独的参数传入，则在数组前面加上 <code>*</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3]    </span><br><span class="line">foo(a)  # 会输出 ([1,2,3], )   因为只传了一个数组作为参数</span><br><span class="line">foo(*a) # 输出 [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>这里的单个 <em> 只能接收非关键字参数，也就是仅有参数值的哪些参数。如果想接受关键字参数，需要用 *</em> 来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def foo(*args, **kwargs):</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">foo(1,2,3, a=61, b=62)</span><br><span class="line"># 第一行输出：(1, 2, 3)</span><br><span class="line"># 第二行输出：&#123;&apos;a&apos;: 61, &apos;b&apos;: 62&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，字典变量传入函数只能作为单个参数，如果要想展开并被 <code>**kwargs 识别，需要在字典前面加上两个星号 **</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3]</span><br><span class="line">d = &#123;&apos;a&apos;: 61, &apos;b&apos;: 62&#125;</span><br><span class="line">foo(*a, **d)</span><br></pre></td></tr></table></figure>
<h5 id="参数分类"><a href="#参数分类" class="headerlink" title="参数分类"></a>参数分类</h5><p>Python 中函数的参数可以分为两大类：</p>
<ol>
<li>定位参数（Positional）：表示参数的位置是固定的。比如对于函数 foo(a, b) 来说，<code>foo(1, 2)</code> 和 <code>foo(2, 1)</code> 就是截然不同的，a 和 b 的位置是固定的，不可随意调换。</li>
<li>关键词参数（Keyword）：表示参数的位置不重要，但是参数名称很重要。比如 <code>foo(a = 1, b = 2)</code> 和 <code>foo(b = 2, a = 1)</code> 的含义相同。</li>
</ol>
<p>有一种参数叫做仅限关键字（Keyword-Only）参数，比如考虑这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def foo(*args, n=1, **kwargs):</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>
<p>这个函数在调用时，如果参数 n 不指定名字，就会被前面的 <em>args 处理掉，如果指定的名字不是 n，又会被后面的 *</em>kwargs 处理掉，所以参数 n 必须精确的以 (n = xxx) 的形式出现，也就是 Keyworld-Only。</p>
<h4 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h4><p>在 2.2.2 节中，我们查看了函数变量的 <strong>defaults</strong> 属性，其实这就是一种内省，也就是在运行时动态的查看变量的信息。</p>
<p>前文说过，函数也是对象，因此函数的变量个数，变量类型都应该有办法获取到，如果你需要开发一个框架，也许会对函数有各种奇葩的检查和校验。</p>
<p>以下面这个函数为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = 1</span><br><span class="line">def foo(m, *args, n, **kwargs):</span><br><span class="line">    a = 1</span><br><span class="line">    b = 2</span><br></pre></td></tr></table></figure>
<p>首先可以获取函数名，函数所在模块的全局变量等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__globals__   # 全局变量，包含了 g = 1</span><br><span class="line">foo.__name__      # foo</span><br></pre></td></tr></table></figure>
<p>我们还可以看到函数的参数，函数内部的局部变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__code__.co_varnames  # (&apos;m&apos;, &apos;n&apos;, &apos;args&apos;, &apos;kwargs&apos;, &apos;a&apos;, &apos;b&apos;)</span><br><span class="line">foo.__code__.co_argcount  # 只计算参数个数，不考虑可变参数和仅限关键字参数，所以得到 1</span><br></pre></td></tr></table></figure>
<p>或者用 inspect 模块来查看更详细的信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">sig = inspect.signature(foo)  <span class="comment"># 获取函数签名</span></span><br><span class="line"></span><br><span class="line">sig.parameters[<span class="string">'m'</span>].kind      <span class="comment"># POSITIONAL_OR_KEYWORD 表示可以是定位参数或关键字参数</span></span><br><span class="line">sig.parameters[<span class="string">'args'</span>].kind   <span class="comment"># VAR_POSITIONAL 定位参数构成的数组</span></span><br><span class="line">sig.parameters[<span class="string">'n'</span>].kind      <span class="comment"># KEYWORD_ONLY 仅限关键字参数</span></span><br><span class="line">sig.parameters[<span class="string">'kwargs'</span>].kind <span class="comment"># VAR_KEYWORD 关键字参数构成的字典</span></span><br><span class="line">inspect.getfullargspec(foo)       </span><br><span class="line"><span class="comment"># 得到：ArgSpec(args=['m', 'n'], varargs='args', keywords='kwargs', defaults=None)</span></span><br></pre></td></tr></table></figure>
<p>本节的新 API 比较多，但并不要求记住这些 API 的用法。再次强调，本文的写作目的是为了建立读者对 Python 的总体认知，了解 Python 能做什么，至于怎么做，那是文档该做的事。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><h5 id="设计模式的消亡"><a href="#设计模式的消亡" class="headerlink" title="设计模式的消亡"></a>设计模式的消亡</h5><p>经典的设计模式有 23 个，虽然设计模式都是常用代码的总结，理论上来说与语法无关。但不得不承认的是，标准的设计模式在不同的语言中，有的因为语法的限制根本无法轻易实现（比如在 C 语言中实现组合模式），有的则因为语言的特定功能，变得冗余啰嗦。</p>
<p>以策略模式为例，有一个抽象的策略类，定义了策略的接口，然后使用者选择一个具体的策略类，构造他们的实例并且调用策略方法</p>
<p>然而这些对象本身并没有作用，它们仅仅是可以调用相同的方法而已，只不过在 Java 中，所有的任务都需要由对象来完成。即使策略本身就是一个函数，但也必须把它包裹在一个策略对象中。所以在 Python 中更优雅写法是直接把策略函数作为变量使用。不过这就引入一个问题，如何判断某个函数是个策略呢，毕竟在面向对象的写法中，只要检查它的父类是否是抽象的策略类即可。</p>
<p>也许你已经见过类似的写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@strategy</span><br><span class="line">def strategyA(n):</span><br><span class="line">    print(n * 2)</span><br></pre></td></tr></table></figure>
<p>下面就开始介绍装饰器</p>
<h5 id="装饰器的基本原理"><a href="#装饰器的基本原理" class="headerlink" title="装饰器的基本原理"></a>装饰器的基本原理</h5><p>首先，装饰器是个函数，它的参数是被装饰的函数，返回值也是一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def decorate(origin_func):  # 这个参数是被装饰的函数</span><br><span class="line">    print(1)  # 先输出点东西</span><br><span class="line">    return origin_func  # 把原函数直接返回</span><br><span class="line"></span><br><span class="line">@decorate    # 注意这里不是函数调用，所以不用加括号，也不用加被修饰的函数名</span><br><span class="line">def sayHello():</span><br><span class="line">    print(&apos;Hello&apos;)</span><br><span class="line"></span><br><span class="line">sayHello()  # 如果没有装饰器，只会打印 &apos;Hello&apos;，实际结果是打印 1 再打印 &apos;Hello&apos;</span><br></pre></td></tr></table></figure>
<p>因此，使用装饰器的这种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@decorate</span><br><span class="line">def foo():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p>
<p>和下面这种写法是完全等价的， 初学者可以把装饰器在心中默默的转换成下一种写法，以方便理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    pass</span><br><span class="line">foo = decorate(foo)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，装饰器函数 decorate 在模块被导入时就会执行，而被装饰的函数只在被调用时才会执行，也就是说即使不调用 sayHello 函数也会输出 1，但这样就不会输出 Hello 了。</p>
<p>有了装饰器，配合前面介绍的函数对象，函数内省，我们可以做很多有意思的事，至少判断上一节中某个函数是否是策略是非常容易的。在装饰器中，我们还可以把策略函数都保存到数组中， 然后提供一个“推荐最佳策略”的功能， 其实就是遍历执行所有的策略，然后选择最好的结果</p>
<h5 id="装饰器进阶"><a href="#装饰器进阶" class="headerlink" title="装饰器进阶"></a>装饰器进阶</h5><p>上一节中的装饰器主要是为了介绍工作原理，它的功能非常简单，并不会改变被装饰函数的运行结果，仅仅是在导入时装饰函数，然后输出一些内容。换句话说，即使不执行函数，也要执行装饰器中的 print 语句，而且因为直接返回函数的缘故，其实没有真正的起到装饰的效果。</p>
<p>如何做到装饰时不输出任何内容，仅在函数执行最初输出一些东西呢？这是常见的 AOP（面向切片编程） 的需求。这就要求我们不能再直接返回被装饰的函数，而是应该返回一个新的函数，所以新的装饰器需要这么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def decorate(origin_func):</span><br><span class="line">    def new_func():</span><br><span class="line">        print(1)</span><br><span class="line">        origin_func()</span><br><span class="line">    return new_func</span><br><span class="line"></span><br><span class="line">decorate</span><br><span class="line">def sayHello():</span><br><span class="line">    print(&apos;Hello&apos;)</span><br><span class="line"></span><br><span class="line">sayHello() # 运行结果不变，但是仅在调用函数 sayHello 时才会输出 1</span><br></pre></td></tr></table></figure>
<p>这个例子的工作原理是，sayHello 函数作为参数 origin_func 被传到装饰器中，经过装饰以后，它实际上变成了 new_func，会先输出 1 再执行原来的函数，也就是 sayHello。</p>
<p>这个例子很简陋，因为我们知道了 sayHello 函数没有参数，所以才能定义一个同样没有参数的替代者：nwe_func。如果我们在开发一个框架，要求装饰器能对任意函数生效，就需要用到 2.2.3 中介绍的 <em> 和 *</em> 这种不定参数语法了。</p>
<p>如果查看 sayHello 函数的名字，得到的结果将是 new_func：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello.__name__  # new_func</span><br></pre></td></tr></table></figure>
<p>这是很自然的，因为本质上其实执行的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_func = decorate(sayHello)</span><br></pre></td></tr></table></figure>
<p>而装饰器的返回结果是另一个函数 new_func，两者仅仅是运行结果类似，但两个对象并没有什么关联。</p>
<p>所以为了处理不定参数，并且不改变被装饰函数的外观（比如函数名），我们需要做一些细微的修补工作。这些工作都是模板代码，所以 Python 早就提供了封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def decorate(origin_func):</span><br><span class="line">    @functools.wraps(origin_func)  # 这是 Python 内置的装饰器</span><br><span class="line">    def new_func(*args, **kwargs):</span><br><span class="line">        print(1)</span><br><span class="line">        origin_func(*args, **kwargs)</span><br><span class="line">    return new_func</span><br></pre></td></tr></table></figure>
<h5 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h5><p>在 2.4.2 节的代码注释中我解释过，装饰器后面不要加括号，被装饰的函数自动作为参数，传递到装饰器函数中。如果加了括号和参数，就变成手动调用装饰器函数了，大多数时候这与预期不符（因为装饰器的参数一般都是被装饰的函数）。</p>
<p>不过装饰器可以接受自定义的参数，然后返回另一个装饰器，这样外面的装饰器实际上就是一个装饰器工厂，可以根据用户的参数，生成不同的装饰器。还是以上面的装饰器为例，我希望输出的内容不是固定的 1，而是用户可以指定的，代码就应该这么写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line"></span><br><span class="line">def decorate(content):                        # 这其实是一个装饰器工厂</span><br><span class="line">    def real_decorator(origin_func):          # 这才是刚刚的装饰器</span><br><span class="line">        @functools.wraps(origin_func)</span><br><span class="line">        def new_func():</span><br><span class="line">            print(&apos;You said &apos; + str(content)) # 现在输出内容可以由用户指定</span><br><span class="line">            origin_func()</span><br><span class="line">        return new_func                       # 在装饰器里，返回的是新的函数</span><br><span class="line">    return real_decorator</span><br></pre></td></tr></table></figure>
<p>装饰器工厂和装饰器的区别在于它可以接受参数，返回一个装饰器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@decorate(2017)</span><br><span class="line">def sayHello():</span><br><span class="line">    print(&apos;Hello&apos;)</span><br><span class="line"></span><br><span class="line">sayHello()</span><br></pre></td></tr></table></figure>
<p>其实还是等价于:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real_decorator = decorate(2017)      # 通过装饰器工厂生成装饰器</span><br><span class="line">new_func = real_decorator(sayHello)  # 正常的装饰器工作逻辑</span><br><span class="line">new_func()</span><br></pre></td></tr></table></figure>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="对象内存管理"><a href="#对象内存管理" class="headerlink" title="对象内存管理"></a>对象内存管理</h4><h5 id="对象不是盒子"><a href="#对象不是盒子" class="headerlink" title="对象不是盒子"></a>对象不是盒子</h5><p>C 语言中我们定义变量用到的语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br></pre></td></tr></table></figure>
<p>这背后的含义是定义了一个 int 类型的变量 a，相当于申请了一个名为 a 的盒子（存储空间），里面装了数字 1</p>
<p>然后我们改变 a 的值：a = 2;，可以打印 a 的地址来证明它并没有发生变化。所以只是盒子里装的内容（指针指向的位置）发生了改变.</p>
<p>但是在 Python 中，变量不是盒子。比如同样的定义变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br></pre></td></tr></table></figure>
<p>这里就不能把 a 理解为 int 类型的变量了。因为在 Python 中，变量没有类型，值才有，或者说只有对象才有类型。因为即使是数字 1，也是 int 类的实例，而变量 a 更像是给这个对象贴的一个标签</p>
<p>如果执行赋值语句 a = 2，相当于把标签 a 贴在另一个对象上</p>
<p>基于这个认知，我们现在应该更容易理解 2.2.1 节中所说的函数传参规则了。如果传入的是不可变类型，比如 int，改变它的值实际上就是把标签挂在新的对象上，自然不会改变原来的参数。如果是可变类型，并且做了修改，那么函数中的变量和外面的变量都是指向同一个对象的标签，所以会共享变化。</p>
<h5 id="默认浅复制"><a href="#默认浅复制" class="headerlink" title="默认浅复制"></a>默认浅复制</h5><p>根据上一节的描述，直接把变量赋值给另一个变量， 还算不上复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3]</span><br><span class="line">b = a</span><br><span class="line">b == a   # True，等同性校验，会调用 __eq__ 函数，这里只判断内容是否相等</span><br><span class="line">b is a   # True，一致性校验，会检查是否是同一个对象，调用 hash() 函数，可以理解为比较指针</span><br></pre></td></tr></table></figure>
<p>可见不仅仅数组相同，就连变量也是相同的，可以把 b 理解为 a 的别名。</p>
<p>如果用切片，或者数组的构造函数来创建新的数组，得到的是原数组的浅拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3]</span><br><span class="line">b = list(a)</span><br><span class="line">b == a   # True，因为数组内容相同</span><br><span class="line">b is a   # False，现在 a 和 b 是两个变量，恰好指向同一个数组对象</span><br></pre></td></tr></table></figure>
<p>但如果数组中的元素是可变的，可以看到这些元素并没有被完全拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [[1], [2], [3]]</span><br><span class="line">b = list(a)</span><br><span class="line">b[0].append(2)</span><br><span class="line">a # 得到 [[1, 2], [2], [3]]，因为 a[0] 和 b[0] 其实还是挂在相同对象上的不同标签</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Micah
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://lvchenqiang.github.io/2018/03/24/Python入门指南/" title="Python入门指南">https://lvchenqiang.github.io/2018/03/24/Python入门指南/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/笔记/" rel="tag"># 笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/06/Hexo-Git-pages-免费搭建个人博客详解/" rel="next" title="Hexo + Git pages 免费搭建个人博客详解">
                <i class="fa fa-chevron-left"></i> Hexo + Git pages 免费搭建个人博客详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/24/图文布局/" rel="prev" title="自定义 UIButton 图文布局">
                自定义 UIButton 图文布局 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/image/avatar.png"
                alt="Micah" />
            
              <p class="site-author-name" itemprop="name">Micah</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lvchenqiang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/lvchenqiang_" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-csdn"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#开篇"><span class="nav-number">1.</span> <span class="nav-text">开篇</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备"><span class="nav-number">2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">3.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">3.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#列表推导"><span class="nav-number">3.1.1.</span> <span class="nav-text">列表推导</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#元组"><span class="nav-number">3.1.2.</span> <span class="nav-text">元组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组切片"><span class="nav-number">3.1.3.</span> <span class="nav-text">数组切片</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#循环与遍历"><span class="nav-number">3.1.4.</span> <span class="nav-text">循环与遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#魔术方法"><span class="nav-number">3.1.5.</span> <span class="nav-text">魔术方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字典"><span class="nav-number">3.2.</span> <span class="nav-text">字典</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化字典"><span class="nav-number">3.2.1.</span> <span class="nav-text">初始化字典</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#查询字典"><span class="nav-number">3.2.2.</span> <span class="nav-text">查询字典</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历字典"><span class="nav-number">3.2.3.</span> <span class="nav-text">遍历字典</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字典的魔术方法"><span class="nav-number">3.2.4.</span> <span class="nav-text">字典的魔术方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#集合"><span class="nav-number">3.2.5.</span> <span class="nav-text">集合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">3.3.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串编码"><span class="nav-number">3.3.1.</span> <span class="nav-text">字符串编码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串的常用方法"><span class="nav-number">3.3.2.</span> <span class="nav-text">字符串的常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符串格式化"><span class="nav-number">3.3.3.</span> <span class="nav-text">字符串格式化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HereDoc"><span class="nav-number">3.3.4.</span> <span class="nav-text">HereDoc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">4.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数是一等公民"><span class="nav-number">4.1.</span> <span class="nav-text">函数是一等公民</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数参数"><span class="nav-number">4.2.</span> <span class="nav-text">函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数传参"><span class="nav-number">4.2.1.</span> <span class="nav-text">函数传参</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默认参数"><span class="nav-number">4.2.2.</span> <span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#多参数传递"><span class="nav-number">4.2.3.</span> <span class="nav-text">多参数传递</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#参数分类"><span class="nav-number">4.2.4.</span> <span class="nav-text">参数分类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数内省"><span class="nav-number">4.3.</span> <span class="nav-text">函数内省</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#装饰器"><span class="nav-number">4.4.</span> <span class="nav-text">装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#设计模式的消亡"><span class="nav-number">4.4.1.</span> <span class="nav-text">设计模式的消亡</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#装饰器的基本原理"><span class="nav-number">4.4.2.</span> <span class="nav-text">装饰器的基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#装饰器进阶"><span class="nav-number">4.4.3.</span> <span class="nav-text">装饰器进阶</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#装饰器工厂"><span class="nav-number">4.4.4.</span> <span class="nav-text">装饰器工厂</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象"><span class="nav-number">5.</span> <span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象内存管理"><span class="nav-number">5.1.</span> <span class="nav-text">对象内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象不是盒子"><span class="nav-number">5.1.1.</span> <span class="nav-text">对象不是盒子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默认浅复制"><span class="nav-number">5.1.2.</span> <span class="nav-text">默认浅复制</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Micah</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Micah.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://lvchenqiang.github.io/2018/03/24/Python入门指南/';
          this.page.identifier = '2018/03/24/Python入门指南/';
          this.page.title = 'Python入门指南';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Micah.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  












  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'ob6xEevaCzifOdzvnfIrxSJ7-gzGzoHsz',
        appKey: 'ibWrHDRgAsLSxr5UnNH7Tb2n',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>

<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="lvchenqiang.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="lvchenqiang.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="lvchenqiang.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="lvchenqiang.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="lvchenqiang.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="lvchenqiang.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="lvchenqiang.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Python 简单入门指北 － 小专栏                                                 MathJax.Hub.Config({ tex2jax: { inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&quot;\\(&quot;,&quot;\\)&quot;]], displayMath: [ [&apos;$$&apos;,&apos;$$&apos;">
<meta property="og:type" content="article">
<meta property="og:title" content="大前端之路">
<meta property="og:url" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/index.html">
<meta property="og:site_name" content="大前端之路">
<meta property="og:description" content="Python 简单入门指北 － 小专栏                                                 MathJax.Hub.Config({ tex2jax: { inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&quot;\\(&quot;,&quot;\\)&quot;]], displayMath: [ [&apos;$$&apos;,&apos;$$&apos;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/share_logo-a15dd98a7d6b22923eb2eea3c246043ad69ebeec10682ddabc27854620f2cb9c.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/de72c2a2887d30c37adc04b0d760166b.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/20d50fcb6fd8122e0a88b9523a1ad366">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/d488dd71e0be57efe82f076c550e6a22.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/63785ebe7adfb514dcc88d4b96a34cad.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/6d30c0da2d2108ccc071c8751c4e7c1a.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/05a4f3b25b942f0656f1759eb5b6dbc6.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/7cfd0dcc1843eac2a7e4e84afd794533.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/d488dd71e0be57efe82f076c550e6a22.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/63785ebe7adfb514dcc88d4b96a34cad.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/6d30c0da2d2108ccc071c8751c4e7c1a.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/05a4f3b25b942f0656f1759eb5b6dbc6.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/7cfd0dcc1843eac2a7e4e84afd794533.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/d488dd71e0be57efe82f076c550e6a22.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/63785ebe7adfb514dcc88d4b96a34cad.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/6d30c0da2d2108ccc071c8751c4e7c1a.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/05a4f3b25b942f0656f1759eb5b6dbc6.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/31469b3ad08c72861469f732a43e61ea.jpg!small">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/de72c2a2887d30c37adc04b0d760166b.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/6766a88feda7bbbd2a0f8815d287597a.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/bf3aa9f8015fa4674524cae79572a9ad.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/38b72d1e2bc1cddc1b65af971f6a56a3.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/70d04aeb976f684226c4915995a84389.jpg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/cc2fe823edaf10d7f914bba24f0a223b.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/b427de653c520e3b2e734cd22a95f1ea.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/0545476daea0872f6f3a85c677718ed7.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/f65d300241b70bd276481cb23409aa34.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/0a42735e24ce3742e56b000ce99ca119.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/0e3b9fa52fa3483eeeb8a2b126064174.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/c0c24bc2d9413af382825082cb2a84a7.jpg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/bce84abd5b3b46130270a8c244625cbf.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/3fd8dad1645b01bc16efcefdefab6fca">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/e6e92b8c65473dc125fce865d8353932.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/65e7c7e51f6e106deea3daef037edd45">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/5c5dc26e64b05c7d0381bc3fdcf47b47">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/75188c2e8ac7fd1e9e407083982206ea">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/4dc4a3fb596e21db48e5979e32c3c2ab">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/ac9787bc1c1abf94ee5b295352c7f709.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/f41f8898ae8d88abfaad37af6ae3993a">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/e8589f82b49c5d712d21256477ee354c.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/849e9afbd5e53836367745f1ae7e09a5">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/e0f27aa764650d290355d0b930830cec.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/74195a1d1a1984c79a9cece5180064fc.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/2ba5d1612e896600f0245d6fe3cf55e1.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/1c44deacfe847a6935b3b8d4a7b93a04.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/3552a2ac5711ee6e99962a2f171332b0.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/f67a21e2662edf08c260c1cbce52fa31.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/048981f8149a8836d612e3ff1952f07e">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/6637487168e8ae745655e04f63f726d0.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/fd61ba95a601ed1681e18c3453d1747e.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/b8853af62e568ed0010d23a77d372360">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/5c317fa91f61662c9313ae23fc24c743">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/a3072951abba7a814f37b46f26753f72.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/f1facde3ce5b7ba68857754fe094ef65.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/5c317fa91f61662c9313ae23fc24c743">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/b7eb1aeef225fdfb5ed76371606b99a1.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/d7e4a31006464c3004407f1a29766092.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/de3e03a16070d32f02b88e860609fc9d">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/c3430433302aaaa20d1acf3d93ee7fca">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/317dc68116a605a7471652a0d17302de.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/eb02ca7ee2a7eb26b4a7748bd84232e2">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/3fed820eb78e9d1c5f296871af915648">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/a32c3d2dba32d51a7b007df50af3e88b.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/7f74692aba736da5cdb40c12e6be94ef">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/c80b8a2c8461db552a5a4344890304b3.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/343a695ff477b38815df891afe2c0106.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/04cc1a8878c6f749b51215173241befd.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/4f5609ad204d16c7c5009b8428b39619.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/7a3e6ed1460e1e61bac46191abe51833">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/20d50fcb6fd8122e0a88b9523a1ad366">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/645063c4a48fff43c8d8a6c2ac573ba3">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/c46e1beb8b1429b6f888386182c2e2b6.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/eb6ab31476f84fe3043528ee07f753c9">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/c3d8814cbaaa7c516ad5a6edd3e05dab">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/545a0a8c2986ffc8c647209eb27c901a">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/20d50fcb6fd8122e0a88b9523a1ad366">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/wechat-e7cc39b856533cdc49437c7235aa3a12525480633f79fb7d9164005112ae4d90.svg">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/pay-success-9d4074188ff3710b3587bf93ef297b98d647346b7f25f918be77ad1a6aa531c4.png">
<meta property="og:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/wechat-e7cc39b856533cdc49437c7235aa3a12525480633f79fb7d9164005112ae4d90.svg">
<meta property="og:updated_time" content="2019-01-25T16:03:10.106Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大前端之路">
<meta name="twitter:description" content="Python 简单入门指北 － 小专栏                                                 MathJax.Hub.Config({ tex2jax: { inlineMath: [[&apos;$&apos;,&apos;$&apos;], [&quot;\\(&quot;,&quot;\\)&quot;]], displayMath: [ [&apos;$$&apos;,&apos;$$&apos;">
<meta name="twitter:image" content="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python%20简单入门指北%20－%20小专栏/share_logo-a15dd98a7d6b22923eb2eea3c246043ad69ebeec10682ddabc27854620f2cb9c.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: 'lvchenqiang.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/"/>





  <title> | 大前端之路</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  

  <div class="container  page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="lvchenqiang.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大前端之路</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="lvchenqiang.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="lvchenqiang.github.io/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="lvchenqiang.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="lvchenqiang.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="lvchenqiang.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lvchenqiang.github.iolvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Micah">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="lvchenqiang.github.io/image/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大前端之路">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-26T00:03:10+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!DOCTYPE html>
<!-- saved from url=(0052)https://xiaozhuanlan.com/topic/1053427869#section313 -->
<html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="shortcut icon" type="image/x-icon" href="https://diycode.b0.upaiyun.com/assets/favicon-bd135558698197f509ada06695c03a4f458f0077fa476f9a4e7ba9664f3dc55f.ico">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
  <meta name="apple-mobile-web-app-capable" content="no">
  <meta content="True" name="HandheldFriendly">
    <meta http-equiv="X-Frame-Options" content="ALLOW-FROM https://www.bilibili.com">  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>
    Python 简单入门指北 － 小专栏
  </title>
  <meta name="keywords" content="">
  <meta name="description" content="从 iOS 到全栈 - @张星宇 - [TOC]  Python 是一门非常容易上手的语言，通过查阅资料和教程，也许一晚上就能写出一个简单的爬虫。但 Python 也是一门很难精通的语言，因为简洁的语法背后隐藏了许多黑科技。本文主要针对的读者是：  ...">
  <link rel="stylesheet" media="screen" href="./Python 简单入门指北 － 小专栏_files/application-f734c62f1bbd70be618525ecbb2c33b87f167b531ce866a302f1e2283655defe.css">
  <link rel="stylesheet" media="screen" href="./Python 简单入门指北 － 小专栏_files/base-2b98779741767449024e9452dec1c559566c0fc6b0b91903e25fd401bd554e60.css">
  <script src="./Python 简单入门指北 － 小专栏_files/hm.js"></script><script async src="./Python 简单入门指北 － 小专栏_files/analytics.js"></script><script src="./Python 简单入门指北 － 小专栏_files/application-ed0aff321b36d914f613fdade2812da4d24ef9f35ce57e93d74e4426f5128557.js"></script>
  <script src="./Python 简单入门指北 － 小专栏_files/showdown_toc-ebb63501ea44121d364fd5bbf368e6680552896b0b1250218e5bfcd6c6e75fac.js"></script>
  <script src="./Python 简单入门指北 － 小专栏_files/flowchart-e67c581916393cef0114623cdb6386ae4d590f549b3a4fe6d4a5b65930200f67.js"></script>
  <script src="./Python 简单入门指北 － 小专栏_files/mermaid-87c4a8b71bd9cec95ceb3601f3c343505dcd851ccf412682982e9d530887eaca.js"></script>


  <meta name="action-cable-url" content="/cable">
    <script src="./Python 简单入门指北 － 小专栏_files/MathJax.js"></script>
    <script type="text/x-mathjax-config;executed=true">
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true }, TeX: { equationNumbers: { autoNumber: "AMS" } }, messageStyle: "none", SVG: { blacker: 1 }});
    </script>
    <link rel="dns-prefetch" href="https://cdn.bootcss.com/">
    <link rel="dns-prefetch" href="https://cdn.mathjax.org/">
    <script src="./Python 简单入门指北 － 小专栏_files/raphael-73fc121fcba5dc93ab67fbe3a44329411937f2f432ec705a3e2c337ad2d4d576.js"></script>
<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><script type="text/javascript">
function rtcScript() {
    document.oncontextmenu = null;
    document.onselectstart = null;
    document.onmousedown = null;
    document.onclick = null;
    document.oncopy = null;
    document.oncut = null;
    var elements = document.getElementsByTagName('*');
    for (var i = 0; i < elements.length; i++) {
        elements[i].oncontextmenu = null;
        elements[i].onselectstart = null;
        elements[i].onmousedown = null;
        elements[i].oncopy = null;
        elements[i].oncut = null;
    }
    function preventShareThis() {
        document.getSelection = window.getSelection = function() {
            return {isCollapsed: true};
        }
    }
    var scripts = document.getElementsByTagName('script');
    for (var i = 0; i < scripts.length; i++) {
        if (scripts[i].src.indexOf('w.sharethis.com') > -1) {
            preventShareThis();
        }
    }
    if (typeof Tynt != 'undefined') {
        Tynt = null;
    }
}
rtcScript();
setInterval(rtcScript, 2000);</script><style>
* {
    -webkit-user-select: auto !important; /* injected by RightToCopy */
}</style></head>
<body data-current-user-id="49218" class="  "><div id="MathJax_Message" style="display: none;"></div>
  <script type="text/javascript">
    $(window).unbind('scroll');
  </script>

  <div class="xzl-site-main " id="container" data-page-title="Python 简单入门指北 － 小专栏" data-page-description="[TOC]  Python 是一门非常容易上手的语言，通过查阅资料和教程，也许一晚上就能写出一个简单的爬虫。但 Pytho">
    <img class="share_page_img hidden" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/share_logo-a15dd98a7d6b22923eb2eea3c246043ad69ebeec10682ddabc27854620f2cb9c.png" alt="Share logo">
    <div class="xzl-main-container">
        <div class="xzl-metabar-wrapper  ">
          <div class="metabar">
            <a href="https://xiaozhuanlan.com/" ,="" class="xzl-logo-link" target="_blank" rel="noopener">
                <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="142px" height="52px" viewbox="0 0 142 52" version="1.1" class="xzl-logo">
    <!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
        <path d="M63.853,17.315 L65.037,17.315 C65.222,17.315 65.347,17.505 65.276,17.676 L59.733,30.84 C59.692,30.938 59.597,30.999 59.493,30.999 L58.311,30.999 C58.126,30.999 58,30.811 58.071,30.639 L63.614,17.473 C63.654,17.378 63.75,17.315 63.853,17.315 Z M76.879,17.315 L78.072,17.315 C78.175,17.315 78.268,17.374 78.31,17.47 L84.519,31.44 C84.595,31.612 84.469,31.804 84.281,31.804 L83.088,31.804 C82.986,31.804 82.892,31.744 82.851,31.651 L76.642,17.68 C76.567,17.508 76.693,17.315 76.879,17.315 Z M116.445,21.341 L117.548,21.341 C117.708,21.341 117.83,21.482 117.804,21.64 L116.306,31.316 C116.287,31.443 116.177,31.536 116.051,31.536 L114.946,31.536 C114.788,31.536 114.666,31.395 114.69,31.236 L116.188,21.56 C116.208,21.433 116.317,21.341 116.445,21.341 Z M136.192,11.948 L137.386,11.948 C137.572,11.948 137.698,12.142 137.623,12.314 L135.265,17.622 C135.188,17.794 135.314,17.987 135.501,17.987 L139.625,17.987 C139.77,17.987 139.887,18.103 139.887,18.248 L139.887,19.337 C139.887,19.48 139.77,19.596 139.625,19.596 L125.583,19.596 C125.439,19.596 125.323,19.48 125.323,19.337 L125.323,18.248 C125.323,18.103 125.439,17.987 125.583,17.987 L128.527,17.987 C128.717,17.987 128.843,17.794 128.766,17.622 L126.533,12.598 C126.456,12.425 126.582,12.232 126.772,12.232 L127.963,12.232 C128.065,12.232 128.158,12.294 128.201,12.387 L130.621,17.832 C130.662,17.927 130.757,17.987 130.859,17.987 L133.17,17.987 C133.273,17.987 133.367,17.927 133.408,17.832 L135.954,12.102 C135.996,12.008 136.09,11.948 136.192,11.948 Z M126.658,26.037 L138.552,26.037 C138.696,26.037 138.811,26.154 138.811,26.297 L138.811,27.387 C138.811,27.531 138.696,27.648 138.552,27.648 L126.658,27.648 C126.513,27.648 126.397,27.531 126.397,27.387 L126.397,26.297 C126.397,26.154 126.513,26.037 126.658,26.037 Z M124.271,35.566 L140.94,35.566 C141.082,35.566 141.199,35.682 141.199,35.827 L141.199,36.917 C141.199,37.06 141.082,37.178 140.94,37.178 L124.271,37.178 C124.126,37.178 124.01,37.06 124.01,36.917 L124.01,35.827 C124.01,35.682 124.126,35.566 124.271,35.566 Z M96.934,11.411 L98.027,11.411 C98.167,11.411 98.283,11.522 98.286,11.662 C98.308,12.369 98.3,13.664 98.102,15.278 C98.082,15.432 98.203,15.572 98.358,15.572 L109.382,15.572 C109.525,15.572 109.642,15.689 109.642,15.831 L109.642,16.921 C109.642,17.066 109.525,17.182 109.382,17.182 L98.005,17.182 C97.881,17.182 97.776,17.267 97.75,17.386 C97.537,18.404 97.241,19.485 96.837,20.586 C96.776,20.757 96.898,20.938 97.079,20.938 L110.992,20.938 C111.136,20.938 111.252,21.054 111.252,21.199 L111.252,22.287 C111.252,22.431 111.136,22.548 110.992,22.548 L96.162,22.548 C96.066,22.548 95.977,22.603 95.933,22.691 C95.344,23.87 94.609,25.039 93.695,26.145 C93.555,26.316 93.67,26.574 93.893,26.574 L107.661,26.574 C107.805,26.574 107.92,26.69 107.92,26.832 L107.92,28.181 L107.921,28.182 L107.92,28.182 L107.919,28.182 L100.642,33.953 C100.477,34.085 100.527,34.347 100.731,34.408 L105.856,35.898 C105.966,35.93 106.042,36.033 106.042,36.148 L106.042,37.283 C106.042,37.456 105.875,37.581 105.71,37.533 L89.324,32.765 C89.213,32.734 89.138,32.632 89.138,32.518 L89.138,31.381 C89.138,31.207 89.304,31.083 89.471,31.132 L98.223,33.678 C98.304,33.702 98.391,33.684 98.456,33.632 L104.743,28.649 C104.936,28.495 104.827,28.182 104.581,28.182 L91.349,28.182 C91.204,28.182 91.087,28.067 91.087,27.922 L91.087,26.684 C91.087,26.613 91.118,26.545 91.168,26.497 C92.319,25.406 93.232,24.19 93.954,22.936 C94.054,22.763 93.925,22.548 93.727,22.548 L85.909,22.548 C85.766,22.548 85.649,22.431 85.649,22.287 L85.649,21.199 C85.649,21.054 85.766,20.938 85.909,20.938 L94.772,20.938 C94.876,20.938 94.974,20.873 95.014,20.776 C95.474,19.658 95.808,18.547 96.05,17.498 C96.089,17.336 95.963,17.182 95.795,17.182 L87.251,17.182 C87.107,17.182 86.99,17.066 86.99,16.921 L86.99,15.831 C86.99,15.689 87.107,15.572 87.251,15.572 L96.188,15.572 C96.318,15.572 96.43,15.473 96.447,15.346 C96.677,13.675 96.689,12.341 96.673,11.675 C96.669,11.53 96.786,11.411 96.934,11.411 Z M70.608,11.949 L71.697,11.949 C71.84,11.949 71.957,12.065 71.957,12.207 L71.957,37.449 C71.957,37.592 71.84,37.708 71.697,37.708 L65.672,37.708 C65.559,37.708 65.457,37.633 65.424,37.525 L65.09,36.435 C65.038,36.268 65.164,36.099 65.339,36.099 L70.087,36.099 C70.231,36.099 70.347,35.982 70.347,35.838 L70.347,12.207 C70.347,12.065 70.463,11.949 70.608,11.949 Z M118.948,11.277 L120.038,11.277 C120.182,11.277 120.298,11.395 120.298,11.537 L120.298,17.727 C120.298,17.87 120.414,17.988 120.558,17.988 L124.063,17.988 C124.205,17.988 124.322,18.104 124.322,18.246 L124.322,19.336 C124.322,19.481 124.205,19.596 124.063,19.596 L120.558,19.596 C120.414,19.596 120.298,19.713 120.298,19.858 L120.298,23.762 C120.298,23.907 120.414,24.024 120.558,24.024 L121.787,24.024 C121.899,24.024 121.997,24.093 122.033,24.198 L123.447,28.24 C123.506,28.409 123.38,28.585 123.202,28.585 L122.047,28.585 C121.937,28.585 121.838,28.514 121.802,28.41 L120.804,25.557 C120.706,25.281 120.298,25.351 120.298,25.644 L120.298,37.452 C120.298,37.596 120.182,37.712 120.038,37.712 L118.948,37.712 C118.805,37.712 118.688,37.596 118.688,37.452 L118.688,19.858 C118.688,19.713 118.57,19.596 118.428,19.596 L114.851,19.596 C114.706,19.596 114.59,19.481 114.59,19.336 L114.59,18.246 C114.59,18.104 114.706,17.988 114.851,17.988 L118.428,17.988 C118.57,17.988 118.688,17.87 118.688,17.727 L118.688,11.537 C118.688,11.395 118.805,11.277 118.948,11.277 Z" id="path-1"/>
        <path d="M18.711,9.071 C19.106,10.111 20.102,11.444 22.769,13.171 L23.068,11.827 C23.068,11.827 21.011,10.363 19.935,9.48 C19.669,9.263 19.436,9.009 19.212,8.749 C19.036,8.544 18.881,8.447 18.774,8.447 C18.611,8.447 18.559,8.671 18.711,9.071 Z" id="path-3"/>
        <path d="M20.313,2.529 C20.703,3.198 21.096,3.936 21.29,4.477 C23.194,8.311 23.084,13.771 20.707,18.114 C19.094,21.059 16.699,22.992 14.136,23.417 C13.487,23.524 11.778,23.549 10.412,23.063 C8.977,22.55 7.894,21.522 7.627,21.496 C6.994,21.438 7.718,22.547 7.862,22.681 C9.374,24.074 11.2,24.807 13.105,24.807 C13.516,24.807 13.93,24.773 14.345,24.704 C17.303,24.214 20.033,22.042 21.839,18.744 C24.745,13.437 24.509,6.546 21.523,2.335 C21.426,2.198 21.244,2.04 21.022,1.88 C20.93,1.812 20.831,1.783 20.737,1.783 C20.395,1.783 20.104,2.169 20.313,2.529 Z" id="path-5"/>
        <path d="M20.313,2.529 C20.703,3.198 21.096,3.936 21.29,4.477 C23.194,8.311 23.084,13.771 20.707,18.114 C19.094,21.059 16.699,22.992 14.136,23.417 C13.487,23.524 11.778,23.549 10.412,23.063 C8.977,22.55 7.894,21.522 7.627,21.496 C6.994,21.438 7.718,22.547 7.862,22.681 C9.374,24.074 11.2,24.807 13.105,24.807 C13.516,24.807 13.93,24.773 14.345,24.704 C17.303,24.214 20.033,22.042 21.839,18.744 C24.745,13.437 24.509,6.546 21.523,2.335 C21.426,2.198 21.244,2.04 21.022,1.88 C20.929,1.812 20.831,1.783 20.737,1.783 C20.395,1.783 20.104,2.169 20.313,2.529 Z" id="path-7"/>
    </defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Group-2">
            <mask id="mask-2" fill="white">
                <use xlink:href="#path-1"/>
            </mask>
            <use id="Combined-Shape" fill="#000000" xlink:href="#path-1"/>
            <g id="Group">
                <g id="Group-33" fill="#FF7055" fill-rule="nonzero">
                    <g id="Group-30">
                        <g id="Fill-28-Clipped">
                            <path d="M25.6312,0.4948 C11.4762,0.4948 0.0002,11.9708 0.0002,26.1258 C0.0002,40.2818 11.4762,51.7578 25.6312,51.7578 C39.7862,51.7578 51.2622,40.2818 51.2622,26.1258 C51.2622,11.9708 39.7862,0.4948 25.6312,0.4948" id="Fill-28"/>
                        </g>
                    </g>
                </g>
                <g id="Group-79" transform="translate(9.000000, 8.000000)">
                    <path d="M6.9651,20.0329 C5.6871,19.6579 4.9661,18.2619 4.9661,18.2619 C4.9661,18.2619 6.3181,17.4729 7.5951,17.8479 C8.8731,18.2219 9.5941,19.6189 9.5941,19.6189 C9.5941,19.6189 8.2421,20.4069 6.9651,20.0329" id="Fill-61" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M3.5228,24.4753 C1.6958,24.6443 0.0788,23.2193 0.0788,23.2193 C0.0788,23.2193 1.4238,21.5223 3.2518,21.3543 C5.0798,21.1863 6.6968,22.6103 6.6968,22.6103 C6.6968,22.6103 5.3508,24.3073 3.5228,24.4753" id="Fill-63" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M10.9163,16.5945 C10.8953,15.0275 12.1953,13.7405 12.1953,13.7405 C12.1953,13.7405 13.5293,14.9935 13.5503,16.5595 C13.5703,18.1265 12.2703,19.4135 12.2703,19.4135 C12.2703,19.4135 10.9373,18.1605 10.9163,16.5945" id="Fill-65" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M28.6907,2.739 C30.4657,1.844 32.6517,2.628 32.6517,2.628 C32.6517,2.628 31.9587,4.859 30.1827,5.754 C28.4067,6.647 26.2207,5.864 26.2207,5.864 C26.2207,5.864 26.9157,3.633 28.6907,2.739" id="Fill-67" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M26.9378,11.6433 C28.5038,11.3053 30.0558,12.3623 30.0558,12.3623 C30.0558,12.3623 29.0678,13.9643 27.5008,14.3023 C25.9338,14.6393 24.3818,13.5823 24.3818,13.5823 C24.3818,13.5823 25.3708,11.9803 26.9378,11.6433" id="Fill-69" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M23.928,2.3777 C23.848,1.1497 24.808,0.0887 24.808,0.0887 C24.808,0.0887 25.898,1.0167 25.977,2.2437 C26.057,3.4707 25.096,4.5327 25.096,4.5327 C25.096,4.5327 24.007,3.6057 23.928,2.3777" id="Fill-71" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M16.0335,10.9714 C14.6945,10.9914 13.5925,9.8714 13.5925,9.8714 C13.5925,9.8714 14.6625,8.7184 16.0015,8.6984 C17.3405,8.6774 18.4415,9.7974 18.4415,9.7974 C18.4415,9.7974 17.3725,10.9504 16.0335,10.9714" id="Fill-73" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M18.848,3.9167 C20.302,5.2777 20.343,7.6157 20.343,7.6157 C20.343,7.6157 18.027,7.7457 16.573,6.3847 C15.119,5.0217 15.078,2.6847 15.078,2.6847 C15.078,2.6847 17.395,2.5547 18.848,3.9167" id="Fill-75" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M17.4056,26.1599 C17.0536,26.1219 16.7946,25.7549 16.8266,25.3379 C16.8586,24.9209 17.1696,24.6139 17.5216,24.6509 C17.8736,24.6899 18.1336,25.0569 18.1006,25.4739 C18.0696,25.8909 17.7586,26.1979 17.4056,26.1599 M26.9366,18.5649 C25.4776,18.9089 23.4266,20.1609 21.3996,21.1429 C15.9116,23.7999 9.1106,28.5629 8.4266,29.0139 C8.0876,29.2369 8.0266,29.7119 8.3016,30.0129 C8.5896,30.3269 8.6716,30.4609 9.3636,31.2509 C10.4076,32.3519 11.1966,32.6629 12.5836,32.4949 C14.2286,32.2429 15.9756,31.2309 17.0856,31.3559 C17.0856,31.3559 20.3476,31.5449 21.0206,30.4569 C21.0206,30.4569 24.1586,33.1929 24.0586,39.1099 C24.0536,39.3799 24.0376,39.8499 24.0186,40.1339 C24.0746,37.1389 23.0896,33.3719 21.0286,31.0539 C20.6396,31.3379 19.4136,32.0339 17.1506,31.7389 C18.1166,37.1729 16.5736,42.1859 15.5676,43.7299 C15.6156,43.7319 15.6636,43.7319 15.7126,43.7339 C15.7416,43.7289 15.7686,43.7369 15.7986,43.7359 C16.0756,43.7449 16.3506,43.7569 16.6316,43.7569 C21.4036,43.7569 25.8676,42.4489 29.6936,40.1779 C29.7256,40.1569 29.7566,40.1359 29.7886,40.1159 C28.2326,33.0689 22.6596,23.6149 22.6596,23.6149 C27.7516,23.7409 26.9366,18.5649 26.9366,18.5649" id="Fill-77" fill="#FFFFFF" fill-rule="nonzero"/>
                    <path d="M12.081,20.345 C13.342,21.638 15.197,22.638 17.096,22.638 C17.559,22.638 18.026,22.579 18.487,22.449 C18.806,22.359 19.881,21.518 19.719,21.198 C19.557,20.876 19.166,20.749 18.849,20.913 C16.837,21.947 14.165,20.883 12.505,20.042 C12.427,20.003 12.346,19.985 12.274,19.985 C12.048,19.985 11.892,20.151 12.081,20.345 Z" id="path-25" fill="#FFFFFF"/>
                    <path d="M25.375,5.067 C24.811,5.919 23.959,7.365 22.961,8.068 L23.107,9.391 C24.429,8.533 25.288,6.684 25.779,5.271 C25.838,5.099 25.7,4.964 25.558,4.964 C25.49,4.964 25.422,4.995 25.375,5.067 Z" id="path-27"/>
                    <path d="M25.375,5.067 C24.811,5.919 23.959,7.365 22.961,8.068 L23.107,9.391 C24.429,8.533 25.288,6.684 25.779,5.271 C25.838,5.099 25.699,4.964 25.558,4.964 C25.491,4.964 25.422,4.995 25.375,5.067 Z" id="path-29" fill="#FFFFFF"/>
                    <path d="M18.711,9.071 C19.106,10.111 20.102,11.444 22.769,13.171 L23.068,11.827 C23.068,11.827 21.011,10.363 19.935,9.48 C19.669,9.263 19.436,9.009 19.212,8.749 C19.036,8.543 18.881,8.447 18.774,8.447 C18.611,8.447 18.559,8.671 18.711,9.071 Z" id="path-31" fill="#FFFFFF"/>
                    <mask id="mask-4" fill="white">
                        <use xlink:href="#path-3"/>
                    </mask>
                    <g id="path-33">
                    <mask id="mask-6" fill="white">
                        <use xlink:href="#path-5"/>
                    </mask>
                    <g id="path-23">
                    <path d="M21.0218,1.8796 C20.5938,1.5676 20.0458,2.0686 20.3128,2.5286 C20.7028,3.1976 21.0958,3.9366 21.2898,4.4766 C23.1938,8.3116 23.0848,13.7716 20.7078,18.1136 C19.0938,21.0596 16.6998,22.9916 14.1358,23.4166 C13.4878,23.5246 11.7788,23.5496 10.4128,23.0636 C8.9778,22.5506 7.8938,21.5216 7.6258,21.4966 C6.9938,21.4386 7.7178,22.5466 7.8628,22.6806 C9.3738,24.0736 11.1998,24.8076 13.1048,24.8076 C13.5158,24.8076 13.9298,24.7736 14.3448,24.7036 C17.3018,24.2146 20.0338,22.0416 21.8388,18.7436 C24.7458,13.4376 24.5088,6.5456 21.5228,2.3346 C21.4258,2.1976 21.2438,2.0396 21.0218,1.8796" id="Fill-31" fill="#FFFFFF" fill-rule="nonzero" mask="url(#mask-6)"/>
                    <mask id="mask-8" fill="white">
                        <use xlink:href="#path-7"/>
                    </mask>
                    <g id="path-21">
                </g>
            </g>
        </g>
    </g>
</g></g></g></title></svg>

            </a>

            <div class="metabar-inner">
              <div class="u-clearfix u-relative">
                <div class="xzl-header-body">
                  <a href="https://xiaozhuanlan.com/" ,="" class="xzl-logo-link" target="_blank" rel="noopener">
                      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="142px" height="52px" viewbox="0 0 142 52" version="1.1" class="xzl-logo">
    <!-- Generator: Sketch 50.2 (55047) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
        <path d="M63.853,17.315 L65.037,17.315 C65.222,17.315 65.347,17.505 65.276,17.676 L59.733,30.84 C59.692,30.938 59.597,30.999 59.493,30.999 L58.311,30.999 C58.126,30.999 58,30.811 58.071,30.639 L63.614,17.473 C63.654,17.378 63.75,17.315 63.853,17.315 Z M76.879,17.315 L78.072,17.315 C78.175,17.315 78.268,17.374 78.31,17.47 L84.519,31.44 C84.595,31.612 84.469,31.804 84.281,31.804 L83.088,31.804 C82.986,31.804 82.892,31.744 82.851,31.651 L76.642,17.68 C76.567,17.508 76.693,17.315 76.879,17.315 Z M116.445,21.341 L117.548,21.341 C117.708,21.341 117.83,21.482 117.804,21.64 L116.306,31.316 C116.287,31.443 116.177,31.536 116.051,31.536 L114.946,31.536 C114.788,31.536 114.666,31.395 114.69,31.236 L116.188,21.56 C116.208,21.433 116.317,21.341 116.445,21.341 Z M136.192,11.948 L137.386,11.948 C137.572,11.948 137.698,12.142 137.623,12.314 L135.265,17.622 C135.188,17.794 135.314,17.987 135.501,17.987 L139.625,17.987 C139.77,17.987 139.887,18.103 139.887,18.248 L139.887,19.337 C139.887,19.48 139.77,19.596 139.625,19.596 L125.583,19.596 C125.439,19.596 125.323,19.48 125.323,19.337 L125.323,18.248 C125.323,18.103 125.439,17.987 125.583,17.987 L128.527,17.987 C128.717,17.987 128.843,17.794 128.766,17.622 L126.533,12.598 C126.456,12.425 126.582,12.232 126.772,12.232 L127.963,12.232 C128.065,12.232 128.158,12.294 128.201,12.387 L130.621,17.832 C130.662,17.927 130.757,17.987 130.859,17.987 L133.17,17.987 C133.273,17.987 133.367,17.927 133.408,17.832 L135.954,12.102 C135.996,12.008 136.09,11.948 136.192,11.948 Z M126.658,26.037 L138.552,26.037 C138.696,26.037 138.811,26.154 138.811,26.297 L138.811,27.387 C138.811,27.531 138.696,27.648 138.552,27.648 L126.658,27.648 C126.513,27.648 126.397,27.531 126.397,27.387 L126.397,26.297 C126.397,26.154 126.513,26.037 126.658,26.037 Z M124.271,35.566 L140.94,35.566 C141.082,35.566 141.199,35.682 141.199,35.827 L141.199,36.917 C141.199,37.06 141.082,37.178 140.94,37.178 L124.271,37.178 C124.126,37.178 124.01,37.06 124.01,36.917 L124.01,35.827 C124.01,35.682 124.126,35.566 124.271,35.566 Z M96.934,11.411 L98.027,11.411 C98.167,11.411 98.283,11.522 98.286,11.662 C98.308,12.369 98.3,13.664 98.102,15.278 C98.082,15.432 98.203,15.572 98.358,15.572 L109.382,15.572 C109.525,15.572 109.642,15.689 109.642,15.831 L109.642,16.921 C109.642,17.066 109.525,17.182 109.382,17.182 L98.005,17.182 C97.881,17.182 97.776,17.267 97.75,17.386 C97.537,18.404 97.241,19.485 96.837,20.586 C96.776,20.757 96.898,20.938 97.079,20.938 L110.992,20.938 C111.136,20.938 111.252,21.054 111.252,21.199 L111.252,22.287 C111.252,22.431 111.136,22.548 110.992,22.548 L96.162,22.548 C96.066,22.548 95.977,22.603 95.933,22.691 C95.344,23.87 94.609,25.039 93.695,26.145 C93.555,26.316 93.67,26.574 93.893,26.574 L107.661,26.574 C107.805,26.574 107.92,26.69 107.92,26.832 L107.92,28.181 L107.921,28.182 L107.92,28.182 L107.919,28.182 L100.642,33.953 C100.477,34.085 100.527,34.347 100.731,34.408 L105.856,35.898 C105.966,35.93 106.042,36.033 106.042,36.148 L106.042,37.283 C106.042,37.456 105.875,37.581 105.71,37.533 L89.324,32.765 C89.213,32.734 89.138,32.632 89.138,32.518 L89.138,31.381 C89.138,31.207 89.304,31.083 89.471,31.132 L98.223,33.678 C98.304,33.702 98.391,33.684 98.456,33.632 L104.743,28.649 C104.936,28.495 104.827,28.182 104.581,28.182 L91.349,28.182 C91.204,28.182 91.087,28.067 91.087,27.922 L91.087,26.684 C91.087,26.613 91.118,26.545 91.168,26.497 C92.319,25.406 93.232,24.19 93.954,22.936 C94.054,22.763 93.925,22.548 93.727,22.548 L85.909,22.548 C85.766,22.548 85.649,22.431 85.649,22.287 L85.649,21.199 C85.649,21.054 85.766,20.938 85.909,20.938 L94.772,20.938 C94.876,20.938 94.974,20.873 95.014,20.776 C95.474,19.658 95.808,18.547 96.05,17.498 C96.089,17.336 95.963,17.182 95.795,17.182 L87.251,17.182 C87.107,17.182 86.99,17.066 86.99,16.921 L86.99,15.831 C86.99,15.689 87.107,15.572 87.251,15.572 L96.188,15.572 C96.318,15.572 96.43,15.473 96.447,15.346 C96.677,13.675 96.689,12.341 96.673,11.675 C96.669,11.53 96.786,11.411 96.934,11.411 Z M70.608,11.949 L71.697,11.949 C71.84,11.949 71.957,12.065 71.957,12.207 L71.957,37.449 C71.957,37.592 71.84,37.708 71.697,37.708 L65.672,37.708 C65.559,37.708 65.457,37.633 65.424,37.525 L65.09,36.435 C65.038,36.268 65.164,36.099 65.339,36.099 L70.087,36.099 C70.231,36.099 70.347,35.982 70.347,35.838 L70.347,12.207 C70.347,12.065 70.463,11.949 70.608,11.949 Z M118.948,11.277 L120.038,11.277 C120.182,11.277 120.298,11.395 120.298,11.537 L120.298,17.727 C120.298,17.87 120.414,17.988 120.558,17.988 L124.063,17.988 C124.205,17.988 124.322,18.104 124.322,18.246 L124.322,19.336 C124.322,19.481 124.205,19.596 124.063,19.596 L120.558,19.596 C120.414,19.596 120.298,19.713 120.298,19.858 L120.298,23.762 C120.298,23.907 120.414,24.024 120.558,24.024 L121.787,24.024 C121.899,24.024 121.997,24.093 122.033,24.198 L123.447,28.24 C123.506,28.409 123.38,28.585 123.202,28.585 L122.047,28.585 C121.937,28.585 121.838,28.514 121.802,28.41 L120.804,25.557 C120.706,25.281 120.298,25.351 120.298,25.644 L120.298,37.452 C120.298,37.596 120.182,37.712 120.038,37.712 L118.948,37.712 C118.805,37.712 118.688,37.596 118.688,37.452 L118.688,19.858 C118.688,19.713 118.57,19.596 118.428,19.596 L114.851,19.596 C114.706,19.596 114.59,19.481 114.59,19.336 L114.59,18.246 C114.59,18.104 114.706,17.988 114.851,17.988 L118.428,17.988 C118.57,17.988 118.688,17.87 118.688,17.727 L118.688,11.537 C118.688,11.395 118.805,11.277 118.948,11.277 Z" id="path-1"/>
        <path d="M18.711,9.071 C19.106,10.111 20.102,11.444 22.769,13.171 L23.068,11.827 C23.068,11.827 21.011,10.363 19.935,9.48 C19.669,9.263 19.436,9.009 19.212,8.749 C19.036,8.544 18.881,8.447 18.774,8.447 C18.611,8.447 18.559,8.671 18.711,9.071 Z" id="path-3"/>
        <path d="M20.313,2.529 C20.703,3.198 21.096,3.936 21.29,4.477 C23.194,8.311 23.084,13.771 20.707,18.114 C19.094,21.059 16.699,22.992 14.136,23.417 C13.487,23.524 11.778,23.549 10.412,23.063 C8.977,22.55 7.894,21.522 7.627,21.496 C6.994,21.438 7.718,22.547 7.862,22.681 C9.374,24.074 11.2,24.807 13.105,24.807 C13.516,24.807 13.93,24.773 14.345,24.704 C17.303,24.214 20.033,22.042 21.839,18.744 C24.745,13.437 24.509,6.546 21.523,2.335 C21.426,2.198 21.244,2.04 21.022,1.88 C20.93,1.812 20.831,1.783 20.737,1.783 C20.395,1.783 20.104,2.169 20.313,2.529 Z" id="path-5"/>
        <path d="M20.313,2.529 C20.703,3.198 21.096,3.936 21.29,4.477 C23.194,8.311 23.084,13.771 20.707,18.114 C19.094,21.059 16.699,22.992 14.136,23.417 C13.487,23.524 11.778,23.549 10.412,23.063 C8.977,22.55 7.894,21.522 7.627,21.496 C6.994,21.438 7.718,22.547 7.862,22.681 C9.374,24.074 11.2,24.807 13.105,24.807 C13.516,24.807 13.93,24.773 14.345,24.704 C17.303,24.214 20.033,22.042 21.839,18.744 C24.745,13.437 24.509,6.546 21.523,2.335 C21.426,2.198 21.244,2.04 21.022,1.88 C20.929,1.812 20.831,1.783 20.737,1.783 C20.395,1.783 20.104,2.169 20.313,2.529 Z" id="path-7"/>
    </defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Group-2">
            <mask id="mask-2" fill="white">
                <use xlink:href="#path-1"/>
            </mask>
            <use id="Combined-Shape" fill="#000000" xlink:href="#path-1"/>
            <g id="Group">
                <g id="Group-33" fill="#FF7055" fill-rule="nonzero">
                    <g id="Group-30">
                        <g id="Fill-28-Clipped">
                            <path d="M25.6312,0.4948 C11.4762,0.4948 0.0002,11.9708 0.0002,26.1258 C0.0002,40.2818 11.4762,51.7578 25.6312,51.7578 C39.7862,51.7578 51.2622,40.2818 51.2622,26.1258 C51.2622,11.9708 39.7862,0.4948 25.6312,0.4948" id="Fill-28"/>
                        </g>
                    </g>
                </g>
                <g id="Group-79" transform="translate(9.000000, 8.000000)">
                    <path d="M6.9651,20.0329 C5.6871,19.6579 4.9661,18.2619 4.9661,18.2619 C4.9661,18.2619 6.3181,17.4729 7.5951,17.8479 C8.8731,18.2219 9.5941,19.6189 9.5941,19.6189 C9.5941,19.6189 8.2421,20.4069 6.9651,20.0329" id="Fill-61" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M3.5228,24.4753 C1.6958,24.6443 0.0788,23.2193 0.0788,23.2193 C0.0788,23.2193 1.4238,21.5223 3.2518,21.3543 C5.0798,21.1863 6.6968,22.6103 6.6968,22.6103 C6.6968,22.6103 5.3508,24.3073 3.5228,24.4753" id="Fill-63" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M10.9163,16.5945 C10.8953,15.0275 12.1953,13.7405 12.1953,13.7405 C12.1953,13.7405 13.5293,14.9935 13.5503,16.5595 C13.5703,18.1265 12.2703,19.4135 12.2703,19.4135 C12.2703,19.4135 10.9373,18.1605 10.9163,16.5945" id="Fill-65" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M28.6907,2.739 C30.4657,1.844 32.6517,2.628 32.6517,2.628 C32.6517,2.628 31.9587,4.859 30.1827,5.754 C28.4067,6.647 26.2207,5.864 26.2207,5.864 C26.2207,5.864 26.9157,3.633 28.6907,2.739" id="Fill-67" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M26.9378,11.6433 C28.5038,11.3053 30.0558,12.3623 30.0558,12.3623 C30.0558,12.3623 29.0678,13.9643 27.5008,14.3023 C25.9338,14.6393 24.3818,13.5823 24.3818,13.5823 C24.3818,13.5823 25.3708,11.9803 26.9378,11.6433" id="Fill-69" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M23.928,2.3777 C23.848,1.1497 24.808,0.0887 24.808,0.0887 C24.808,0.0887 25.898,1.0167 25.977,2.2437 C26.057,3.4707 25.096,4.5327 25.096,4.5327 C25.096,4.5327 24.007,3.6057 23.928,2.3777" id="Fill-71" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M16.0335,10.9714 C14.6945,10.9914 13.5925,9.8714 13.5925,9.8714 C13.5925,9.8714 14.6625,8.7184 16.0015,8.6984 C17.3405,8.6774 18.4415,9.7974 18.4415,9.7974 C18.4415,9.7974 17.3725,10.9504 16.0335,10.9714" id="Fill-73" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M18.848,3.9167 C20.302,5.2777 20.343,7.6157 20.343,7.6157 C20.343,7.6157 18.027,7.7457 16.573,6.3847 C15.119,5.0217 15.078,2.6847 15.078,2.6847 C15.078,2.6847 17.395,2.5547 18.848,3.9167" id="Fill-75" fill="#FFFFFF" fill-rule="nonzero" opacity="0.699999988"/>
                    <path d="M17.4056,26.1599 C17.0536,26.1219 16.7946,25.7549 16.8266,25.3379 C16.8586,24.9209 17.1696,24.6139 17.5216,24.6509 C17.8736,24.6899 18.1336,25.0569 18.1006,25.4739 C18.0696,25.8909 17.7586,26.1979 17.4056,26.1599 M26.9366,18.5649 C25.4776,18.9089 23.4266,20.1609 21.3996,21.1429 C15.9116,23.7999 9.1106,28.5629 8.4266,29.0139 C8.0876,29.2369 8.0266,29.7119 8.3016,30.0129 C8.5896,30.3269 8.6716,30.4609 9.3636,31.2509 C10.4076,32.3519 11.1966,32.6629 12.5836,32.4949 C14.2286,32.2429 15.9756,31.2309 17.0856,31.3559 C17.0856,31.3559 20.3476,31.5449 21.0206,30.4569 C21.0206,30.4569 24.1586,33.1929 24.0586,39.1099 C24.0536,39.3799 24.0376,39.8499 24.0186,40.1339 C24.0746,37.1389 23.0896,33.3719 21.0286,31.0539 C20.6396,31.3379 19.4136,32.0339 17.1506,31.7389 C18.1166,37.1729 16.5736,42.1859 15.5676,43.7299 C15.6156,43.7319 15.6636,43.7319 15.7126,43.7339 C15.7416,43.7289 15.7686,43.7369 15.7986,43.7359 C16.0756,43.7449 16.3506,43.7569 16.6316,43.7569 C21.4036,43.7569 25.8676,42.4489 29.6936,40.1779 C29.7256,40.1569 29.7566,40.1359 29.7886,40.1159 C28.2326,33.0689 22.6596,23.6149 22.6596,23.6149 C27.7516,23.7409 26.9366,18.5649 26.9366,18.5649" id="Fill-77" fill="#FFFFFF" fill-rule="nonzero"/>
                    <path d="M12.081,20.345 C13.342,21.638 15.197,22.638 17.096,22.638 C17.559,22.638 18.026,22.579 18.487,22.449 C18.806,22.359 19.881,21.518 19.719,21.198 C19.557,20.876 19.166,20.749 18.849,20.913 C16.837,21.947 14.165,20.883 12.505,20.042 C12.427,20.003 12.346,19.985 12.274,19.985 C12.048,19.985 11.892,20.151 12.081,20.345 Z" id="path-25" fill="#FFFFFF"/>
                    <path d="M25.375,5.067 C24.811,5.919 23.959,7.365 22.961,8.068 L23.107,9.391 C24.429,8.533 25.288,6.684 25.779,5.271 C25.838,5.099 25.7,4.964 25.558,4.964 C25.49,4.964 25.422,4.995 25.375,5.067 Z" id="path-27"/>
                    <path d="M25.375,5.067 C24.811,5.919 23.959,7.365 22.961,8.068 L23.107,9.391 C24.429,8.533 25.288,6.684 25.779,5.271 C25.838,5.099 25.699,4.964 25.558,4.964 C25.491,4.964 25.422,4.995 25.375,5.067 Z" id="path-29" fill="#FFFFFF"/>
                    <path d="M18.711,9.071 C19.106,10.111 20.102,11.444 22.769,13.171 L23.068,11.827 C23.068,11.827 21.011,10.363 19.935,9.48 C19.669,9.263 19.436,9.009 19.212,8.749 C19.036,8.543 18.881,8.447 18.774,8.447 C18.611,8.447 18.559,8.671 18.711,9.071 Z" id="path-31" fill="#FFFFFF"/>
                    <mask id="mask-4" fill="white">
                        <use xlink:href="#path-3"/>
                    </mask>
                    <g id="path-33">
                    <mask id="mask-6" fill="white">
                        <use xlink:href="#path-5"/>
                    </mask>
                    <g id="path-23">
                    <path d="M21.0218,1.8796 C20.5938,1.5676 20.0458,2.0686 20.3128,2.5286 C20.7028,3.1976 21.0958,3.9366 21.2898,4.4766 C23.1938,8.3116 23.0848,13.7716 20.7078,18.1136 C19.0938,21.0596 16.6998,22.9916 14.1358,23.4166 C13.4878,23.5246 11.7788,23.5496 10.4128,23.0636 C8.9778,22.5506 7.8938,21.5216 7.6258,21.4966 C6.9938,21.4386 7.7178,22.5466 7.8628,22.6806 C9.3738,24.0736 11.1998,24.8076 13.1048,24.8076 C13.5158,24.8076 13.9298,24.7736 14.3448,24.7036 C17.3018,24.2146 20.0338,22.0416 21.8388,18.7436 C24.7458,13.4376 24.5088,6.5456 21.5228,2.3346 C21.4258,2.1976 21.2438,2.0396 21.0218,1.8796" id="Fill-31" fill="#FFFFFF" fill-rule="nonzero" mask="url(#mask-6)"/>
                    <mask id="mask-8" fill="white">
                        <use xlink:href="#path-7"/>
                    </mask>
                    <g id="path-21">
                </g>
            </g>
        </g>
    </g>
</g></g></g></title></svg>

                  </a>
                  <div class="xzl-nav-header-center">
  <div class="metabar-block metabar-center xzl-pull-left xzl-nav-header">
    <div class="xzl-button-set ">
      <div class="xzl-header-link zhuanlan-topic-header">
        <a href="https://xiaozhuanlan.com/bestswifter" target="_blank" rel="noopener">
        <img class="xzl-header-zhuanlan-logo" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/de72c2a2887d30c37adc04b0d760166b.png" alt="De72c2a2887d30c37adc04b0d760166b">
</a>        <span class="xzl-zhuanlan-name">
          <a href="https://xiaozhuanlan.com/bestswifter" target="_blank" rel="noopener">从 iOS 到全栈</a></span>
        <button class="button button--small has-subscribed-btn xzl-btn-with-chrome xzl-base-color-normal-btn">
          <span class="button-label  xzl-default-state-btn">
            已经订阅
          </span>
        </button>
      </div>
    </div>
  </div>
</div>
<div class="metabar-block u-float-right  zhualan-header-btn xzl-header-right xzl-nav-header ">
  <div class="xzl-button-set">
    <button class="button link-btn apply-zhuanlan-btn xzl-btn-with-chrome xzl-base-color-normal-btn" data-link-url="/publication/new">
      <span class="button-label  xzl-default-state-btn">
        申请专栏
      </span>
    </button>
    <a class="button  topic-write-btn xzl-btn-with-chrome xzl-red-color-normal-btn" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/new" target="_blank" rel="noopener">
      <span class="button-label  xzl-default-state-btn">
        写文章
      </span>
    </a>
    <div class="xzl-search-div" title="搜索 文章、用户">
      <input class="js-predictiveSearchInput xzl-search-input textInput hidden textInput--darkText u-baseColor--textNormal textInput--transparent" type="search" placeholder="搜索 文章、用户" value="" data-search-type=" " onkeydown="return checkKeyForSearchInput(event)">
      <span class="xzl-search-btn">
        <svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25">
  <path d="M20.067 18.933l-4.157-4.157a6 6 0 1 0-.884.884l4.157 4.157a.624.624 0 1 0 .884-.884zM6.5 11c0-2.62 2.13-4.75 4.75-4.75S16 8.38 16 11s-2.13 4.75-4.75 4.75S6.5 13.62 6.5 11z"/>
  
</svg>

      </span>
    </div>
    <button class="button xzl-primary-btn  xzl-notify-btn button--circle xzl-button-chrome-less is-touchIconBlackPulse is-inSiteNavBar  button--withIcon button--withSvgIcon button--activity js-notificationsButton link-btn is-counter" data-link-url="/notifications">
      <svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 18.666668 21.333332" height="21.333332" width="18.666668" xml:space="preserve" id="svg2" version="1.1" class="notice-icon"><metadata id="metadata8"><rdf:rdf><cc:work rdf:about=""><dc:format>image/svg+xml</dc:format><dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"/></cc:work></rdf:rdf></metadata><defs id="defs6"><clippath id="clipPath20" clippathunits="userSpaceOnUse"><path style="clip-rule:evenodd" id="path18" d="M 79.9531,149.012 C 102.797,144.414 120,124.289 120,99.9766 v -20.336 c 0.684,-1.1093 1.203,-2.2695 1.535,-3.4883 C 128.891,49.418 140,30 140,30 H 0 c 0,0 18.4648,19.3594 18.4648,46.1523 0,2.0118 0.5352,3.8672 1.5352,5.5743 v 18.25 C 20,124.191 37.2383,144.383 60.0469,149.008 60.0156,149.332 60,149.664 60,150 c 0,5.523 4.4766,10 10,10 5.5234,0 10,-4.477 10,-10 0,-0.332 -0.0156,-0.66 -0.0469,-0.988 z"/></clippath><clippath id="clipPath26" clippathunits="userSpaceOnUse"><path id="path24" d="M 0,0 H 140 V 160 H 0 Z"/></clippath><clippath id="clipPath36" clippathunits="userSpaceOnUse"><path style="clip-rule:evenodd" id="path34" d="M 50,20 C 50,8.95313 58.9531,0 70,0 v 0 c 11.0469,0 20,8.95313 20,20"/></clippath><clippath id="clipPath42" clippathunits="userSpaceOnUse"><path id="path40" d="M 0,0 H 140 V 160 H 0 Z"/></clippath></defs><g transform="matrix(1.3333333,0,0,-1.3333333,0,21.333333)" id="g10"><g transform="scale(0.1)" id="g12"><g id="g14"><g clip-path="url(#clipPath20)" id="g16"><g clip-path="url(#clipPath26)" id="g22"><path id="path28" style="fill:none;stroke:#2b2b2c;stroke-width:20;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10;stroke-dasharray:none;stroke-opacity:1" d="M 79.9531,149.012 C 102.797,144.414 120,124.289 120,99.9766 v -20.336 c 0.684,-1.1093 1.203,-2.2695 1.535,-3.4883 C 128.891,49.418 140,30 140,30 H 0 c 0,0 18.4648,19.3594 18.4648,46.1523 0,2.0118 0.5352,3.8672 1.5352,5.5743 v 18.25 C 20,124.191 37.2383,144.383 60.0469,149.008 60.0156,149.332 60,149.664 60,150 c 0,5.523 4.4766,10 10,10 5.5234,0 10,-4.477 10,-10 0,-0.332 -0.0156,-0.66 -0.0469,-0.988 z"/></g></g></g><g id="g30"><g clip-path="url(#clipPath36)" id="g32"><g clip-path="url(#clipPath42)" id="g38"><path id="path44" style="fill:none;stroke:#2b2b2c;stroke-width:20;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10;stroke-dasharray:none;stroke-opacity:1" d="M 50,20 C 50,8.95313 58.9531,0 70,0 v 0 c 11.0469,0 20,8.95313 20,20"/></g></g></g></g></g></svg>

      <span class="notifications-count notifications-count-0">
        </span>
    </button>
    <div class="nav-user-btn">
      <div class="xzl-popover js-popover popover--menu popover--userActions u-resetSpectrum popover--bottom" style="display: none;">
  <div class="popover-inner js-popover-inner">
    <ul role="menu" class="list list--borderless list--short list--large">
      <li class="list-item  profile-list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" href="https://xiaozhuanlan.com/u/6832854225" target="_blank" rel="noopener">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="19px" viewbox="0 0 16 19" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_home</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -272.000000)" id="icon_title_home">
            <g transform="translate(101.000000, 271.000000)">
                <rect id="Rectangle-6" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"/>
                <path d="M2.5,7.05988314 L2.5,18.5481306 L17.5,18.5481306 L17.5,7.05792375 L10.0504226,1.61772806 L2.5,7.05988314 Z" id="Rectangle-5" stroke="#818181"/>
            </g>
        </g>
    </g>
</defs></svg>
</div>
          <span>我的主页</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" href="https://xiaozhuanlan.com/me/publications" target="_blank" rel="noopener">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="20px" viewbox="0 0 16 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_write</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -309.000000)" id="icon_title_write">
            <g transform="translate(101.000000, 309.000000)">
                <rect id="Rectangle-6-Copy-3" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"/>
                <g id="Group-11" transform="translate(3.000000, 1.000000)">
                    <path d="M12.0961903,0.007217431 C12.0950805,0.0840940228 12.0950805,0.0840940228 12.0906395,0.395412629 C12.0850882,0.787332723 12.0850882,0.787332723 12.0784271,1.26720127 C12.0777553,1.31600737 12.0777553,1.31600737 12.0770847,1.36488756 C12.0668478,2.11165141 12.0607067,2.60264713 12.0607067,2.69788938 C12.0607067,6.32194788 12.289768,6.9994991 14.1388632,7.82437955 L14.7391139,8.09215109 L14.3208675,8.59917427 C14.2665361,8.66503806 14.1640261,8.79017314 14.0202307,8.96709441 C13.7802215,9.26239406 13.5126946,9.59453175 13.224549,9.95601411 C12.4013961,10.9886699 11.5783121,12.0490614 10.810665,13.0769552 C10.5999821,13.3590636 10.3960273,13.6353691 10.199511,13.905095 C8.79888518,15.8275065 7.84211607,17.324416 7.50283568,18.1836368 L6.99871818,19.4603042 L6.56357072,18.1585128 C6.31659787,17.4196664 5.27609449,15.8389268 3.69252103,13.7328647 C3.51910808,13.5022353 3.340172,13.2666053 3.1561826,13.026487 C2.38210362,12.0162628 1.55216778,10.9696955 0.722164795,9.94741462 C0.431620618,9.58956318 0.161861606,9.26035845 -0.0801598352,8.96734649 C-0.225186026,8.79176531 -0.32859731,8.66743427 -0.383446471,8.60189193 L-0.81077199,8.09125674 L-0.201226262,7.82328398 C1.66784689,7.00158895 1.88639943,6.41530449 1.87559852,3.22164643 C1.87474274,2.96591436 1.87445639,2.84929113 1.87445639,2.69788938 C1.87445639,2.01038775 1.85698975,0.201713964 1.8415311,0.0510256659 L1.78500307,-0.5 L12.1035127,-0.5 L12.0961903,0.007217431 Z" id="Combined-Shape" stroke="#818181" stroke-linejoin="round"/>
                    <rect id="Rectangle-23" fill="#818181" x="6.5" y="8" width="1" height="10"/>
                    <circle id="Oval-7" fill="#818181" cx="7" cy="8" r="1"/>
                </g>
            </g>
        </g>
    </g>
</defs></svg>
</div>
          <span>我的专栏</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" href="https://xiaozhuanlan.com/me/subscribes" target="_blank" rel="noopener">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="18px" viewbox="0 0 16 18" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_booking</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -348.000000)" id="icon_title_booking">
            <g transform="translate(101.000000, 347.000000)">
                <rect id="Rectangle-6-Copy-4" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"/>
                <g id="Group-10" transform="translate(2.000000, 1.000000)" stroke="#818181">
                    <rect id="Rectangle-24" x="0.5" y="0.5" width="15" height="17" rx="2"/>
                    <path d="M8.5,0.5 L8.5,7.32310369 L11,6.55419486 L13.5,7.32310369 L13.5,0.5 L8.5,0.5 Z" id="icon_mark-copy"/>
                </g>
            </g>
        </g>
    </g>
</defs></svg>
</div>
          <span>我的订阅</span>
        </a>
      </li>
      <li class="list-item list-item--separator list-item--separator-zero">
      </li>
      <li class="list-item topic-list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" href="https://xiaozhuanlan.com/me/topics" tabindex="-1" role="menuitem" target="_blank" rel="noopener">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14px" height="16px" viewbox="0 0 14 16" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_word</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-155.000000, -273.000000)" id="icon_title_word">
            <g transform="translate(152.000000, 271.000000)">
                <rect id="Rectangle-6-Copy-5" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"/>
                <g id="Group-9" transform="translate(3.000000, 2.000000)">
                    <path d="M0.5,0.5 L0.5,15.5 L13.5,15.5 L13.5,3.25704929 L10.8221801,0.5 L0.5,0.5 Z" id="Rectangle-21" stroke="#818181"/>
                    <rect id="Rectangle-22" fill="#818181" x="3" y="4" width="4" height="1"/>
                    <rect id="Rectangle-22-Copy" fill="#818181" x="3" y="7" width="8" height="1"/>
                    <rect id="Rectangle-22-Copy-2" fill="#818181" x="3" y="10" width="8" height="1"/>
                </g>
            </g>
        </g>
    </g>
</defs></svg>
</div>
          <span>我的文章</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" href="https://xiaozhuanlan.com/me/drafts" tabindex="-1" role="menuitem" target="_blank" rel="noopener">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="15px" viewbox="0 0 16 15" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_draft</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-154.000000, -312.000000)" id="icon_title_draft">
            <g transform="translate(152.000000, 309.000000)">
                <rect id="Path" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"/>
                <path d="M2.5,10.6911545 L2.5,15.5863661 C2.5,16.4258256 3.16515947,17.0922852 3.99406028,17.0922852 L16.0059397,17.0922852 C16.8293478,17.0922852 17.5,16.4180516 17.5,15.5863661 L17.5,10.6857048 L14.7177287,3.5 L5.45966255,3.5 L2.5,10.6911545 Z" id="Rectangle-40" stroke="#818181"/>
                <path d="M14,11 L14,12.334029 C14,12.7018346 13.6354685,13 13.2036819,13 L6.79631805,13 C6.35652374,13 6,12.7048931 6,12.334029 L6,11" id="Rectangle-41" stroke="#818181"/>
                <rect id="Rectangle-20" fill="#818181" x="2" y="11" width="4" height="1"/>
                <rect id="Rectangle-20-Copy" fill="#818181" x="14" y="11" width="4" height="1"/>
            </g>
        </g>
    </g>
</defs></svg>
</div>
          <span>我的草稿</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" href="https://xiaozhuanlan.com/me/collections" tabindex="-1" role="menuitem" target="_blank" rel="noopener">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14px" height="18px" viewbox="0 0 14 18" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_mark</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-155.000000, -348.000000)" id="icon_title_mark">
            <g transform="translate(152.000000, 347.000000)">
                <rect id="Rectangle-6-Copy" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"/>
                <path d="M3.5,18.330184 L10,16.4024198 L16.5,18.330184 L16.5,2.99508929 C16.5,2.16960364 15.8266399,1.5 14.9941413,1.5 L5.00585866,1.5 C4.1729829,1.5 3.5,2.16959875 3.5,2.99508929 L3.5,18.330184 Z" id="icon_mark" stroke="#818181"/>
            </g>
        </g>
    </g>
</defs></svg>
</div>
          <span>我的收藏</span>
        </a>
      </li>
      <li class="list-item list-item--dark u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" href="https://xiaozhuanlan.com/wallet" tabindex="-1" role="menuitem" target="_blank" rel="noopener">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="15px" viewbox="0 0 16 15" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_wallet</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-205.000000, -274.000000)" id="icon_title_wallet">
            <g transform="translate(203.000000, 271.000000)">
                <rect id="Rectangle-6-Copy-2" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"/>
                <g id="Group-14" transform="translate(2.000000, 3.000000)">
                    <path d="M15.5,14.5 L15.5,0.5 L1.99406028,0.5 C1.16986472,0.5 0.5,1.16873005 0.5,1.99188419 L0.5,13.0081158 C0.5,13.8309529 1.16940651,14.5 1.99406028,14.5 L15.5,14.5 Z" id="Rectangle-15" stroke="#818181"/>
                    <path d="M15.5,3.5 L15.5,0.5 L1.99406028,0.5 C1.17032001,0.5 0.5,1.17191112 0.5,2 C0.5,2.83350313 1.16628956,3.5 1.99406028,3.5 L15.5,3.5 Z" id="Rectangle-15-Copy" stroke="#818181"/>
                    <path d="M15.5,10.5 L15.5,7.5 L11.0059191,7.5 C10.1667923,7.5 9.5,8.16747386 9.5,9 C9.5,9.83283752 10.1709214,10.5 11.0059191,10.5 L15.5,10.5 Z" id="Rectangle-15-Copy-2" stroke="#818181"/>
                    <rect id="Rectangle-16" fill="#FFFFFF" x="15" y="1" width="1" height="2"/>
                </g>
            </g>
        </g>
    </g>
</defs></svg>
</div>
          <span>我的钱包</span>
        </a>
      </li>
      <li class="list-item list-item--separator list-item--separator-part-one">
      </li>
      <li class="list-item setting-list-item u-padding0">
        <a class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" href="https://xiaozhuanlan.com/me/settings" tabindex="-1" role="menuitem" target="_blank" rel="noopener">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="19px" viewbox="0 0 16 19" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_setting</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-205.000000, -309.000000)" id="icon_title_setting">
            <g transform="translate(203.000000, 309.000000)">
                <rect id="Rectangle-6-Copy-7" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"/>
                <g id="Group-15" transform="translate(2.000000, 0.000000)" stroke="#818181">
                    <path d="M7.86121593,1.42264973 L0.5,5.67264973 L0.5,14.1726497 L7.86121593,18.4226497 L15.2224319,14.1726497 L15.2224319,5.67264973 L7.86121593,1.42264973 Z" id="Polygon"/>
                    <circle id="Oval-14" cx="8" cy="10" r="2.5"/>
                </g>
            </g>
        </g>
    </g>
</defs></svg>
</div>
          <span>设置</span>
        </a>
      </li>

      <li class="list-item u-padding0">
        <a href="https://xiaozhuanlan.com/account/sign_out" class="button--dark xzl-button-chrome-less u-baseColor--buttonDark" data-method="delete" target="_blank" rel="noopener">
          <div class="icon"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="15px" viewbox="0 0 18 15" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>icon_title_quit</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-205.000000, -350.000000)" id="icon_title_quit">
            <g transform="translate(203.000000, 347.000000)">
                <rect id="Rectangle-6-Copy-2" fill="#FF0000" opacity="0" x="0" y="0" width="20" height="20"/>
                <g id="Group-16" transform="translate(2.000000, 3.000000)" stroke="#818181">
                    <polyline id="Rectangle-19" transform="translate(12.000000, 7.535534) rotate(-45.000000) translate(-12.000000, -7.535534) " points="15.2071068 4.32842712 15.2071068 10.7426407 8.79289322 10.7426407"/>
                    <rect id="Rectangle-18" x="5.5" y="7.5" width="10" height="1"/>
                    <path d="M8.5,14.5 L8.5,0.5 L0.5,0.5 L0.5,14.5 L8.5,14.5 Z" id="Rectangle-39"/>
                </g>
            </g>
        </g>
    </g>
</defs></svg>
</div>
          <span>退出</span>
        </a>
      </li>
    </ul>
  </div>
  <div class="popover-arrow">
  </div>
</div>

<script type="text/javascript">
  $(".nav-user-btn").click(function(e){
    $(".xzl-invite-card").hide()
    if($(".popover--userActions").hasClass("is-active")){
      //$(this).css("background-color","rgba(255,255,255,0)")
      $(".popover--userActions").removeClass("is-active")
    }else{
      //$(this).css("background-color","rgba(245,245,245,1)")
      $(".popover--userActions").addClass("is-active")
      $(".popover--userActions").show()
    }
    e.stopPropagation()
  })

  $(".xzl-popover").off("click").click(function(e){
    e.stopPropagation()
  })
  $(window).click(function(e) {
    $(".xzl-popover").hide()
    //$(".nav-user-btn").css("background-color","rgba(255,255,255,0)")
    $(".popover--userActions").removeClass("is-active")
    if($(".is-search").length == 0){
      $(".xzl-search-div").removeClass("is-active")
      $(".xzl-search-input").addClass("hidden")
    }
  });
</script>
      <img class="cirle-user-avatar-36" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/20d50fcb6fd8122e0a88b9523a1ad366" alt="20d50fcb6fd8122e0a88b9523a1ad366">
    </div>
    <div class="nav-menu-btn">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="60px" height="60px" viewbox="0 0 60 60" version="1.1" class="nav-menu-btn-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 2</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-移动端" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-切图" transform="translate(-22.000000, -146.000000)" fill="#2D2E2F" fill-rule="nonzero">
            <g id="Group-2" transform="translate(22.000000, 146.000000)">
                <g id="Group" transform="translate(9.000000, 12.000000)">
                    <rect id="Rectangle" x="0" y="0" width="42" height="5"/>
                    <rect id="Rectangle-Copy" x="0" y="16" width="42" height="5"/>
                    <rect id="Rectangle-Copy-2" x="0" y="32" width="42" height="5"/>
                </g>
            </g>
        </g>
    </g>
</svg>

    </div>
    <div class="nav-menu-btn nav-menu-btn-hide">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="60px" height="60px" viewbox="0 0 60 60" version="1.1" class="nav-menu-btn-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 3</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-移动端" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-切图" transform="translate(-128.000000, -146.000000)" fill="#2D2E2F" fill-rule="nonzero">
            <g id="Group-3" transform="translate(128.000000, 146.000000)">
                <g id="Group" transform="translate(13.000000, 13.000000)">
                    <rect id="Rectangle-Copy" transform="translate(17.000000, 17.500000) scale(-1, 1) rotate(45.000000) translate(-17.000000, -17.500000) " x="-4" y="15" width="42" height="5"/>
                    <rect id="Rectangle-Copy" transform="translate(17.000000, 17.500000) rotate(45.000000) translate(-17.000000, -17.500000) " x="-4" y="15" width="42" height="5"/>
                </g>
            </g>
        </g>
    </g>
</svg>

    </div>

  </div>
</div>
<script id="template" type="text/x-handlebars-template">
  <div class="menu-float">
    <div class="menu-float-box">
      <a href='/' class="menu-float-line">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="42px" height="42px" viewBox="0 0 42 42" version="1.1" class="menu-float-line-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 22</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-304.000000, -99.000000)">
            <g id="Group-22" transform="translate(304.000000, 99.000000)">
                <rect id="Rectangle-6" fill="#FF0000" opacity="0" x="0" y="0" width="42" height="42"></rect>
                <polygon id="Rectangle-5" fill="#2D2E2F" points="4.2 14.2882472 21.1099219 2.1 37.8 14.2882472 37.8 40.0010742 4.2 40.0010742"></polygon>
            </g>
        </g>
    </g>
</svg>

        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="42px" height="42px" viewBox="0 0 42 42" version="1.1" class="menu-float-line-icon_no">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 22 Copy</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-391.000000, -99.000000)">
            <g id="Group-22-Copy" transform="translate(391.000000, 99.000000)">
                <rect id="Rectangle-6" fill="#FF0000" opacity="0" x="0" y="0" width="42" height="42"></rect>
                <polygon id="Rectangle-5" fill="#A9A9A9" points="4.2 14.2882472 21.1099219 2.1 37.8 14.2882472 37.8 40.0010742 4.2 40.0010742"></polygon>
            </g>
        </g>
    </g>
</svg>

        <div class="menu-float-text">首页</div>
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="30px" viewBox="0 0 18 30" version="1.1" class="menu-float-line-right">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Shape</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-508.000000, -217.000000)" fill="#C7C7C7" fill-rule="nonzero">
            <polygon id="Shape" transform="translate(516.828427, 231.828427) scale(-1, 1) translate(-516.828427, -231.828427) " points="513.656854 231.828427 525.656854 243.828427 522.828427 246.656854 508 231.828427 522.828427 217 525.656854 219.828427"></polygon>
        </g>
    </g>
</svg>

      </a>
      <a href='/explore' class="menu-float-line">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" height="40px" viewBox="0 0 40 40" version="1.1" class="menu-float-line-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Combined Shape</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-305.000000, -210.000000)" fill="#2D2E2F" fill-rule="nonzero">
            <path d="M325,250 C313.954305,250 305,241.045695 305,230 C305,218.954305 313.954305,210 325,210 C336.045695,210 345,218.954305 345,230 C345,241.045695 336.045695,250 325,250 Z M321.815941,227.206595 L312.840919,242.244696 L327.87902,233.269674 L336.854042,218.231573 L321.815941,227.206595 Z M325,232 C323.895431,232 323,231.104569 323,230 C323,228.895431 323.895431,228 325,228 C326.104569,228 327,228.895431 327,230 C327,231.104569 326.104569,232 325,232 Z" id="Combined-Shape"></path>
        </g>
    </g>
</svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="40px" height="40px" viewBox="0 0 40 40" version="1.1" class="menu-float-line-icon_no">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Combined Shape Copy</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-392.000000, -210.000000)" fill="#A9A9A9" fill-rule="nonzero">
            <path d="M412,250 C400.954305,250 392,241.045695 392,230 C392,218.954305 400.954305,210 412,210 C423.045695,210 432,218.954305 432,230 C432,241.045695 423.045695,250 412,250 Z M408.815941,227.206595 L399.840919,242.244696 L414.87902,233.269674 L423.854042,218.231573 L408.815941,227.206595 Z M412,232 C410.895431,232 410,231.104569 410,230 C410,228.895431 410.895431,228 412,228 C413.104569,228 414,228.895431 414,230 C414,231.104569 413.104569,232 412,232 Z" id="Combined-Shape-Copy"></path>
        </g>
    </g>
</svg>

          <div class="menu-float-text">发现</div>
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="30px" viewBox="0 0 18 30" version="1.1" class="menu-float-line-right">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Shape</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-508.000000, -217.000000)" fill="#C7C7C7" fill-rule="nonzero">
            <polygon id="Shape" transform="translate(516.828427, 231.828427) scale(-1, 1) translate(-516.828427, -231.828427) " points="513.656854 231.828427 525.656854 243.828427 522.828427 246.656854 508 231.828427 522.828427 217 525.656854 219.828427"></polygon>
        </g>
    </g>
</svg>

      </a>
      <a href='/book' class="menu-float-line">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="41px" height="37px" viewBox="0 0 41 37" version="1.1" class="menu-float-line-icon">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 3</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-304.000000, -322.000000)" fill="#2D2E2F">
            <g id="Group-3" transform="translate(304.000000, 322.000000)">
                <rect id="Rectangle-2" x="0" y="32" width="39" height="5"></rect>
                <polygon id="Rectangle-4" points="2 4 10 4 10 28 2 28"></polygon>
                <polygon id="Rectangle-4-Copy" points="15 0 23 0 23 29 15 29"></polygon>
                <polygon id="Rectangle-4-Copy-2" transform="translate(32.000000, 15.500000) rotate(-23.000000) translate(-32.000000, -15.500000) " points="28.0524805 3 36 3 35.9475195 28 28 28"></polygon>
            </g>
        </g>
    </g>
</svg>

        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="41px" height="37px" viewBox="0 0 41 37" version="1.1" class="menu-float-line-icon_no">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Group 3 Copy</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-391.000000, -322.000000)" fill="#A9A9A9">
            <g id="Group-3-Copy" transform="translate(391.000000, 322.000000)">
                <rect id="Rectangle-2" x="0" y="32" width="39" height="5"></rect>
                <polygon id="Rectangle-4" points="2 4 10 4 10 28 2 28"></polygon>
                <polygon id="Rectangle-4-Copy" points="15 0 23 0 23 29 15 29"></polygon>
                <polygon id="Rectangle-4-Copy-2" transform="translate(32.000000, 15.500000) rotate(-23.000000) translate(-32.000000, -15.500000) " points="28.0524805 3 36 3 35.9475195 28 28 28"></polygon>
            </g>
        </g>
    </g>
</svg>

        <div class="menu-float-text">小书</div>
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18px" height="30px" viewBox="0 0 18 30" version="1.1" class="menu-float-line-right">
    <!-- Generator: Sketch 52.1 (67048) - http://www.bohemiancoding.com/sketch -->
    <title>Shape</title>
    <desc>Created with Sketch.</desc>
    <g id="APP-&#31227;&#21160;&#31471;" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Q-&#20999;&#22270;" transform="translate(-508.000000, -217.000000)" fill="#C7C7C7" fill-rule="nonzero">
            <polygon id="Shape" transform="translate(516.828427, 231.828427) scale(-1, 1) translate(-516.828427, -231.828427) " points="513.656854 231.828427 525.656854 243.828427 522.828427 246.656854 508 231.828427 522.828427 217 525.656854 219.828427"></polygon>
        </g>
    </g>
</svg>

      </a>
    </div>
    <div onclick="closeMenu()"  class="menu-float-bottom"></div>
  </div>
</script>
<script type="text/javascript">
  var menuState = false
  var nowHref =  window.location.href.split('//')[1].split('/')[1].split('?')[0]
  function openPhoneMenu() {
    $($('.nav-menu-btn')[0]).addClass('nav-menu-btn-hide')
    $($('.nav-menu-btn')[1]).removeClass('nav-menu-btn-hide')
    $('body').append($('#template').html())
    $('body').css('overflow', 'hidden')
    $('html').css('height', '100%')
    $('body').css('height', '100%')
    $('.menu-float').css('top', '48px')
    $('.menu-float').css('height', $('body').height() - 47)
    if(nowHref === ''){
      $($('.menu-float-line')[0]).addClass('menu-float-line-active')
    }
    else if(nowHref === 'explore'){
      $($('.menu-float-line')[1]).addClass('menu-float-line-active')
    }
    else if(nowHref === 'book'){
      $($('.menu-float-line')[2]).addClass('menu-float-line-active')
    }
  }
  function closeMenu(){
    $($('.nav-menu-btn')[1]).addClass('nav-menu-btn-hide')
    $($('.nav-menu-btn')[0]).removeClass('nav-menu-btn-hide')
    $('.menu-float').remove()
    $('body').css('overflow', 'auto')
    $('html').css('height', 'auto')
    $('body').css('height', 'auto')
  }
  $($('.nav-menu-btn')[1]).click(function(){
    closeMenu()
  })
  // $('.menu-float-bottom').on('click',function(){
  //   closeMenu()
  // })
  $($('.nav-menu-btn')[0]).click(function(){
    if (menuState) {
      
    }
    else{
      openPhoneMenu()
    }
  })
  function submitSearchQuery() {
    var key = $(".xzl-search-input").val()
    if (!key) {
      $(".xzl-search-div").removeClass("is-active")
      $(".xzl-search-input").addClass("hidden")
    } else {
      Turbolinks.visit("/search?q=" + key + "&type=" + $(".xzl-search-input").data("search-type"), { action: "replace" })
    }
  }
  $(".xzl-search-btn").unbind("click")
  $(".xzl-search-btn").click(function (e) {
    if ($(".xzl-search-div").hasClass("is-active")) {
      submitSearchQuery()
    } else {
      $(".xzl-search-div").addClass("is-active")
      $(".xzl-search-input").removeClass("hidden")
      $(".xzl-search-input").focus()
    }
    e.stopPropagation()
  })
  $(".xzl-search-div").unbind("click")
  $(".xzl-search-div").click(function (e) {
    e.stopPropagation()
  })

  function checkKeyForSearchInput(event) {
    console.log(event)
    if (event.keyCode == 13) {
      submitSearchQuery()
    }
  }
</script>
                </div>
              </div>
            </div>
          </div>
        </div>
      <style type="text/css">
  
</style>
<div class="main topic-show-partial-main container">
  <article class="topic-show-partial">
    <div class="xzl-topic-content">
      <section>
        <div class="section-content">
          <div class="section-inner xzl-home-containner xzl-topic-show-body">
            <div class="topic-title">
              Python 简单入门指北
            </div>
            <div class="topic-header">
              <div class="postMetaInline">
                <div class="xzl-flex-center">
                  <div class="post-meta-inline-avatar u-flex0">
                    <a class="link avatar xzl-link-color" href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">
                      <img class="avatar-image" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg" alt="0bb3579c4b0803177fee89aa150d3ea9">
                    </a>
                  </div>
                  <div class="xzl-author-lockup xzl-author-lockup-user u-flex1 u-noWrapWithEllipsis">
                    <div class="xzl-author-lockup-header">
                      <a class="link link link--darken user-name link--accent u-accentColor--textNormal xzl-text-darken xzl-link-color" href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">
                        张星宇
                      </a>
                        <button class="button xzl-primary-btn link-btn    xzl-basic-btn xzl-btn-with-chrome  btn-follow-user " data-user-id="915" data-followed="false" data-following-btn="true">
                            <span class="button-label  xzl-default-state-btn js-buttonLabel">
                              + 关注
                            </span>
                        </button>
                    </div>
                    <div class="xzl-author-lockup xzl-author-lockup-time">
                      <span class="read_time">
                        预计阅读时间239分钟
                      </span>
                      <span class="time"><abbr class="timeago" title="2017-10-24T20:41:51+08:00">1 年前</abbr></span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
                <textarea class="hidden hidden_topic_body hidden_markdown_body" data-summary="Python 是一门非常容易上手的语言，通过查阅资料和教程，也许一晚上就能写出一个简单的爬虫。但 Python 也是一门很难精通的语言，因为简洁的语法背后隐藏了许多黑科技。本文主要针对的读者是：

1. 毫无 Python 经验的小白
2. 有一些简单 Python 经验，但只会复制粘贴代码，不知其所以然的读者
3. 觉得单独一篇文章太琐碎，质量没保证，却没空读完一本书，但又想对 Python 有全面了解的读者

当然， 用一篇文章来讲完某个语言是不可能的事情，我希望读完本文的读者可以：

1. 对 Python 的整体知识结构形成初步的概念
2. 了解 Python 特有的知识点，比如装饰器、上下文、生成器等等，不仅会写 Demo，还对背后的原理有一定了解
3. 避免 C++/Java 等风格的 Python 代码，能够写出地道的 Python 代码
4. 能够熟练的使用 Python 编写脚本实现日常的简单需求，能够维护小型 Python 项目，能够阅读较复杂的 Python 源码

如果以上介绍符合你对自己的定位，在开始阅读前，还需要明确几点：

1. 本文不会只介绍用法，那样太肤浅
2. 本文不会深入介绍某个知识点，比如分析源码等，那样太啰嗦，我希望做一名引路人，描述各个知识点的概貌并略作引申，为读者指出下一步的研究方向
3. 代码注释非常重要，一定要看，几乎所有的代码段都可以执行，**强烈建议**手敲一遍！

[TOC]

## 0. 准备工作

请不要在学习 Python2 还是 Python3 之间犹豫了，除非你很明确自己只接触 Python2，否则就从 Python3 学起，新版本的语言总是意味着进步的生产力（Swift 和 Xcode 除外）。Python 2 和 3 之间语法不兼容，但这并不影响熟悉 Python3 的开发者迅速写出 Python 2 的代码，反之亦然。所以与其在反复纠结中浪费时间，不如立刻行动起来。

推荐使用 **CodeRunner** 来运行本文中的 demo，它比文本编辑器功能更强大，比如支持自动补全和断点调试，又比 PyCharm 轻量得多。

## 1. 数据结构

### 1.1 数组

#### 1.1.1 列表推导

如果要对数组中的所有内容做一些修改，可以用 for 循环或者 map 函数：

<figure class=" highlight="" python"=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> array: </span><br><span class="line">	<span class="keyword">if</span> n &amp;lt; <span class="number">4</span>:</span><br><span class="line">		small.append(n * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(small)  <span class="comment"># [2, 4, 6]</span></span><br></pre></td></tr></table>

比较地道的 Python 写法是使用列表推导：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = [n * <span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> array <span class="keyword">if</span> n &amp;lt; <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

`for in` 可以写两次，类似于嵌套的 for 循环，会得到一个笛卡尔积：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signs = [&amp;<span class="comment">#39;+&amp;#39;, &amp;#39;-&amp;#39;]</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">ascii = [&amp;<span class="comment">#39;&#123;sign&#125;&#123;number&#125;&amp;#39;.format(sign=sign, number=number) </span></span><br><span class="line">		<span class="keyword">for</span> sign <span class="keyword">in</span> signs <span class="keyword">for</span> number <span class="keyword">in</span> numbers]</span><br><span class="line"><span class="comment"># 得到：[&amp;#39;+1&amp;#39;, &amp;#39;+2&amp;#39;, &amp;#39;-1&amp;#39;, &amp;#39;-2&amp;#39;]</span></span><br></pre></td></tr></table></figure>

#### 1.1.2 元组

元组可以简单的理解为不可变的数组，也就是没有 `append`、`del` 等方法，一旦创建，就无法新增或删除元素，元素自身的值也不能改变，但元素内部的属性是否可变并不受元组的影响，这一点符合其他语言中的常识。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, [])</span><br><span class="line">t[<span class="number">0</span>] = <span class="number">3</span>  <span class="comment"># 抛出错误 TypeError: &amp;#39;tuple&amp;#39; object does not support item assignment</span></span><br><span class="line">t[<span class="number">1</span>].append(<span class="number">2</span>)  <span class="comment"># 正常运行，现在的 t 是 (1, [2])</span></span><br></pre></td></tr></table></figure>

除了不可变性以外，有时候元组也会被当做不具名的数据结构，这时候元素的位置就不再是可有可无的了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coordinate = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>)</span><br><span class="line"><span class="comment"># coordinate 的第一个位置用来表示经度，第二个位置表示纬度</span></span><br></pre></td></tr></table></figure>

在解析元组数据时，可以一一对应的写上变量名：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, b = t <span class="comment"># a = 1, b = 2</span></span><br></pre></td></tr></table></figure>

有时候变量名比较长， 但我只关心其中某一个，可以这样写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, _ = t <span class="comment"># a = 1</span></span><br></pre></td></tr></table></figure>

如果元组中元素特别多，即使挨个写下划线也比较累，可以用 \* 来批量解包：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">first, *middle, last = t</span><br><span class="line"><span class="comment"># first = 1</span></span><br><span class="line"><span class="comment"># middle = [2, 3, 4]</span></span><br><span class="line"><span class="comment"># last = 5</span></span><br></pre></td></tr></table></figure>

当然，如果元素数量较多，含义较复杂，我还是建议使用具名元组：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">People = collections.namedtuple(&amp;<span class="comment">#39;People&amp;#39;, [&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;])</span></span><br><span class="line">p = People(&amp;<span class="comment">#39;bestswifter&amp;#39;, &amp;#39;22&amp;#39;)</span></span><br><span class="line">p.name <span class="comment"># bestswifter</span></span><br></pre></td></tr></table></figure>

具名元组更像是一个不能定义方法的简化版的类，能提供友好的数据展示。


元组的一个小技巧是可以避免用临时变量来交换两个数的值：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> </span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a, b = b, a</span><br><span class="line"><span class="comment"># a = 2, b = 1</span></span><br></pre></td></tr></table></figure>

#### 1.1.3 数组切片

切片的基本格式是 `array[start:end:step]`，表示对 array 在 start 到 end 之前以 step 为间隔取切片。注意这里的区间是 [start, end)，也就是左闭右开。比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 表示取 s 的第 0、2、4 个字符，结果是 &amp;#39;hlo&amp;#39;</span></span><br></pre></td></tr></table></figure>

再举几个例子

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>:<span class="number">5</span>]  <span class="comment"># 不写 step 默认就是 1，因此得到 &amp;#39;hello&amp;#39;</span></span><br><span class="line">s[<span class="number">1</span>:]   <span class="comment"># 不写 end 默认到结尾，因此还是得到 &amp;#39;ello&amp;#39;</span></span><br><span class="line">s[n:]   <span class="comment"># 获取 s 的最后 len(s) - n 个元素</span></span><br><span class="line">s[:<span class="number">2</span>]   <span class="comment"># 不写 start 默认从 0 开始，因此得到 &amp;#39;he&amp;#39;</span></span><br><span class="line">s[:n]   <span class="comment"># 获取 s 的前 n 个元素</span></span><br><span class="line">s[:<span class="number">-1</span>]  <span class="comment"># 负数表示倒过来数，因此这会刨除最后一个字符，得到 &amp;#39;hell&amp;#39;</span></span><br><span class="line">s[<span class="number">-2</span>:]  <span class="comment"># 同上，表示获取最后两个字符，得到 &amp;#39;lo&amp;#39;</span></span><br><span class="line">s[::<span class="number">-1</span>] <span class="comment"># 获取字符串的倒序排列，相当于 reverse 函数</span></span><br></pre></td></tr></table></figure>

 step 和它前面的冒号要么同时写，要么同时不写，但 start 和 end 之间的冒号不能省，否则就不是切片而是获取元素了。再次强调 `array[start:end]` 表示的区间是 [a, b)，也许你会觉得这很难记，但同样的，这会得出以下美妙的公式：

&gt; array[:n] + array[n:] = array (0 &lt;= n &lt;= len(array))

用代码来表示就是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">s[:<span class="number">2</span>] + s[<span class="number">2</span>:] == s  </span><br><span class="line"><span class="comment"># True，因为 s[:2] 是 &amp;#39;he&amp;#39;，s[2:] 是 &amp;#39;llo&amp;#39;</span></span><br></pre></td></tr></table></figure>

切片不仅可以用来获取数组的一部分值，修改切片也可以直接修改数组的对应部分，比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"><span class="comment"># a = [1, 22, 33, 44, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

并没有人规定切片的新值必须和原来的长度一致：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">3</span>]</span><br><span class="line"><span class="comment"># a = [1, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>] = []</span><br><span class="line"><span class="comment"># a = [1, 6]，相当于删除了中间的三个数字</span></span><br></pre></td></tr></table></figure>

但切片的新值必须也是可迭代的对象，比如这样写是不合法的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment"># TypeError: can only assign an iterable</span></span><br></pre></td></tr></table></figure>

#### 1.1.4 循环与遍历

一般来说，在 Python 中我们不会写出 `for (int i = 0; i &lt; len(array); ++i)` 这种风格的代码，而是使用 `for in` 这种语法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

虽然大家都知道 `for in` 语法，但它的某些灵活用法或许就不是那么众所周知了。有时候，我们会在 `if` 语句中对某个变量的值做多次判断，只要满足一个条件即可：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &amp;<span class="comment">#39;bs&amp;#39;</span></span><br><span class="line"><span class="keyword">if</span> name == &amp;<span class="comment">#39;hello&amp;#39; or name == &amp;#39;hi&amp;#39; or name == &amp;#39;bs&amp;#39; or name == &amp;#39;admin&amp;#39;:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Valid&amp;#39;)</span></span><br></pre></td></tr></table></figure>

这种情况推荐用 `in` 来代替：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &amp;<span class="comment">#39;bs&amp;#39;</span></span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">in</span> (&amp;<span class="comment">#39;hello&amp;#39;, &amp;#39;hi&amp;#39;, &amp;#39;bs&amp;#39;, &amp;#39;admin&amp;#39;):</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Valid&amp;#39;)</span></span><br></pre></td></tr></table></figure>

有时候，如果我们想要把某件事重复固定的次数，用 `for in` 会显得有些啰嗦，这时候可以借助 `range` 类型：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">	print(&amp;<span class="comment">#39;Hi&amp;#39;) # 打印五次 &amp;#39;Hi&amp;#39;</span></span><br></pre></td></tr></table></figure>

`range` 的语法和切片类似，比如我们需要访问数组所有奇数下标的元素，可以这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a), <span class="number">2</span>):</span><br><span class="line">	print(a[i])</span><br></pre></td></tr></table></figure>

在这种写法中，我们不仅能获得元素，还能知道元素的下标，这与使用 `enumerate(iterable [, start ])` 函数类似：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(a):</span><br><span class="line">	print(i, n)</span><br></pre></td></tr></table></figure>

#### 1.1.5 魔术方法

也许你已经注意到了，数组和字符串都支持切片，而且语法高度统一。这在某些强类型语言（比如我经常接触的 Objective-C 和 Java）中是不可能的，事实上，Python 能够支持这样统一的语法，并非巧合，而是因为所有用中括号进行下标访问的操作，其实都是调用这个类的 `__getitem__` 方法。

比如我们完全可以让自己的类也支持通过下标访问：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.chapters = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.chapters[n]</span><br><span class="line">				</span><br><span class="line">b = Book()</span><br><span class="line">print(b[<span class="number">1</span>]) <span class="comment"># 结果是 2</span></span><br></pre></td></tr></table></figure>

需要注意的是，这段代码几乎不会出问题（除非数组越界），这是因为我们直接把下标传到了内部的 `self.chapters` 数组上。但如果要自己处理下标，需要牢记它不一定是数字，也可以是切片，因此更完整的逻辑应该是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> isinstance(n, int): <span class="comment"># n是索引</span></span><br><span class="line">		<span class="comment"># 处理索引</span></span><br><span class="line">	<span class="keyword">if</span> isinstance(n, slice): <span class="comment"># n是切片</span></span><br><span class="line">		<span class="comment"># 通过 n.start，n.stop 和 n.step 来处理切片</span></span><br></pre></td></tr></table></figure>

与静态语言不同的是，任何实现了 `__getitem__` 都支持通过下标访问，而不用声明为实现了某个协议，这种特性也被称为 “鸭子类型”。鸭子类型并不要求某个类 **是什么**，仅仅要求这个类 **能做什么**。

顺便说一句，实现了 `__getitem__` 方法的类都是可迭代的，比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = Book()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> b:</span><br><span class="line">	print(c)</span><br></pre></td></tr></table></figure>

后续的章节还会介绍更多 Python 中的魔术方法，这种方法的名称前后都有两个下划线，如果读作 “下划线-下划线-getitem” 会比较拗口，因此可以读作 “dunder-getitem” 或者 “双下-getitem”，类似的，我想每个人都能猜到 `__setitem__` 的作用和用法。

### 1.2 字典

#### 1.2.1 初始化字典

最简单的创建一个字典的方式就是直接写字面量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62, &amp;#39;c&amp;#39;: 63, &amp;#39;d&amp;#39;: 64, &amp;#39;e&amp;#39;: 65&#125;</span></span><br></pre></td></tr></table></figure>

字典字面量由大括号包住（注意区别于数组的中括号），键值对之间由逗号分割，每个键值对内部用冒号分割键和值。

如果数组的每个元素都是二元的元组，这个数组可以直接转成字典：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict([(&amp;<span class="comment">#39;a&amp;#39;, 61), (&amp;#39;b&amp;#39;, 62), (&amp;#39;c&amp;#39;, 63), (&amp;#39;d&amp;#39;, 64), (&amp;#39;e&amp;#39;, 65)])</span></span><br></pre></td></tr></table></figure>

就像数组可以推导一样，字典也可以推导：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [(&amp;<span class="comment">#39;a&amp;#39;, 61), (&amp;#39;b&amp;#39;, 62), (&amp;#39;c&amp;#39;, 63), (&amp;#39;d&amp;#39;, 64), (&amp;#39;e&amp;#39;, 65)]</span></span><br><span class="line">d = &#123;letter: number <span class="keyword">for</span> letter, number <span class="keyword">in</span> a&#125; <span class="comment"># 这里用到了元组拆包</span></span><br></pre></td></tr></table></figure>

只要记得外面还是大括号就行了。

两个独立的数组可以被压缩成一个字典：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>]</span><br><span class="line">letters = [&amp;<span class="comment">#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br><span class="line">dict(zip(letters, numbers))</span><br></pre></td></tr></table></figure>

正如 zip 的意思所表示的，超出长处的那部分数组会被抛弃。

#### 1.2.2 查询字典

最简单方法是直接写键名，但如果键名不存在会抛出 `KeyError`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61&#125;</span></span><br><span class="line">d[&amp;<span class="comment">#39;a&amp;#39;] # 值是 61</span></span><br><span class="line">d[&amp;<span class="comment">#39;b&amp;#39;] # KeyError: &amp;#39;b&amp;#39;</span></span><br></pre></td></tr></table></figure>

可以用 `if key in dict` 的判断来检查键是否存在，甚至可以先 `try` 再 `catch KeyError` ，但更加优雅简洁一些的写法是用 `get(k, default)` 方法来提供默认值：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61&#125;</span></span><br><span class="line">d.get(&amp;<span class="comment">#39;a&amp;#39;, 62) # 得到 61</span></span><br><span class="line">d.get(&amp;<span class="comment">#39;b&amp;#39;, 62) # 得到 62</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">不过有时候，我们可能不仅仅要读出默认属性，更希望能把这个默认属性能写入到字典中，比如：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="comment"># 我们想对字典中某个 Value 做操作，如果 Key 不存在，就先写入一个空值</span></span><br><span class="line"><span class="keyword">if</span> &amp;<span class="comment">#39;list&amp;#39; not in d:</span></span><br><span class="line">	d[&amp;<span class="comment">#39;list&amp;#39;] = []</span></span><br><span class="line">d[&amp;<span class="comment">#39;list&amp;#39;].append(1)</span></span><br></pre></td></tr></table></figure>

这种情况下，`setdefault(key, default)` 函数或许更合适：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.setdefault(&amp;<span class="comment">#39;key&amp;#39;, []).append(1)</span></span><br></pre></td></tr></table></figure>

这个函数虽然名为 `set`，但作用其实是查找，仅仅在查找不到时才会把默认值写入字典。

#### 1.2.3 遍历字典

直接遍历字典实际上是遍历了字典的键，因此也可以通过键获取值：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62, &amp;#39;c&amp;#39;: 63, &amp;#39;d&amp;#39;: 64, &amp;#39;e&amp;#39;: 65&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">	print(i, d[i])</span><br><span class="line"><span class="comment">#b 62</span></span><br><span class="line"><span class="comment">#a 61</span></span><br><span class="line"><span class="comment">#e 65</span></span><br><span class="line"><span class="comment">#d 64</span></span><br><span class="line"><span class="comment">#c 63</span></span><br></pre></td></tr></table></figure>

我们也可以用字典的 `keys()` 或者 `values()` 方法显式的获取键和值。字典还有一个 `items()` 方法，它返回一个数组，每个元素都是由键和值组成的二元元组：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62, &amp;#39;c&amp;#39;: 63, &amp;#39;d&amp;#39;: 64, &amp;#39;e&amp;#39;: 65&#125;</span></span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> d.items():</span><br><span class="line">	print(k, v)</span><br><span class="line"><span class="comment">#e 65</span></span><br><span class="line"><span class="comment">#d 64</span></span><br><span class="line"><span class="comment">#a 61</span></span><br><span class="line"><span class="comment">#c 63</span></span><br><span class="line"><span class="comment">#b 62</span></span><br></pre></td></tr></table></figure>

可见 `items()` 方法和字典的构造方法互为逆操作，因为这个公式总是成立的：

&gt; dict(d.items()) == d

#### 1.2.4 字典的魔术方法

在 1.1.4 节中介绍过，通过下标访问最终都会由 `__getitem__` 这个魔术方法处理，因此字典的 `d[key]` 这种写法也不例外， 如果键不存在，则会走到 `__missing__` 方法，再给一次挽救的机会。比如我们可以实现一个字典， 自动忽略键的大小写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> key.islower():</span><br><span class="line">			<span class="keyword">raise</span> KeyError(key)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> self[key.lower()]</span><br><span class="line">			</span><br><span class="line">d = MyDict(&#123;&amp;<span class="comment">#39;a&amp;#39;: 61&#125;)</span></span><br><span class="line">d[&amp;<span class="comment">#39;A&amp;#39;] # 返回 61</span></span><br><span class="line">&amp;<span class="comment">#39;A&amp;#39; in d # False</span></span><br></pre></td></tr></table></figure>

这个字典比较简陋，比如 key 可能不是字符串，不过我没有处理太多情况，因为它主要是用来演示 `__missing__` 的用法，如果想要最后一行的 `in` 语法正确工作，需要重写 `__contains__` 这个魔术方法，过程类似，就不赘述了。

虽然通过自定义的函数也能实现相似的效果，不过这个自定义字典对用户更加透明，如果不在文档中说明，调用方很难察觉到字典的内部逻辑被修改了。 Python 有很多强大的功能，可以具备这种内部进行修改，但是对外保持透明的能力。这可能是我们第一次体会到，后续还会不断的经历。

#### 1.2.5 集合

集合更像是不会有重复元素的数组，但它的本质是以元素的哈希值作为 Key，从而实现去重的逻辑。因此，集合也可以推导，不过得用字典的语法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">d = &#123;i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &amp;lt; <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># d = &#123;1, 2, 3, 4&#125;，注意这里的大括号</span></span><br></pre></td></tr></table></figure>

回忆一下，二进制逻辑运算一共有三个运算符，按位或 `|`，按位与 `&amp;` 和异或 `^`，这三个运算符也可以用在集合之间，而且含义变化不大。比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a | b</span><br><span class="line"><span class="comment"># c = &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

这里的 `|` 运算表示并集，也就是 c 中的任意元素，要么在 a，要么在 b 集合中。类似的，按位与 `&amp;` 运算求的就是交集：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a &amp;amp; b</span><br><span class="line"><span class="comment"># c = &#123;3&#125;</span></span><br></pre></td></tr></table></figure>

而异或则表示那些只在 a 不在 b 或者只在 b 不在 a 的元素。或者换个说法，表示那些在集合 a 和 b 中出现了且仅出现了一次的元素：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a ^ b</span><br><span class="line"><span class="comment"># c = &#123;1, 2, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

还有一个差集运算 `-`，表示在集合 a 中但不在集合 b 中的元素：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a - b</span><br><span class="line"><span class="comment"># c = &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>

回忆一下韦恩图，就会得到以下公式（虽然并没有什么卵用）：

&gt; A | B = (A ^ B) | (A &amp; B)
&gt; A ^ B = (A - B) | (B - A)

### 1.3 字符串

#### 1.3.1 字符串编码

用 Python 写过爬虫的人都应该感受过被字符串编码支配的恐惧。简单来说，编码指的是将可读的字符串转换成不太可读的数字，用来存储或者传输。解码则指的是将数字还原成字符串的过程。常见的编码有 ASCII、GBK 等。

ASCII 编码是一个相当小的字符集合，只有一百多个常用的字符，因此只用一个字节（8 位）就能表示，为了存储本国语言，各个国家都开发出了自己的编码，比如中文的 GBK。这就带来了一个问题，如果我想要在一篇文章中同时写中文和日文，就无法实现了，除非能对每个字符指定编码，这个成本高到无法接受。

Unicode 则是一个最全的编码方式，每个 Unicode 字符占据 6 个字节，可以表示出 2 ^ 48 种字符。但随之而来的是 Unicode 编码后的内容不适合存储和发送，因此诞生了基于 Unicode 的再次编码，目的是为了更高效的存储。

更详细的概念分析和配图说明可以参考我的这篇文章：[字符串编码入门科普](http://fullstack.blog/2017/09/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E5%85%A5%E9%97%A8%E7%A7%91%E6%99%AE/)，这里我们主要聊聊 Python 对字符串编码的处理。

首先，编码的函数是 `encode`，它是字符串的方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">s.encode()         <span class="comment"># 得到 b&amp;#39;hello&amp;#39;</span></span><br><span class="line">s.encode(&amp;<span class="comment">#39;utf16&amp;#39;)  # 得到 b&amp;#39;\xff\xfeh\x00e\x00l\x00l\x00o\x00&amp;#39;</span></span><br></pre></td></tr></table></figure>

`encode` 函数有两个参数，第一个参数不写表示使用默认的 `utf8` 编码，理论上会输出二进制格式的编码结果，但在终端打印时，被自动还原回字符串了。如果用 `utf16` 进行编码，则会看到编码以后的二进制结果。

前面说过，编码是字符转到二进制的转化过程，有时候在某个编码规范中，并没有指定某个字符是如何编码的，也就是找不到对应的数字，这时候编码就会报错：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">city = &amp;<span class="comment">#39;São Paulo&amp;#39;</span></span><br><span class="line">b_city = city.encode(&amp;<span class="comment">#39;cp437&amp;#39;)</span></span><br><span class="line"><span class="comment"># UnicodeEncodeError: &amp;#39;charmap&amp;#39; codec can&amp;#39;t encode character &amp;#39;\xe3&amp;#39; in position 1: character maps to &amp;lt;undefined&amp;gt;</span></span><br></pre></td></tr></table></figure>

此时需要用到 `encode` 函数的第二个参数，用来指定遇到错误时的行为。它的值可以是 `&#39;ignore&#39;`，表示忽略这个不能编码的字符，也可以是 `&#39;replace&#39;`，表示用默认字符代替：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b_city = city.encode(&amp;<span class="comment">#39;cp437&amp;#39;, errors=&amp;#39;ignore&amp;#39;) </span></span><br><span class="line"><span class="comment"># b&amp;#39;So Paulo&amp;#39;</span></span><br><span class="line">b_city = city.encode(&amp;<span class="comment">#39;cp437&amp;#39;, errors=&amp;#39;replace&amp;#39;)</span></span><br><span class="line"><span class="comment"># b&amp;#39;S?o Paulo&amp;#39;</span></span><br></pre></td></tr></table></figure>

`decode` 完全是 `encode` 的逆操作，只有二进制类型才有这个函数。它的两个参数含义和 `encode` 函数完全一致，就不再介绍了。

从理论上来说，仅从编码后的内容上来看，是无法确定编码方式的，也无法解码出原来的字符。但不同的编码有各自的特点，虽然无法完全倒推，但可以从概率上来猜测，如果发现某个二进制内容，有 99% 的可能性是 `utf8` 编码生成的，我们就可以用 `utf8` 进行解码。Python 提供了一个强大的工具包 `Chardet`  来完成这一任务：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octets = b&amp;<span class="comment">#39;Montr\xe9al&amp;#39;</span></span><br><span class="line">chardet.detect(octets)</span><br><span class="line"><span class="comment"># &#123;&amp;#39;encoding&amp;#39;: &amp;#39;ISO-8859-1&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;&#125;</span></span><br><span class="line">octets.decode(&amp;<span class="comment">#39;ISO-8859-1&amp;#39;)</span></span><br><span class="line"><span class="comment"># Montréal</span></span><br></pre></td></tr></table></figure>

返回结果中包含了猜测的编码方式，以及可信度。可信度越高，说明是这种编码方式的可能性越大。

有时候，我们拿到的是二进制的字符串字面量，比如 `68 65 6c 6c 6f`，前文说过只有二进制类型才有 `decode` 函数，所以需要通过二进制的字面量生成二进制变量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;68 65 6c 6c 6f&amp;#39;</span></span><br><span class="line">b = bytearray.fromhex(s)</span><br><span class="line">b.decode()  <span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

#### 1.3.2 字符串的常用方法

字符串的 `split(sep, maxsplit)` 方法可以以指定的分隔符进行分割，有点类似于 Shell 中的 `awk -F &#39; &#39;`&#39;，第一个 `sep` 参数表示分隔符，不填则为空格：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;a b c d e&amp;#39;</span></span><br><span class="line">a = s.split()</span><br><span class="line"><span class="comment"># a = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br></pre></td></tr></table></figure>

第二个参数 `maxsplit` 表示最多分割多少次，因此返回数组的长度是 `maxsplit + 1`。举个例子说明下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;a;b;c;d;e&amp;#39;</span></span><br><span class="line">a = s.split(&amp;<span class="comment">#39;;&amp;#39;)</span></span><br><span class="line"><span class="comment"># a = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br><span class="line"></span><br><span class="line">b = s.split(&amp;<span class="comment">#39;;&amp;#39;, 2)</span></span><br><span class="line"><span class="comment"># b = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c;d;e&amp;#39;]</span></span><br></pre></td></tr></table></figure>

如果想批量替换，则可以用 `replace(old, new[, count])` 方法，由中括号括起来的参数表示选填。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &amp;<span class="comment">#39;a;b;c;d;e&amp;#39;</span></span><br><span class="line">new = old.replace(&amp;<span class="comment">#39;;&amp;#39;, &amp;#39; &amp;#39;, 3)</span></span><br><span class="line"><span class="comment"># new = &amp;#39;a b c d;e&amp;#39;</span></span><br></pre></td></tr></table></figure>

`strip[chars]` 用于移除指定的字符们：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &amp;quot;*****!!!Hello!!!*****&amp;quot;</span><br><span class="line">new = old.strip(&amp;<span class="comment">#39;*&amp;#39;)  # 得到 &amp;#39;!!!Hello!!!&amp;#39;</span></span><br><span class="line">new = old.strip(&amp;<span class="comment">#39;*！&amp;#39;)  # 得到 &amp;#39;Hello&amp;#39;</span></span><br></pre></td></tr></table></figure>

如果不传参数，则默认移除空格。其实 `strip` 等价于分别执行 `lstrip()` 和 `rstrip()`，即分别从左侧和右侧进行移除。比如 `lstrip()` 表示从左侧第一个字符开始，移除空格，直到第一个非空格字符为止，所以字符串中间的空格，无论是 `lstrip` 还是 `strip()` 都是无法移除的。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &amp;<span class="comment">#39;  Hello world  &amp;#39;</span></span><br><span class="line">new = old.strip()   <span class="comment"># 得到 &amp;#39;Hello wrold&amp;#39;</span></span><br><span class="line">new = old.lstrip()  <span class="comment"># 得到 &amp;#39;Hello world  &amp;#39;</span></span><br></pre></td></tr></table></figure>

最后一个常用方法是 `join`，其实这个可以理解为字符串的构造方法，它可以把数组转换成字符串：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = &amp;<span class="comment">#39;a b c d e&amp;#39;.split() # 之前说过，结果是 [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br><span class="line">s = &amp;<span class="comment">#39;;&amp;#39;.join(array) # 以分号为连接符，把数组中的元素连接起来</span></span><br><span class="line"><span class="comment"># s = &amp;#39;a;b;c;d;e&amp;#39;</span></span><br></pre></td></tr></table></figure>

所以 `join` 可以理解为 `split` 的逆操作，这个公式始终是成立的：

&gt; c.join(string.split(c)) = string

上面这些字符串处理的函数，大多返回的还是字符串，因此可以链式调用，避免使用临时变量和多行代码，但也要避免过长（超过 3 个）的链式调用，以免影响可读性。

#### 1.3.3 字符串格式化

最初级的字符串格式化方法是使用 `+` 来拼接：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">		self.age = <span class="number">22</span></span><br><span class="line">		self.sex = &amp;<span class="comment">#39;m&amp;#39;</span></span><br><span class="line">		</span><br><span class="line">p = Person()</span><br><span class="line">print(&amp;<span class="comment">#39;Name: &amp;#39; + p.name + &amp;#39;, Age: &amp;#39; + str(p.age) + &amp;#39;, Sex: &amp;#39; + p.sex)</span></span><br><span class="line"><span class="comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span></span><br></pre></td></tr></table></figure>

这里必须要把 `int` 类型的年龄转成字符串以后才能进行拼接，这是因为 Python 是强类型语言，不支持类型的隐式转换。

这种做法的缺点在于如果输出结构比较复杂，极容易出现引号匹配错误的问题，可读性非常低。

Python 2 中的做法是使用占位符，类似于 C 语言中 `printf`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content = &amp;<span class="comment">#39;Name: %s, Age: %i, Sex: %c&amp;#39; % (p.name, p.age, p.sex)</span></span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>

从结构上看，要比上一种写法清楚得多， 但每个变量都需要指定类型，这和 Python 的简洁不符。实际上每个对象都可以通过 `str()` 函数转换成字符串，这个函数的背后是 `__str__` 魔术方法。

Python 3 中的写法是使用 `format` 函数，比如我们来实现一下 `__str__` 方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">		self.age = <span class="number">22</span></span><br><span class="line">		self.sex = &amp;<span class="comment">#39;m&amp;#39;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="comment">#39;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&amp;#39;.format(user=self)</span></span><br><span class="line">			</span><br><span class="line">p = Person()</span><br><span class="line">print(p)</span><br><span class="line"><span class="comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span></span><br></pre></td></tr></table></figure>

除了把对象传给 `format` 函数并在字符串中展开以外， 也可以传入多个参数，并且通过下标访问他们：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&amp;<span class="comment">#39;&#123;0&#125;, &#123;1&#125;, &#123;0&#125;&amp;#39;.format(1, 2))</span></span><br><span class="line"><span class="comment"># 输出：1, 2, 1，这里的 &#123;1&#125; 表示第二个参数</span></span><br></pre></td></tr></table></figure>

#### 1.3.4 HereDoc

Heredoc 不是 Python 特有的概念， 命令行和各种脚本中都会见到，它表示一种所见即所得的文本。

假设我们在写一个 HTML 的模板，绝大多数字符串都是常量，只有有限的几个地方会用变量去替换，那这个字符串该如何表示呢？一种写法是直接用单引号去定义：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;\nFriends CGI Demo&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;\n&amp;lt;BODY&amp;gt;&amp;lt;H3&amp;gt;ERROR&amp;lt;/H3&amp;gt;\n&amp;lt;B&amp;gt;%s&amp;lt;/B&amp;gt;&amp;lt;P&amp;gt;\n&amp;lt;FORM&amp;gt;&amp;lt;INPUT TYPE=button VALUE=Back\nONCLICK=\&amp;#39;window.history.back()\&amp;#39;&amp;gt;&amp;lt;/FORM&amp;gt;\n&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;&amp;#39;</span></span><br></pre></td></tr></table></figure>

这段代码是自动生成的还好，如果是手动维护的，那么可读性就非常差，因为换行符和转义后的引号增加了理解的难度。如果用 heredoc 来写，就非常简单了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;&amp;#39;&amp;#39;&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;</span></span><br><span class="line">Friends CGI Demo&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;</span><br><span class="line">&amp;lt;BODY&amp;gt;&amp;lt;H3&amp;gt;ERROR&amp;lt;/H3&amp;gt;</span><br><span class="line">&amp;lt;B&amp;gt;%s&amp;lt;/B&amp;gt;&amp;lt;P&amp;gt;</span><br><span class="line">&amp;lt;FORM&amp;gt;&amp;lt;INPUT TYPE=button VALUE=Back</span><br><span class="line">ONCLICK=&amp;<span class="comment">#39;window.history.back()&amp;#39;&amp;gt;&amp;lt;/FORM&amp;gt;</span></span><br><span class="line">&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;</span><br><span class="line">&amp;<span class="comment">#39;&amp;#39;&amp;#39;</span></span><br></pre></td></tr></table></figure>

Heredoc 主要是用来书写大段的字符串常量，比如 HTML 模板，SQL语句等等。

## 2 函数

### 2.1 函数是一等公民

一等公民指的是 Python 的函数能够动态创建，能赋值给别的变量，能作为参传给函数，也能作为函数的返回值。总而言之，函数和普通变量并没有什么区别。

函数是一等公民，这是函数式编程的基础，然而 Python 中基本上不会使用 lambda 表达式，因为在 lambda 表达式的中仅能使用单纯的表达式，不能赋值，不能使用 while、try 等语句，因此 lambda 表达式要么难以阅读，要么根本无法写出。这极大的限制了 lambda 表达式的使用场景。

上文说过，函数和普通变量没什么区别，但普通变量并不是函数，因为这些变量无法调用。但如果某个类实现了 `__call__` 这个魔术方法，这个类的实例就都可以像函数一样被调用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">		self.age = <span class="number">22</span></span><br><span class="line">		self.sex = &amp;<span class="comment">#39;m&amp;#39;</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(self)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="comment">#39;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&amp;#39;.format(user=self)</span></span><br><span class="line">			</span><br><span class="line">p = Person()</span><br><span class="line">p() <span class="comment"># 等价于 print(p)</span></span><br></pre></td></tr></table></figure>

### 2.2 函数参数

#### 2.2.1 函数传参

对于熟悉 C 系列语言的人来说，函数传参的方式一目了然。默认是拷贝传值，如果传指针是引用传值。我们先来看一段简单的 Python 代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg = <span class="number">5</span></span><br><span class="line">	print(arg)</span><br><span class="line">	</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">foo(a)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 输出 5 和 1</span></span><br></pre></td></tr></table></figure>

这段代码的结果符合我们的预期，从这段代码来看，Python 也属于拷贝传值。但如果再看这段代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg.append(<span class="number">1</span>)</span><br><span class="line">	print(arg)</span><br><span class="line">	</span><br><span class="line">a = [<span class="number">1</span>]</span><br><span class="line">foo(a)</span><br><span class="line">print(a) <span class="comment"># 输出两个 [1, 1]</span></span><br></pre></td></tr></table></figure>

你会发现参数数组在函数内部被改变了。就像是 C 语言中传递了变量的指针一样。所以 Python 到底是拷贝传值还是引用传值呢？答案**都是否定的**！

Python 的传值方式可以被理解为混合传值。对于那些不可变的对象（比如 1.1.2 节中介绍过的元组，还有数字、字符串类型），传值方式是拷贝传值；对于那些可变对象（比如数组和字典）则是引用传值。

#### 2.2.2 默认参数

Python 的函数可以有默认值，这个功能很好用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, l=[])</span>:</span></span><br><span class="line">	l.append(a)</span><br><span class="line">	<span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>,[<span class="number">1</span>])  <span class="comment"># 给数组 [1] 添加一个元素 2，得到 [1,2]</span></span><br><span class="line">foo(<span class="number">2</span>)      <span class="comment"># 没有传入数组，使用默认的空数组，得到 [2]</span></span><br></pre></td></tr></table></figure>

然而如果这样调用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">2</span>)  <span class="comment"># 利用默认参数，得到 [2]</span></span><br><span class="line">foo(<span class="number">3</span>)  <span class="comment"># 竟然得到了 [2, 3]</span></span><br></pre></td></tr></table></figure>

函数调用了两次以后，默认参数被改变了，也就是说函数调用产生了副作用。这是因为默认参数的存储并不像函数里的临时变量一样存储在栈上、随着函数调用结束而释放，而是存储在函数这个对象的内部：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.__defaults__  <span class="comment"># 一开始确实是空数组</span></span><br><span class="line">foo(<span class="number">2</span>)  <span class="comment"># 利用默认参数，得到 [2]</span></span><br><span class="line">foo.__defaults__  <span class="comment"># 如果打印出来看，已经变成 [2] 了</span></span><br><span class="line">foo(<span class="number">3</span>)  <span class="comment"># 再添加一个元素就得到了 [2, 3]</span></span><br></pre></td></tr></table></figure>

因为函数 `foo` 作为一个对象，不会被释放，因此这个对象内部的属性也不会随着多次调用而自动重置，会一直保持上次发生的变化。基于这个前提，我们得出一个结论：**函数的默认参数不允许是可变对象**，比如这里的 `foo` 函数需要这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, l=None)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> l <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">		l = []</span><br><span class="line">	l.append(a)</span><br><span class="line">	<span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">print(foo(<span class="number">2</span>)) <span class="comment"># 得到 [2]</span></span><br><span class="line">print(foo(<span class="number">3</span>)) <span class="comment"># 得到 [3]</span></span><br></pre></td></tr></table></figure>

现在，给参数添加默认值的行为在函数体中完成，不会随着函数的多次调用而累积。

对于 Python 的默认参数来说：

&gt; 如果默认值是不可变的，可以直接设置默认值，否则要设置为 None 并在函数体中设置默认值。

#### 2.2.3 多参数传递

当参数个数不确定时，可以在参数名前加一个 `*`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args)</span>:</span></span><br><span class="line">	print(args)</span><br><span class="line">	</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

如果直接把数组作为参数传入，它其实是单个参数，如果要把数组中所有元素都作为单独的参数传入，则在数组前面加上 `*`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]	</span><br><span class="line">foo(a)  <span class="comment"># 会输出 ([1,2,3], )   因为只传了一个数组作为参数</span></span><br><span class="line">foo(*a) <span class="comment"># 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

这里的单个 `*` 只能接收非关键字参数，也就是仅有参数值的哪些参数。如果想接受关键字参数，需要用 `**` 来表示：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">	print(args)</span><br><span class="line">	print(kwargs)</span><br><span class="line">	</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, a=<span class="number">61</span>, b=<span class="number">62</span>)</span><br><span class="line"><span class="comment"># 第一行输出：(1, 2, 3)</span></span><br><span class="line"><span class="comment"># 第二行输出：&#123;&amp;#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62&#125;</span></span><br></pre></td></tr></table></figure>

类似的，字典变量传入函数只能作为单个参数，如果要想展开并被 `**kwargs` 识别，需要在字典前面加上两个星号 `**`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62&#125;</span></span><br><span class="line">foo(*a, **d)</span><br></pre></td></tr></table></figure>

#### 2.2.4 参数分类

Python 中函数的参数可以分为两大类：

1. 定位参数（Positional）：表示参数的位置是固定的。比如对于函数 `foo(a, b)` 来说，`foo(1, 2)` 和 `foo(2, 1)` 就是截然不同的，a 和 b 的位置是固定的，不可随意调换。
2. 关键词参数（Keyword）：表示参数的位置不重要，但是参数名称很重要。比如 `foo(a = 1, b = 2)` 和 `foo(b = 2, a = 1)` 的含义相同。

有一种参数叫做仅限关键字（Keyword-Only）参数，比如考虑这个函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args, n=<span class="number">1</span>, **kwargs)</span>:</span></span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>

这个函数在调用时，如果参数 n 不指定名字，就会被前面的 `*args` 处理掉，如果指定的名字不是 n，又会被后面的 `**kwargs` 处理掉，所以参数 n 必须精确的以 `(n = xxx)` 的形式出现，也就是 Keyworld-Only。

### 2.3 函数内省

在 2.2.2 节中，我们查看了函数变量的 `__defaults__` 属性，其实这就是一种内省，也就是在运行时动态的查看变量的信息。

前文说过，函数也是对象，因此函数的变量个数，变量类型都应该有办法获取到，如果你需要开发一个框架，也许会对函数有各种奇葩的检查和校验。 

以下面这个函数为例：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(m, *args, n, **kwargs)</span>:</span></span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br></pre></td></tr></table></figure>

首先可以获取函数名，函数所在模块的全局变量等：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__globals__   <span class="comment"># 全局变量，包含了 g = 1</span></span><br><span class="line">foo.__name__      <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

我们还可以看到函数的参数，函数内部的局部变量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__code__.co_varnames  <span class="comment"># (&amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;args&amp;#39;, &amp;#39;kwargs&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;)</span></span><br><span class="line">foo.__code__.co_argcount  <span class="comment"># 只计算参数个数，不考虑可变参数和仅限关键字参数，所以得到 1</span></span><br></pre></td></tr></table></figure>

或者用 `inspect` 模块来查看更详细的信息：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">sig = inspect.signature(foo)  <span class="comment"># 获取函数签名</span></span><br><span class="line"></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;m&amp;#39;].kind      # POSITIONAL_OR_KEYWORD 表示可以是定位参数或关键字参数</span></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;args&amp;#39;].kind   # VAR_POSITIONAL 定位参数构成的数组</span></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;n&amp;#39;].kind      # KEYWORD_ONLY 仅限关键字参数</span></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;kwargs&amp;#39;].kind # VAR_KEYWORD 关键字参数构成的字典</span></span><br><span class="line">inspect.getfullargspec(foo)       </span><br><span class="line"><span class="comment"># 得到：ArgSpec(args=[&amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;], varargs=&amp;#39;args&amp;#39;, keywords=&amp;#39;kwargs&amp;#39;, defaults=None)</span></span><br></pre></td></tr></table></figure>

本节的新 API 比较多，但并不要求记住这些 API 的用法。再次强调，本文的写作目的是为了建立读者对 Python 的总体认知，了解 Python **能做什么**，至于怎么做，那是文档该做的事。

### 2.4 装饰器

#### 2.4.1 设计模式的消亡

经典的设计模式有 23 个，虽然设计模式都是常用代码的总结，理论上来说与语法无关。但不得不承认的是，标准的设计模式在不同的语言中，有的因为语法的限制根本无法轻易实现（比如在 C 语言中实现组合模式），有的则因为语言的特定功能，变得冗余啰嗦。

以策略模式为例，有一个抽象的策略类，定义了策略的接口，然后使用者选择一个具体的策略类，构造他们的实例并且调用策略方法。具体代码可以参考：[策略模式在百度百科的定义](https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/646307?fr=aladdin)。

然而这些对象本身并没有作用，它们仅仅是可以调用相同的方法而已，只不过在 Java 中，所有的任务都需要由对象来完成。即使策略本身就是一个函数，但也必须把它包裹在一个策略对象中。所以在 Python 中更优雅写法是直接把策略函数作为变量使用。不过这就引入一个问题，如何判断某个函数是个策略呢，毕竟在面向对象的写法中，只要检查它的父类是否是抽象的策略类即可。

也许你已经见过类似的写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@strategy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strategyA</span><span class="params">(n)</span>:</span></span><br><span class="line">	print(n * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

下面就开始介绍装饰器。

#### 2.4.2 装饰器的基本原理

首先，装饰器是个函数，它的参数是被装饰的函数，返回值也是一个函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(origin_func)</span>:</span>  <span class="comment"># 这个参数是被装饰的函数</span></span><br><span class="line">	print(<span class="number">1</span>)  <span class="comment"># 先输出点东西</span></span><br><span class="line">	<span class="keyword">return</span> origin_func  <span class="comment"># 把原函数直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate    # 注意这里不是函数调用，所以不用加括号，也不用加被修饰的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">sayHello()  <span class="comment"># 如果没有装饰器，只会打印 &amp;#39;Hello&amp;#39;，实际结果是打印 1 再打印 &amp;#39;Hello&amp;#39;</span></span><br></pre></td></tr></table></figure>

因此，使用装饰器的这种写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

和下面这种写法是完全等价的， 初学者可以把装饰器在心中默默的转换成下一种写法，以方便理解：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">foo = decorate(foo)</span><br></pre></td></tr></table></figure>

需要注意的是，装饰器函数 `decorate` 在模块被导入时就会执行，而被装饰的函数只在被调用时才会执行，也就是说即使不调用 `sayHello` 函数也会输出 1，但这样就不会输出 Hello 了。

有了装饰器，配合前面介绍的函数对象，函数内省，我们可以做很多有意思的事，至少判断上一节中某个函数是否是策略是非常容易的。在装饰器中，我们还可以把策略函数都保存到数组中， 然后提供一个“推荐最佳策略”的功能， 其实就是遍历执行所有的策略，然后选择最好的结果。

#### 2.4.3 装饰器进阶

上一节中的装饰器主要是为了介绍工作原理，它的功能非常简单，并不会改变被装饰函数的运行结果，仅仅是在导入时装饰函数，然后输出一些内容。换句话说，即使不执行函数，也要执行装饰器中的 `print` 语句，而且因为直接返回函数的缘故，其实没有真正的起到装饰的效果。

如何做到装饰时不输出任何内容，仅在函数执行最初输出一些东西呢？这是常见的 AOP（面向切片编程） 的需求。这就要求我们不能再直接返回被装饰的函数，而是应该返回一个新的函数，所以新的装饰器需要这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(origin_func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="number">1</span>)</span><br><span class="line">		origin_func()</span><br><span class="line">	<span class="keyword">return</span> new_func</span><br><span class="line"></span><br><span class="line">decorate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">sayHello() <span class="comment"># 运行结果不变，但是仅在调用函数 sayHello 时才会输出 1</span></span><br></pre></td></tr></table></figure>

这个例子的工作原理是，`sayHello` 函数作为参数 `origin_func` 被传到装饰器中，经过装饰以后，它实际上变成了 `new_func`，会先输出 1 再执行原来的函数，也就是 `sayHello`。

这个例子很简陋，因为我们知道了 `sayHello` 函数没有参数，所以才能定义一个同样没有参数的替代者：`nwe_func`。如果我们在开发一个框架，要求装饰器能对任意函数生效，就需要用到 2.2.3 中介绍的 `*` 和 `**` 这种不定参数语法了。

如果查看 `sayHello` 函数的名字，得到的结果将是 `new_func`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello.__name__  <span class="comment"># new_func</span></span><br></pre></td></tr></table></figure>

这是很自然的，因为本质上其实执行的是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_func = decorate(sayHello)</span><br></pre></td></tr></table></figure>

而装饰器的返回结果是另一个函数 `new_func`，两者仅仅是运行结果类似，但两个对象并没有什么关联。

所以为了处理不定参数，并且不改变被装饰函数的外观（比如函数名），我们需要做一些细微的修补工作。这些工作都是模板代码，所以 Python 早就提供了封装：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(origin_func)</span>:</span></span><br><span class="line"><span class="meta">	@functools.wraps(origin_func)  # 这是 Python 内置的装饰器</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="number">1</span>)</span><br><span class="line">		origin_func(*args, **kwargs)</span><br><span class="line">	<span class="keyword">return</span> new_func</span><br></pre></td></tr></table></figure>

#### 2.4.4 装饰器工厂

在 2.4.2 节的代码注释中我解释过，装饰器后面不要加括号，被装饰的函数自动作为参数，传递到装饰器函数中。如果加了括号和参数，就变成手动调用装饰器函数了，大多数时候这与预期不符（因为装饰器的参数一般都是被装饰的函数）。

不过装饰器可以接受自定义的参数，然后返回另一个装饰器，这样外面的装饰器实际上就是一个装饰器工厂，可以根据用户的参数，生成不同的装饰器。还是以上面的装饰器为例，我希望输出的内容不是固定的 1，而是用户可以指定的，代码就应该这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(content)</span>:</span>  				      <span class="comment"># 这其实是一个装饰器工厂</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">real_decorator</span><span class="params">(origin_func)</span>:</span>          <span class="comment"># 这才是刚刚的装饰器</span></span><br><span class="line"><span class="meta">		@functools.wraps(origin_func)</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">()</span>:</span></span><br><span class="line">			print(&amp;<span class="comment">#39;You said &amp;#39; + str(content)) # 现在输出内容可以由用户指定</span></span><br><span class="line">			origin_func()</span><br><span class="line">		<span class="keyword">return</span> new_func                       <span class="comment"># 在装饰器里，返回的是新的函数</span></span><br><span class="line">	<span class="keyword">return</span> real_decorator                     <span class="comment"># 装饰器工厂返回的是装饰器</span></span><br></pre></td></tr></table></figure>

装饰器工厂和装饰器的区别在于它可以接受参数，返回一个装饰器：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate(2017)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">sayHello()</span><br></pre></td></tr></table></figure>

其实等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real_decorator = decorate(<span class="number">2017</span>)      <span class="comment"># 通过装饰器工厂生成装饰器</span></span><br><span class="line">new_func = real_decorator(sayHello)  <span class="comment"># 正常的装饰器工作逻辑</span></span><br><span class="line">new_func()                           <span class="comment"># 调用的是装饰过的函数</span></span><br></pre></td></tr></table></figure>

## 3 面向对象

### 3.1 对象内存管理

#### 3.1.1 对象不是盒子

C 语言中我们定义变量用到的语法是：

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

这背后的含义是定义了一个 `int` 类型的变量 `a`，相当于申请了一个名为 `a` 的盒子（存储空间），里面装了数字 1。
![](https://diycode.b0.upaiyun.com/photo/2018/d488dd71e0be57efe82f076c550e6a22.png)


然后我们改变 `a` 的值：`a = 2;`，可以打印 `a` 的地址来证明它并没有发生变化。所以只是盒子里装的内容（指针指向的位置）发生了改变：
![](https://diycode.b0.upaiyun.com/photo/2018/63785ebe7adfb514dcc88d4b96a34cad.png)

但是在 Python 中，变量不是盒子。比如同样的定义变量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

这里就不能把 `a` 理解为 `int` 类型的变量了。因为在 Python 中，变量没有类型，值才有，或者说只有对象才有类型。因为即使是数字 1，也是 `int` 类的实例，而变量 `a` 更像是给这个对象贴的一个标签。


![](https://diycode.b0.upaiyun.com/photo/2018/6d30c0da2d2108ccc071c8751c4e7c1a.png)
如果执行赋值语句 `a = 2`，相当于把标签 a 贴在另一个对象上：
![](https://diycode.b0.upaiyun.com/photo/2018/05a4f3b25b942f0656f1759eb5b6dbc6.png)


基于这个认知，我们现在应该更容易理解 2.2.1 节中所说的函数传参规则了。如果传入的是不可变类型，比如 `int`，改变它的值实际上就是把标签挂在新的对象上，自然不会改变原来的参数。如果是可变类型，并且做了修改，那么函数中的变量和外面的变量都是指向同一个对象的标签，所以会共享变化。

#### 3.1.2 默认浅复制

根据上一节的描述，直接把变量赋值给另一个变量， 还算不上复制：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b == a   <span class="comment"># True，等同性校验，会调用 __eq__ 函数，这里只判断内容是否相等</span></span><br><span class="line">b <span class="keyword">is</span> a   <span class="comment"># True，一致性校验，会检查是否是同一个对象，调用 hash() 函数，可以理解为比较指针</span></span><br></pre></td></tr></table></figure>

可见不仅仅数组相同，就连变量也是相同的，可以把 b 理解为 a 的别名。

如果用切片，或者数组的构造函数来创建新的数组，得到的是原数组的浅拷贝：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = list(a)</span><br><span class="line">b == a   <span class="comment"># True，因为数组内容相同</span></span><br><span class="line">b <span class="keyword">is</span> a   <span class="comment"># False，现在 a 和 b 是两个变量，恰好指向同一个数组对象</span></span><br></pre></td></tr></table></figure>

但如果数组中的元素是可变的，可以看到这些元素并没有被完全拷贝：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line">b = list(a)</span><br><span class="line">b[<span class="number">0</span>].append(<span class="number">2</span>)</span><br><span class="line">a <span class="comment"># 得到 [[1, 2], [2], [3]]，因为 a[0] 和 b[0] 其实还是挂在相同对象上的不同标签</span></span><br></pre></td></tr></table></figure>

如果想要深拷贝，需要使用 `copy` 模块的 `deepcopy` 函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy </span><br><span class="line"></span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">b[<span class="number">0</span>].append(<span class="number">2</span>)</span><br><span class="line">b  <span class="comment"># 变成了 [[1, 2], [2], [3]]</span></span><br><span class="line">a  <span class="comment"># 还是 [[1], [2], [3]]</span></span><br></pre></td></tr></table></figure>

此时，不仅仅是每个元素的引用被拷贝，就连每个元素自己也被拷贝。所以现在的 `a[0]` 和 `b[0]` 是指向两个不同对象的两个不同变量（标签），自然就互不干扰了。

如果要实现自定义对象的深复制，只要实现 `__deepcopy__` 函数即可。这个概念在几乎所有面向对象的语言中都会存在，就不详细介绍了。

#### 3.1.3 弱引用

Python 内存管理使用垃圾回收的方式，当没有指向对象的引用时，对象就会被回收。然而对象一直被持有也并非什么好事，比如我们要实现一个缓存，预期目标是缓存中的内容随着真正对象的存在而存在，随着真正对象的消失而消失。如果因为缓存的存在，导致被缓存的对象无法释放，就会导致内存泄漏。

Python 提供了语言级别的支持，我们可以使用 `weakref` 模块，它提供了 `weakref.WeakValueDictionary` 这个弱引用字典来确保字典中的值不会被引用。如果想要获取某个对象的弱引用，可以使用 `weakref.ref(obj)`  函数。

### 3.2 Python 风格的对象

#### 3.2.1 静态函数与类方法

静态函数其实和类的方法没什么关系，它只是恰好定义在类的内部而已，所以这里我用函数（function) 来形容它。它可以没有参数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod   # 用 staticmethod 这个修饰器来表明函数是静态的</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">Person.sayHello() <span class="comment"># 输出 &amp;#39;Hello`</span></span><br></pre></td></tr></table></figure>

静态函数的调用方式是类名加上函数名。类方法的调用方式也是这样，唯一的不同是需要用 `@staticmethod` 修饰器，而且方法的第一个参数必须是类：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">	@classmethod    # 用 classmethod 这个修饰器来表明这是一个类方法</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(cls)</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;Hi: &amp;#39; + cls.__name__)</span></span><br><span class="line">	</span><br><span class="line">Person.sayHi() <span class="comment"># 输出 &amp;#39;Hi: Person`</span></span><br></pre></td></tr></table></figure>

类方法和静态函数的调用方法一致，在定义时除了修饰器不一样，唯一的区别就是类方法需要多声明一个参数。这样看起来比较麻烦，但静态函数无法引用到类对象，自然就无法访问类的任何属性。

于是问题来了，静态函数有何意义呢？有的人说类名可以提供命名空间的概念，但在我看来这种解释并不成立，因为每个 Python 文件都可以作为模块被别的模块引用，把静态函数从类里抽取出来，定义成全局函数，也是有命名空间的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 module1.py 文件中：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">global</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 module2.py 文件中：</span></span><br><span class="line"><span class="keyword">import</span> module1</span><br><span class="line">module1.<span class="keyword">global</span>()        <span class="comment"># 调用全局函数</span></span><br><span class="line">module1.Util.helper()   <span class="comment"># 调用静态函数</span></span><br></pre></td></tr></table></figure>

从这个角度看，定义在类中的静态函数不仅不具备命名空间的优点，甚至调用语法还更加啰嗦。对此，我的理解是：**静态函数可以被继承、重写，但全局函数不行**，由于 Python 中的函数是一等公民，因此很多时候用函数替代类都会使代码更加简洁，但缺点就是无法继承，后面还会有更多这样的例子。

#### 3.2.2 属性 attribute

Python （等多数动态语言）中的类并不像 C/OC/Java 这些静态语言一样，需要预先定义属性。我们可以直接在初始化函数中创建属性：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.name  <span class="comment"># 值是 &amp;#39;bestswifter&amp;#39;</span></span><br></pre></td></tr></table></figure>

由于 `__init__` 函数是运行时调用的，所以我们可以直接给对象添加属性：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bs.age = <span class="number">22</span></span><br><span class="line">bs.age  <span class="comment"># 因为刚刚赋值了，所以现在取到的值是 22</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">如果访问一个不存在的属性，将会抛出异常。从以上特性来看，对象其实和字典非常相似，但这种过于灵活的特性其实蕴含了潜在的风险。比如某个封装好的父类中定义了许多属性， 但是子类的使用者并不一定清楚这一点，他们很可能会不小心就重写了父类的属性。一种隐藏并保护属性的方式是在属性前面加上两个下划线：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.__name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">	</span><br><span class="line">bs = Person()</span><br><span class="line"></span><br><span class="line">bs.__name          <span class="comment"># 这样是无法获取属性的</span></span><br><span class="line">bs._Person__name   <span class="comment"># 这样还是可以读取属性</span></span><br></pre></td></tr></table></figure>

这是因为 Python 会自动处理以双下划线开头的属性，把他们重名为 `_Classname__attrname` 的格式。由于 Python 对象的所有属性都保存在实例的 `__dict__`  属性中，我们可以验证一下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bs = Person()</span><br><span class="line">bs.__dict__ </span><br><span class="line"><span class="comment"># 得到 &#123;&amp;#39;_Person__name&amp;#39;: &amp;#39;bestswifter&amp;#39;&#125;</span></span><br></pre></td></tr></table></figure>

但很多人并不认可通过名称改写（name mangling) 的方式来存储私有属性，原因很简单，只要知道改写规则，依然**很容易的**就能读写私有属性。与其自欺欺人，不如采用更简单，更通用的方法，比如给私有属性前面加上单个下划线 `_`。

注意，以单个下划线开头的属性不会触发任何操作，完全靠自觉与共识。**任何稍有追求的 Python 程序员，都不应该读写这些属性。**

#### 3.2.3 特性 property

使用过别的面向对象语言的读者应该都清楚属性的 `getter` 和 `setter` 函数的重要性。它们封装了属性的读写操作，可以添加一些额外的逻辑，比如校验新值，返回属性前做一些修饰等等。最简陋的 `getter` 和 `setter` 就是两个普通函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.name.upper()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> isinstance(new_name, str):</span><br><span class="line">			self.name = new_name.lower()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.get_name()   <span class="comment"># 得到大写的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br><span class="line">bs.set_name(<span class="number">1</span>)  <span class="comment"># 由于新的名字不是字符串，所以无法赋值</span></span><br><span class="line">bs.get_name()   <span class="comment"># 还是老的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br></pre></td></tr></table></figure>

工作虽然完成了，但方法并不高明。在 1.2.3 节中我们就见识到了 Python 的一个特点：“内部高度封装，完全对外透明”。这里手动调用 `getter` 和 `setter` 方法显得有些愚蠢、啰嗦，比如对比下面的两种写法，在变量名和函数名很长的情况下，差距会更大：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bs.name += &amp;<span class="comment">#39;1995&amp;#39;</span></span><br><span class="line">bs.set_name(bs.get_name() + &amp;<span class="comment">#39;1995&amp;#39;)</span></span><br></pre></td></tr></table></figure>

Python 提供了 `@property` 关键字来装饰 `getter` 和 `setter` 方法，这样的好处是可以直接使用点语法，了解 Objective-C 的读者对这一特性一定倍感亲切：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">	@property                        # 定义 getter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span>                  <span class="comment"># 函数名就是点语法访问的属性名</span></span><br><span class="line">		<span class="keyword">return</span> self._name.upper()    <span class="comment"># 现在真正的属性是 _name 了</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">	@name.setter	                 # 定义 setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, new_name)</span>:</span>        <span class="comment"># 函数名不变</span></span><br><span class="line">		<span class="keyword">if</span> isinstance(new_name, str):</span><br><span class="line">			self._name = new_name.lower()  <span class="comment"># 把值存到私有属性 _name 里</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.name      <span class="comment"># 其实调用了 name 函数，得到大写的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br><span class="line">bs.name = <span class="number">1</span>  <span class="comment"># 其实调用了 name 函数，因为类型不符，无法赋值</span></span><br><span class="line">bs.name      <span class="comment"># 还是老的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br></pre></td></tr></table></figure>

我们已经在 2.4 节详细学习了装饰器，应该能意识到这里的 `@property` 和 `@xxx.setter` 都是装饰器。因此上述写法实际上等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._name.upper()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> isinstance(new_name, str):</span><br><span class="line">			self._name = new_name.lower()</span><br><span class="line">	<span class="comment"># 以上是老旧的 getter 和 setter 定义</span></span><br><span class="line">	<span class="comment"># 如果不用 @property，可以定义一个 property 类的实例</span></span><br><span class="line">	name = property(get_name, set_name)</span><br></pre></td></tr></table></figure>

可见，特性的本质是给类创建了一个类属性，它是 `property` 类的实例，构造方法中需要把 `getter`、`setter` 等函数传入，我们可以打印一下类的 `name` 属性来证明：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.name  <span class="comment"># &amp;lt;property object at 0x107c99868&amp;gt;</span></span><br></pre></td></tr></table></figure>

理解特性的工作原理至关重要。以这里的 `name` 特性为例，我们访问了对象的 `name` 属性，但是它并不存在，所以会尝试访问类的 `name` 属性，这个属性是 `property` 类的实例，会对读写操作做特殊处理。这也意味着，如果我们重写了类的 `name` 属性，那么对象的读写方法就不会生效了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bs = Person()</span><br><span class="line">Person.name = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">bs.name  <span class="comment"># 实例并没有 name 属性，因此会访问到类的属性 name，现在的值是 &amp;#39;hello` 了</span></span><br></pre></td></tr></table></figure>

如果访问不存在的属性，默认会抛出异常，但如果实现了 `__getattr__` 函数，还有一次挽救的机会：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.name    <span class="comment"># 直接访问属性</span></span><br><span class="line">bs.age     <span class="comment"># 得到 0，这是 __getattr__ 方法提供的默认值</span></span><br><span class="line">bs.age = <span class="number">1</span> <span class="comment"># 动态给属性赋值</span></span><br><span class="line">bs.age     <span class="comment"># 得到 1，注意！！！这时候就不会再调用 __getattr__ 方法了</span></span><br></pre></td></tr></table></figure>

由于 `__getattr__` 只是兜底策略，处理一些异常情况，并非每次都能被调用，所以不能把重要的业务逻辑写在这个方法中。

#### 3.2.4 特性工厂

在上一节中，我们利用特性来封装 `getter` 和 `setter`，对外暴露统一的读写接口。但有些 `getter` 和 `setter` 的逻辑其实是可以复用的，比如商品的价格和剩余数量在赋值时，都必须是大于 0 的数字。这时候如果每次都要写一遍 `setter`，代码就显得很冗余，所以我们需要一个能批量生产特性的函数。由于我们已经知道了特性是 `property` 类的实例，而且是类的属性，所以代码可以这样写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">(storage_name)</span>:</span>  <span class="comment"># 定义 getter 和 setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">		    <span class="comment"># 把值保存在实例的 __dict__ 字典中</span></span><br><span class="line">			instance.__dict__[storage_name] = value </span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br><span class="line">	<span class="keyword">return</span> property(qty_getter, qty_setter) <span class="comment"># 返回 property 的实例</span></span><br></pre></td></tr></table></figure>

有了这个特性工厂，我们可以这样来定义特性：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    price = quantity(&amp;<span class="comment">#39;price&amp;#39;)</span></span><br><span class="line">    number = quantity(&amp;<span class="comment">#39;number&amp;#39;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        		</span><br><span class="line">i = Item()</span><br><span class="line">i.price = <span class="number">-1</span> </span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ValueError: value must be &amp;gt; 0</span></span><br></pre></td></tr></table></figure>

作为追求简洁的程序员，我们不禁会问，在 `price = quantity(&#39;price&#39;)` 这行代码中，属性名重复了两次，能不能在 `quantity` 函数中自动读取左边的属性名呢，这样代码就可以简化成 `price = quantity()` 了。

答案显然是否定的，因为右边的函数先被调用，然后才能把结果赋值给左边的变量。不过我们可以采用迂回策略，变相的实现上面的需求：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		quantity.count += <span class="number">1</span></span><br><span class="line">	<span class="keyword">except</span> AttributeError:</span><br><span class="line">		quantity.count = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	storage_name = &amp;<span class="comment">#39;_&#123;&#125;:&#123;&#125;&amp;#39;.format(&amp;#39;quantity&amp;#39;, quantity.count)	</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">			instance.__dict__[storage_name] = value</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br><span class="line">	<span class="keyword">return</span> property(qty_getter, qty_setter)</span><br></pre></td></tr></table></figure>

这段代码中我们利用了两个技巧。首先函数是一等公民， 所以函数也是对象，自然就有属性。所以我们利用 `try ... except` 很容易的就给函数工厂添加了一个计数器对象 `count`，它每次调用都会增加，然后再拼接成存储时用的键 `storage_name` ，并且可以保证不同 `property` 实例的存储键名各不相同。

其次，`storage_name` 在 `getter` 和 `setter` 函数中都被引用到，而这两个函数又被 `property` 的实例引用，所以 `storage_name` 会因为被持有而延长生命周期。这也正是闭包的一大特性：能够捕获自由变量并延长它的生命周期和作用域。

我们来验证一下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    price = quantity()</span><br><span class="line">    number = quantity()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">i = Item()</span><br><span class="line">i.price = <span class="number">1</span></span><br><span class="line">i.number = <span class="number">2</span></span><br><span class="line">i.price     <span class="comment"># 得到 1，可以正常访问</span></span><br><span class="line">i.number    <span class="comment"># 得到 2，可以正常访问</span></span><br><span class="line">i.__dict__  <span class="comment"># &#123;&amp;#39;_quantity:0&amp;#39;: 1, &amp;#39;_quantity:1&amp;#39;: 2&#125;</span></span><br></pre></td></tr></table></figure>

可见现在存储的键名可以被正确地自动生成。

#### 3.2.5 属性描述符

文件描述符的作用和特性工厂一样，都是为了批量的应用特性。它的写法也和特性工厂非常类似：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">		self.storage = storage_name</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[self.storage]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">			instance.__dict__[self.storage] = value</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br></pre></td></tr></table></figure>

主要有以下几个改动：

1. 不用返回 `property` 类的实例了，因此 `getter` 和 `setter` 方法的名字是固定的，这样才能满足协议。
2. `__get__` 方法的第一个参数是描述符类 `Quantity` 的实例，第二个参数 `self` 是要读取属性的实例，比如上面的 `i`，也被称作托管实例。第三个参数是托管类，也就是 `Item`。
3. `__set__` 方法的前两个参数含义类似，第三个则是要读取的属性名，比如 `price`。

和特性工厂类似，属性描述符也可以实现 `storage_name` 的自动生成，这里就不重复代码了。看起来属性描述符和特性工厂几乎一样，但由于属性描述符是类，它就可以继承。比如这里的 `Quantity` 描述符有两个功能：自动存储和值的校验。自动存储是一个非常通用的逻辑，而值的校验是可变的业务逻辑，所以我们可以先定义一个 `AutoStorage` 描述符来实现自动存储功能，然后留下一个空的 `validate` 函数交给子类去重写。

而特性工厂作为函数，自然就没有上述功能，这两者的区别类似于 3.2.1 节中介绍的静态函数与全局函数的区别。

#### 3.2.6 实例属性的查找顺序

我们知道类的属性都会存储在 `__dict__` 字典中，即使没有显式的给属性赋值，但只要字典里面有这个字段，也是可以读取到的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p.__dict__[&amp;<span class="comment">#39;name&amp;#39;] = &amp;#39;bestswifter&amp;#39;</span></span><br><span class="line">p.name  <span class="comment"># 不会报错，而是返回字典中的值，&amp;#39;bestswifter&amp;#39;</span></span><br></pre></td></tr></table></figure>

但我们在特性工厂和属性描述符的实现中，都是直接把属性的值存储在 `__dict__` 中，而且键就是属性名。之前我们还介绍过，特性的工作原理是没有直接访问实例的属性，而是读取了 `property` 的实例。那直接把值存在 `__dict__` 中，会不会导致特性失效，直接访问到原始内容呢？从之前的实践结果来看，答案是否定的，要解释这个问题，我们需要搞明白访问实例属性的查找顺序。

假设有这么一段代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o = cls()   <span class="comment"># 假设 o 是 cls 类的实例</span></span><br><span class="line">o.attr      <span class="comment"># 试图访问 o 的属性 attr</span></span><br></pre></td></tr></table></figure>

再对上一节中的属性描述符做一个简单的分类：

1. 覆盖型描述符：定义了 `__set__` 方法的描述符
2. 非覆盖型描述符：没有定义 `__set__` 方法的描述符

在执行 `o.attr` 时，查找顺序如下：

1. 如果 `attr` 出现在 `cls` 或父类的 `__dict__` 中，且 `attr` 是覆盖型描述符，那么调用 `__get__` 方法。
2. 否则，如果 `attr` 出现在 `o` 的`__dict__` 中，返回 `o.__dict__[attr]`
3. 否则，如果`attr` 出现在 `cls` 或父类的 `__dict__` 中，如果 `attr` 是非覆盖型描述符，那么调用 `__get__` 方法。
4. 否则，如果没有非覆盖型描述符，直接返回 `cls.__dict__[attr]`
5. 否则，如果 `cls` 实现了 `__getattr__` 方法，调用这个方法
6. 抛出 `AttributeError`

所以，在访问类的属性时，覆盖型描述符的优先级是高于直接存储在 `__dict__` 中的值的。

### 3.3 多继承

本节内容部分摘自我的这篇文章：[从 Swift 的面向协议编程说开去](http://www.jianshu.com/p/fc105512bf40)，本节聊的是多继承在 Python 中的知识，如果想阅读关于多继承的讨论，请参考原文。

#### 3.3.1 多继承的必要性

很多语言类的书籍都会介绍，多继承是个危险的行为。诚然，狭义上的多继承在绝大多数情况下都是不合理的。这里所谓的 **“狭义”**，指的是一个类拥有多个父类。我们要明确一个概念：继承的目的不是代码复用，而是声明一种 `is a` 的关系，代码复用只是 `is a` 关系的一种外在表现。

因此，如果你需要狭义上的多继承，还是应该先问问自己，真的存在这么多 `is a` 的关系么？你是需要声明这种关系，还是为了代码复用。如果是后者，有很多更优雅的解决方案，因为多继承的一个直接问题就是菱形问题（Diamond Problem）。

但是广义上的多继承是必须的，不能因为害怕多继承的问题就忽略多继承的优点。**广义多继承** 指的是通过定义接口（Interface）以及接口方法的默认实现，形成“一个父类，多个接口”的模式，最终实现代码的复用。当然，不是每个语言都有接口的概念，比如 Python 里面叫 Mixin，会在 3.3.3 节中介绍。

广义上的多继承非常常见，有一些教科书式的例子，比如动物可以按照哺乳动物，爬行动物等分类，也可以按照有没有翅膀来分类。某一个具体的动物可能满足上述好几类。在实际的开发中也到处都是广义多继承的使用场景，比如 iOS 或者安卓开发中，系统控件的父类都是固定的，如果想让他们复用别的父类的代码，就会比较麻烦。

#### 3.3.2 Python 的多继承
" value="Python 是一门非常容易上手的语言，通过查阅资料和教程，也许一晚上就能写出一个简单的爬虫。但 Python 也是一门很难精通的语言，因为简洁的语法背后隐藏了许多黑科技。本文主要针对的读者是：

1. 毫无 Python 经验的小白
2. 有一些简单 Python 经验，但只会复制粘贴代码，不知其所以然的读者
3. 觉得单独一篇文章太琐碎，质量没保证，却没空读完一本书，但又想对 Python 有全面了解的读者

当然， 用一篇文章来讲完某个语言是不可能的事情，我希望读完本文的读者可以：

1. 对 Python 的整体知识结构形成初步的概念
2. 了解 Python 特有的知识点，比如装饰器、上下文、生成器等等，不仅会写 Demo，还对背后的原理有一定了解
3. 避免 C++/Java 等风格的 Python 代码，能够写出地道的 Python 代码
4. 能够熟练的使用 Python 编写脚本实现日常的简单需求，能够维护小型 Python 项目，能够阅读较复杂的 Python 源码

如果以上介绍符合你对自己的定位，在开始阅读前，还需要明确几点：

1. 本文不会只介绍用法，那样太肤浅
2. 本文不会深入介绍某个知识点，比如分析源码等，那样太啰嗦，我希望做一名引路人，描述各个知识点的概貌并略作引申，为读者指出下一步的研究方向
3. 代码注释非常重要，一定要看，几乎所有的代码段都可以执行，**强烈建议**手敲一遍！

[TOC]

## 0. 准备工作

请不要在学习 Python2 还是 Python3 之间犹豫了，除非你很明确自己只接触 Python2，否则就从 Python3 学起，新版本的语言总是意味着进步的生产力（Swift 和 Xcode 除外）。Python 2 和 3 之间语法不兼容，但这并不影响熟悉 Python3 的开发者迅速写出 Python 2 的代码，反之亦然。所以与其在反复纠结中浪费时间，不如立刻行动起来。

推荐使用 **CodeRunner** 来运行本文中的 demo，它比文本编辑器功能更强大，比如支持自动补全和断点调试，又比 PyCharm 轻量得多。

## 1. 数据结构

### 1.1 数组

#### 1.1.1 列表推导

如果要对数组中的所有内容做一些修改，可以用 for 循环或者 map 函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> array: </span><br><span class="line">	<span class="keyword">if</span> n &amp;lt; <span class="number">4</span>:</span><br><span class="line">		small.append(n * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(small)  <span class="comment"># [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

比较地道的 Python 写法是使用列表推导：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = [n * <span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> array <span class="keyword">if</span> n &amp;lt; <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

`for in` 可以写两次，类似于嵌套的 for 循环，会得到一个笛卡尔积：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signs = [&amp;<span class="comment">#39;+&amp;#39;, &amp;#39;-&amp;#39;]</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">ascii = [&amp;<span class="comment">#39;&#123;sign&#125;&#123;number&#125;&amp;#39;.format(sign=sign, number=number) </span></span><br><span class="line">		<span class="keyword">for</span> sign <span class="keyword">in</span> signs <span class="keyword">for</span> number <span class="keyword">in</span> numbers]</span><br><span class="line"><span class="comment"># 得到：[&amp;#39;+1&amp;#39;, &amp;#39;+2&amp;#39;, &amp;#39;-1&amp;#39;, &amp;#39;-2&amp;#39;]</span></span><br></pre></td></tr></table></figure>

#### 1.1.2 元组

元组可以简单的理解为不可变的数组，也就是没有 `append`、`del` 等方法，一旦创建，就无法新增或删除元素，元素自身的值也不能改变，但元素内部的属性是否可变并不受元组的影响，这一点符合其他语言中的常识。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, [])</span><br><span class="line">t[<span class="number">0</span>] = <span class="number">3</span>  <span class="comment"># 抛出错误 TypeError: &amp;#39;tuple&amp;#39; object does not support item assignment</span></span><br><span class="line">t[<span class="number">1</span>].append(<span class="number">2</span>)  <span class="comment"># 正常运行，现在的 t 是 (1, [2])</span></span><br></pre></td></tr></table></figure>

除了不可变性以外，有时候元组也会被当做不具名的数据结构，这时候元素的位置就不再是可有可无的了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coordinate = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>)</span><br><span class="line"><span class="comment"># coordinate 的第一个位置用来表示经度，第二个位置表示纬度</span></span><br></pre></td></tr></table></figure>

在解析元组数据时，可以一一对应的写上变量名：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, b = t <span class="comment"># a = 1, b = 2</span></span><br></pre></td></tr></table></figure>

有时候变量名比较长， 但我只关心其中某一个，可以这样写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, _ = t <span class="comment"># a = 1</span></span><br></pre></td></tr></table></figure>

如果元组中元素特别多，即使挨个写下划线也比较累，可以用 \* 来批量解包：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">first, *middle, last = t</span><br><span class="line"><span class="comment"># first = 1</span></span><br><span class="line"><span class="comment"># middle = [2, 3, 4]</span></span><br><span class="line"><span class="comment"># last = 5</span></span><br></pre></td></tr></table></figure>

当然，如果元素数量较多，含义较复杂，我还是建议使用具名元组：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">People = collections.namedtuple(&amp;<span class="comment">#39;People&amp;#39;, [&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;])</span></span><br><span class="line">p = People(&amp;<span class="comment">#39;bestswifter&amp;#39;, &amp;#39;22&amp;#39;)</span></span><br><span class="line">p.name <span class="comment"># bestswifter</span></span><br></pre></td></tr></table></figure>

具名元组更像是一个不能定义方法的简化版的类，能提供友好的数据展示。


元组的一个小技巧是可以避免用临时变量来交换两个数的值：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> </span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a, b = b, a</span><br><span class="line"><span class="comment"># a = 2, b = 1</span></span><br></pre></td></tr></table></figure>

#### 1.1.3 数组切片

切片的基本格式是 `array[start:end:step]`，表示对 array 在 start 到 end 之前以 step 为间隔取切片。注意这里的区间是 [start, end)，也就是左闭右开。比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 表示取 s 的第 0、2、4 个字符，结果是 &amp;#39;hlo&amp;#39;</span></span><br></pre></td></tr></table></figure>

再举几个例子

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>:<span class="number">5</span>]  <span class="comment"># 不写 step 默认就是 1，因此得到 &amp;#39;hello&amp;#39;</span></span><br><span class="line">s[<span class="number">1</span>:]   <span class="comment"># 不写 end 默认到结尾，因此还是得到 &amp;#39;ello&amp;#39;</span></span><br><span class="line">s[n:]   <span class="comment"># 获取 s 的最后 len(s) - n 个元素</span></span><br><span class="line">s[:<span class="number">2</span>]   <span class="comment"># 不写 start 默认从 0 开始，因此得到 &amp;#39;he&amp;#39;</span></span><br><span class="line">s[:n]   <span class="comment"># 获取 s 的前 n 个元素</span></span><br><span class="line">s[:<span class="number">-1</span>]  <span class="comment"># 负数表示倒过来数，因此这会刨除最后一个字符，得到 &amp;#39;hell&amp;#39;</span></span><br><span class="line">s[<span class="number">-2</span>:]  <span class="comment"># 同上，表示获取最后两个字符，得到 &amp;#39;lo&amp;#39;</span></span><br><span class="line">s[::<span class="number">-1</span>] <span class="comment"># 获取字符串的倒序排列，相当于 reverse 函数</span></span><br></pre></td></tr></table></figure>

 step 和它前面的冒号要么同时写，要么同时不写，但 start 和 end 之间的冒号不能省，否则就不是切片而是获取元素了。再次强调 `array[start:end]` 表示的区间是 [a, b)，也许你会觉得这很难记，但同样的，这会得出以下美妙的公式：

&gt; array[:n] + array[n:] = array (0 &lt;= n &lt;= len(array))

用代码来表示就是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">s[:<span class="number">2</span>] + s[<span class="number">2</span>:] == s  </span><br><span class="line"><span class="comment"># True，因为 s[:2] 是 &amp;#39;he&amp;#39;，s[2:] 是 &amp;#39;llo&amp;#39;</span></span><br></pre></td></tr></table></figure>

切片不仅可以用来获取数组的一部分值，修改切片也可以直接修改数组的对应部分，比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"><span class="comment"># a = [1, 22, 33, 44, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

并没有人规定切片的新值必须和原来的长度一致：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">3</span>]</span><br><span class="line"><span class="comment"># a = [1, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>] = []</span><br><span class="line"><span class="comment"># a = [1, 6]，相当于删除了中间的三个数字</span></span><br></pre></td></tr></table></figure>

但切片的新值必须也是可迭代的对象，比如这样写是不合法的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment"># TypeError: can only assign an iterable</span></span><br></pre></td></tr></table></figure>

#### 1.1.4 循环与遍历

一般来说，在 Python 中我们不会写出 `for (int i = 0; i &lt; len(array); ++i)` 这种风格的代码，而是使用 `for in` 这种语法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

虽然大家都知道 `for in` 语法，但它的某些灵活用法或许就不是那么众所周知了。有时候，我们会在 `if` 语句中对某个变量的值做多次判断，只要满足一个条件即可：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &amp;<span class="comment">#39;bs&amp;#39;</span></span><br><span class="line"><span class="keyword">if</span> name == &amp;<span class="comment">#39;hello&amp;#39; or name == &amp;#39;hi&amp;#39; or name == &amp;#39;bs&amp;#39; or name == &amp;#39;admin&amp;#39;:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Valid&amp;#39;)</span></span><br></pre></td></tr></table></figure>

这种情况推荐用 `in` 来代替：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &amp;<span class="comment">#39;bs&amp;#39;</span></span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">in</span> (&amp;<span class="comment">#39;hello&amp;#39;, &amp;#39;hi&amp;#39;, &amp;#39;bs&amp;#39;, &amp;#39;admin&amp;#39;):</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Valid&amp;#39;)</span></span><br></pre></td></tr></table></figure>

有时候，如果我们想要把某件事重复固定的次数，用 `for in` 会显得有些啰嗦，这时候可以借助 `range` 类型：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">	print(&amp;<span class="comment">#39;Hi&amp;#39;) # 打印五次 &amp;#39;Hi&amp;#39;</span></span><br></pre></td></tr></table></figure>

`range` 的语法和切片类似，比如我们需要访问数组所有奇数下标的元素，可以这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a), <span class="number">2</span>):</span><br><span class="line">	print(a[i])</span><br></pre></td></tr></table></figure>

在这种写法中，我们不仅能获得元素，还能知道元素的下标，这与使用 `enumerate(iterable [, start ])` 函数类似：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(a):</span><br><span class="line">	print(i, n)</span><br></pre></td></tr></table></figure>

#### 1.1.5 魔术方法

也许你已经注意到了，数组和字符串都支持切片，而且语法高度统一。这在某些强类型语言（比如我经常接触的 Objective-C 和 Java）中是不可能的，事实上，Python 能够支持这样统一的语法，并非巧合，而是因为所有用中括号进行下标访问的操作，其实都是调用这个类的 `__getitem__` 方法。

比如我们完全可以让自己的类也支持通过下标访问：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.chapters = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.chapters[n]</span><br><span class="line">				</span><br><span class="line">b = Book()</span><br><span class="line">print(b[<span class="number">1</span>]) <span class="comment"># 结果是 2</span></span><br></pre></td></tr></table></figure>

需要注意的是，这段代码几乎不会出问题（除非数组越界），这是因为我们直接把下标传到了内部的 `self.chapters` 数组上。但如果要自己处理下标，需要牢记它不一定是数字，也可以是切片，因此更完整的逻辑应该是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> isinstance(n, int): <span class="comment"># n是索引</span></span><br><span class="line">		<span class="comment"># 处理索引</span></span><br><span class="line">	<span class="keyword">if</span> isinstance(n, slice): <span class="comment"># n是切片</span></span><br><span class="line">		<span class="comment"># 通过 n.start，n.stop 和 n.step 来处理切片</span></span><br></pre></td></tr></table></figure>

与静态语言不同的是，任何实现了 `__getitem__` 都支持通过下标访问，而不用声明为实现了某个协议，这种特性也被称为 “鸭子类型”。鸭子类型并不要求某个类 **是什么**，仅仅要求这个类 **能做什么**。

顺便说一句，实现了 `__getitem__` 方法的类都是可迭代的，比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = Book()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> b:</span><br><span class="line">	print(c)</span><br></pre></td></tr></table></figure>

后续的章节还会介绍更多 Python 中的魔术方法，这种方法的名称前后都有两个下划线，如果读作 “下划线-下划线-getitem” 会比较拗口，因此可以读作 “dunder-getitem” 或者 “双下-getitem”，类似的，我想每个人都能猜到 `__setitem__` 的作用和用法。

### 1.2 字典

#### 1.2.1 初始化字典

最简单的创建一个字典的方式就是直接写字面量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62, &amp;#39;c&amp;#39;: 63, &amp;#39;d&amp;#39;: 64, &amp;#39;e&amp;#39;: 65&#125;</span></span><br></pre></td></tr></table></figure>

字典字面量由大括号包住（注意区别于数组的中括号），键值对之间由逗号分割，每个键值对内部用冒号分割键和值。

如果数组的每个元素都是二元的元组，这个数组可以直接转成字典：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict([(&amp;<span class="comment">#39;a&amp;#39;, 61), (&amp;#39;b&amp;#39;, 62), (&amp;#39;c&amp;#39;, 63), (&amp;#39;d&amp;#39;, 64), (&amp;#39;e&amp;#39;, 65)])</span></span><br></pre></td></tr></table></figure>

就像数组可以推导一样，字典也可以推导：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [(&amp;<span class="comment">#39;a&amp;#39;, 61), (&amp;#39;b&amp;#39;, 62), (&amp;#39;c&amp;#39;, 63), (&amp;#39;d&amp;#39;, 64), (&amp;#39;e&amp;#39;, 65)]</span></span><br><span class="line">d = &#123;letter: number <span class="keyword">for</span> letter, number <span class="keyword">in</span> a&#125; <span class="comment"># 这里用到了元组拆包</span></span><br></pre></td></tr></table></figure>

只要记得外面还是大括号就行了。

两个独立的数组可以被压缩成一个字典：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>]</span><br><span class="line">letters = [&amp;<span class="comment">#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br><span class="line">dict(zip(letters, numbers))</span><br></pre></td></tr></table></figure>

正如 zip 的意思所表示的，超出长处的那部分数组会被抛弃。

#### 1.2.2 查询字典

最简单方法是直接写键名，但如果键名不存在会抛出 `KeyError`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61&#125;</span></span><br><span class="line">d[&amp;<span class="comment">#39;a&amp;#39;] # 值是 61</span></span><br><span class="line">d[&amp;<span class="comment">#39;b&amp;#39;] # KeyError: &amp;#39;b&amp;#39;</span></span><br></pre></td></tr></table></figure>

可以用 `if key in dict` 的判断来检查键是否存在，甚至可以先 `try` 再 `catch KeyError` ，但更加优雅简洁一些的写法是用 `get(k, default)` 方法来提供默认值：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61&#125;</span></span><br><span class="line">d.get(&amp;<span class="comment">#39;a&amp;#39;, 62) # 得到 61</span></span><br><span class="line">d.get(&amp;<span class="comment">#39;b&amp;#39;, 62) # 得到 62</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">不过有时候，我们可能不仅仅要读出默认属性，更希望能把这个默认属性能写入到字典中，比如：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="comment"># 我们想对字典中某个 Value 做操作，如果 Key 不存在，就先写入一个空值</span></span><br><span class="line"><span class="keyword">if</span> &amp;<span class="comment">#39;list&amp;#39; not in d:</span></span><br><span class="line">	d[&amp;<span class="comment">#39;list&amp;#39;] = []</span></span><br><span class="line">d[&amp;<span class="comment">#39;list&amp;#39;].append(1)</span></span><br></pre></td></tr></table></figure>

这种情况下，`setdefault(key, default)` 函数或许更合适：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.setdefault(&amp;<span class="comment">#39;key&amp;#39;, []).append(1)</span></span><br></pre></td></tr></table></figure>

这个函数虽然名为 `set`，但作用其实是查找，仅仅在查找不到时才会把默认值写入字典。

#### 1.2.3 遍历字典

直接遍历字典实际上是遍历了字典的键，因此也可以通过键获取值：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62, &amp;#39;c&amp;#39;: 63, &amp;#39;d&amp;#39;: 64, &amp;#39;e&amp;#39;: 65&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">	print(i, d[i])</span><br><span class="line"><span class="comment">#b 62</span></span><br><span class="line"><span class="comment">#a 61</span></span><br><span class="line"><span class="comment">#e 65</span></span><br><span class="line"><span class="comment">#d 64</span></span><br><span class="line"><span class="comment">#c 63</span></span><br></pre></td></tr></table></figure>

我们也可以用字典的 `keys()` 或者 `values()` 方法显式的获取键和值。字典还有一个 `items()` 方法，它返回一个数组，每个元素都是由键和值组成的二元元组：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62, &amp;#39;c&amp;#39;: 63, &amp;#39;d&amp;#39;: 64, &amp;#39;e&amp;#39;: 65&#125;</span></span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> d.items():</span><br><span class="line">	print(k, v)</span><br><span class="line"><span class="comment">#e 65</span></span><br><span class="line"><span class="comment">#d 64</span></span><br><span class="line"><span class="comment">#a 61</span></span><br><span class="line"><span class="comment">#c 63</span></span><br><span class="line"><span class="comment">#b 62</span></span><br></pre></td></tr></table></figure>

可见 `items()` 方法和字典的构造方法互为逆操作，因为这个公式总是成立的：

&gt; dict(d.items()) == d

#### 1.2.4 字典的魔术方法

在 1.1.4 节中介绍过，通过下标访问最终都会由 `__getitem__` 这个魔术方法处理，因此字典的 `d[key]` 这种写法也不例外， 如果键不存在，则会走到 `__missing__` 方法，再给一次挽救的机会。比如我们可以实现一个字典， 自动忽略键的大小写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> key.islower():</span><br><span class="line">			<span class="keyword">raise</span> KeyError(key)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> self[key.lower()]</span><br><span class="line">			</span><br><span class="line">d = MyDict(&#123;&amp;<span class="comment">#39;a&amp;#39;: 61&#125;)</span></span><br><span class="line">d[&amp;<span class="comment">#39;A&amp;#39;] # 返回 61</span></span><br><span class="line">&amp;<span class="comment">#39;A&amp;#39; in d # False</span></span><br></pre></td></tr></table></figure>

这个字典比较简陋，比如 key 可能不是字符串，不过我没有处理太多情况，因为它主要是用来演示 `__missing__` 的用法，如果想要最后一行的 `in` 语法正确工作，需要重写 `__contains__` 这个魔术方法，过程类似，就不赘述了。

虽然通过自定义的函数也能实现相似的效果，不过这个自定义字典对用户更加透明，如果不在文档中说明，调用方很难察觉到字典的内部逻辑被修改了。 Python 有很多强大的功能，可以具备这种内部进行修改，但是对外保持透明的能力。这可能是我们第一次体会到，后续还会不断的经历。

#### 1.2.5 集合

集合更像是不会有重复元素的数组，但它的本质是以元素的哈希值作为 Key，从而实现去重的逻辑。因此，集合也可以推导，不过得用字典的语法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">d = &#123;i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &amp;lt; <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># d = &#123;1, 2, 3, 4&#125;，注意这里的大括号</span></span><br></pre></td></tr></table></figure>

回忆一下，二进制逻辑运算一共有三个运算符，按位或 `|`，按位与 `&amp;` 和异或 `^`，这三个运算符也可以用在集合之间，而且含义变化不大。比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a | b</span><br><span class="line"><span class="comment"># c = &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

这里的 `|` 运算表示并集，也就是 c 中的任意元素，要么在 a，要么在 b 集合中。类似的，按位与 `&amp;` 运算求的就是交集：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a &amp;amp; b</span><br><span class="line"><span class="comment"># c = &#123;3&#125;</span></span><br></pre></td></tr></table></figure>

而异或则表示那些只在 a 不在 b 或者只在 b 不在 a 的元素。或者换个说法，表示那些在集合 a 和 b 中出现了且仅出现了一次的元素：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a ^ b</span><br><span class="line"><span class="comment"># c = &#123;1, 2, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

还有一个差集运算 `-`，表示在集合 a 中但不在集合 b 中的元素：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a - b</span><br><span class="line"><span class="comment"># c = &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>

回忆一下韦恩图，就会得到以下公式（虽然并没有什么卵用）：

&gt; A | B = (A ^ B) | (A &amp; B)
&gt; A ^ B = (A - B) | (B - A)

### 1.3 字符串

#### 1.3.1 字符串编码

用 Python 写过爬虫的人都应该感受过被字符串编码支配的恐惧。简单来说，编码指的是将可读的字符串转换成不太可读的数字，用来存储或者传输。解码则指的是将数字还原成字符串的过程。常见的编码有 ASCII、GBK 等。

ASCII 编码是一个相当小的字符集合，只有一百多个常用的字符，因此只用一个字节（8 位）就能表示，为了存储本国语言，各个国家都开发出了自己的编码，比如中文的 GBK。这就带来了一个问题，如果我想要在一篇文章中同时写中文和日文，就无法实现了，除非能对每个字符指定编码，这个成本高到无法接受。

Unicode 则是一个最全的编码方式，每个 Unicode 字符占据 6 个字节，可以表示出 2 ^ 48 种字符。但随之而来的是 Unicode 编码后的内容不适合存储和发送，因此诞生了基于 Unicode 的再次编码，目的是为了更高效的存储。

更详细的概念分析和配图说明可以参考我的这篇文章：[字符串编码入门科普](http://fullstack.blog/2017/09/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E5%85%A5%E9%97%A8%E7%A7%91%E6%99%AE/)，这里我们主要聊聊 Python 对字符串编码的处理。

首先，编码的函数是 `encode`，它是字符串的方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">s.encode()         <span class="comment"># 得到 b&amp;#39;hello&amp;#39;</span></span><br><span class="line">s.encode(&amp;<span class="comment">#39;utf16&amp;#39;)  # 得到 b&amp;#39;\xff\xfeh\x00e\x00l\x00l\x00o\x00&amp;#39;</span></span><br></pre></td></tr></table></figure>

`encode` 函数有两个参数，第一个参数不写表示使用默认的 `utf8` 编码，理论上会输出二进制格式的编码结果，但在终端打印时，被自动还原回字符串了。如果用 `utf16` 进行编码，则会看到编码以后的二进制结果。

前面说过，编码是字符转到二进制的转化过程，有时候在某个编码规范中，并没有指定某个字符是如何编码的，也就是找不到对应的数字，这时候编码就会报错：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">city = &amp;<span class="comment">#39;São Paulo&amp;#39;</span></span><br><span class="line">b_city = city.encode(&amp;<span class="comment">#39;cp437&amp;#39;)</span></span><br><span class="line"><span class="comment"># UnicodeEncodeError: &amp;#39;charmap&amp;#39; codec can&amp;#39;t encode character &amp;#39;\xe3&amp;#39; in position 1: character maps to &amp;lt;undefined&amp;gt;</span></span><br></pre></td></tr></table></figure>

此时需要用到 `encode` 函数的第二个参数，用来指定遇到错误时的行为。它的值可以是 `&#39;ignore&#39;`，表示忽略这个不能编码的字符，也可以是 `&#39;replace&#39;`，表示用默认字符代替：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b_city = city.encode(&amp;<span class="comment">#39;cp437&amp;#39;, errors=&amp;#39;ignore&amp;#39;) </span></span><br><span class="line"><span class="comment"># b&amp;#39;So Paulo&amp;#39;</span></span><br><span class="line">b_city = city.encode(&amp;<span class="comment">#39;cp437&amp;#39;, errors=&amp;#39;replace&amp;#39;)</span></span><br><span class="line"><span class="comment"># b&amp;#39;S?o Paulo&amp;#39;</span></span><br></pre></td></tr></table></figure>

`decode` 完全是 `encode` 的逆操作，只有二进制类型才有这个函数。它的两个参数含义和 `encode` 函数完全一致，就不再介绍了。

从理论上来说，仅从编码后的内容上来看，是无法确定编码方式的，也无法解码出原来的字符。但不同的编码有各自的特点，虽然无法完全倒推，但可以从概率上来猜测，如果发现某个二进制内容，有 99% 的可能性是 `utf8` 编码生成的，我们就可以用 `utf8` 进行解码。Python 提供了一个强大的工具包 `Chardet`  来完成这一任务：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octets = b&amp;<span class="comment">#39;Montr\xe9al&amp;#39;</span></span><br><span class="line">chardet.detect(octets)</span><br><span class="line"><span class="comment"># &#123;&amp;#39;encoding&amp;#39;: &amp;#39;ISO-8859-1&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;&#125;</span></span><br><span class="line">octets.decode(&amp;<span class="comment">#39;ISO-8859-1&amp;#39;)</span></span><br><span class="line"><span class="comment"># Montréal</span></span><br></pre></td></tr></table></figure>

返回结果中包含了猜测的编码方式，以及可信度。可信度越高，说明是这种编码方式的可能性越大。

有时候，我们拿到的是二进制的字符串字面量，比如 `68 65 6c 6c 6f`，前文说过只有二进制类型才有 `decode` 函数，所以需要通过二进制的字面量生成二进制变量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;68 65 6c 6c 6f&amp;#39;</span></span><br><span class="line">b = bytearray.fromhex(s)</span><br><span class="line">b.decode()  <span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

#### 1.3.2 字符串的常用方法

字符串的 `split(sep, maxsplit)` 方法可以以指定的分隔符进行分割，有点类似于 Shell 中的 `awk -F &#39; &#39;`&#39;，第一个 `sep` 参数表示分隔符，不填则为空格：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;a b c d e&amp;#39;</span></span><br><span class="line">a = s.split()</span><br><span class="line"><span class="comment"># a = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br></pre></td></tr></table></figure>

第二个参数 `maxsplit` 表示最多分割多少次，因此返回数组的长度是 `maxsplit + 1`。举个例子说明下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;a;b;c;d;e&amp;#39;</span></span><br><span class="line">a = s.split(&amp;<span class="comment">#39;;&amp;#39;)</span></span><br><span class="line"><span class="comment"># a = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br><span class="line"></span><br><span class="line">b = s.split(&amp;<span class="comment">#39;;&amp;#39;, 2)</span></span><br><span class="line"><span class="comment"># b = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c;d;e&amp;#39;]</span></span><br></pre></td></tr></table></figure>

如果想批量替换，则可以用 `replace(old, new[, count])` 方法，由中括号括起来的参数表示选填。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &amp;<span class="comment">#39;a;b;c;d;e&amp;#39;</span></span><br><span class="line">new = old.replace(&amp;<span class="comment">#39;;&amp;#39;, &amp;#39; &amp;#39;, 3)</span></span><br><span class="line"><span class="comment"># new = &amp;#39;a b c d;e&amp;#39;</span></span><br></pre></td></tr></table></figure>

`strip[chars]` 用于移除指定的字符们：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &amp;quot;*****!!!Hello!!!*****&amp;quot;</span><br><span class="line">new = old.strip(&amp;<span class="comment">#39;*&amp;#39;)  # 得到 &amp;#39;!!!Hello!!!&amp;#39;</span></span><br><span class="line">new = old.strip(&amp;<span class="comment">#39;*！&amp;#39;)  # 得到 &amp;#39;Hello&amp;#39;</span></span><br></pre></td></tr></table></figure>

如果不传参数，则默认移除空格。其实 `strip` 等价于分别执行 `lstrip()` 和 `rstrip()`，即分别从左侧和右侧进行移除。比如 `lstrip()` 表示从左侧第一个字符开始，移除空格，直到第一个非空格字符为止，所以字符串中间的空格，无论是 `lstrip` 还是 `strip()` 都是无法移除的。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &amp;<span class="comment">#39;  Hello world  &amp;#39;</span></span><br><span class="line">new = old.strip()   <span class="comment"># 得到 &amp;#39;Hello wrold&amp;#39;</span></span><br><span class="line">new = old.lstrip()  <span class="comment"># 得到 &amp;#39;Hello world  &amp;#39;</span></span><br></pre></td></tr></table></figure>

最后一个常用方法是 `join`，其实这个可以理解为字符串的构造方法，它可以把数组转换成字符串：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = &amp;<span class="comment">#39;a b c d e&amp;#39;.split() # 之前说过，结果是 [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br><span class="line">s = &amp;<span class="comment">#39;;&amp;#39;.join(array) # 以分号为连接符，把数组中的元素连接起来</span></span><br><span class="line"><span class="comment"># s = &amp;#39;a;b;c;d;e&amp;#39;</span></span><br></pre></td></tr></table></figure>

所以 `join` 可以理解为 `split` 的逆操作，这个公式始终是成立的：

&gt; c.join(string.split(c)) = string

上面这些字符串处理的函数，大多返回的还是字符串，因此可以链式调用，避免使用临时变量和多行代码，但也要避免过长（超过 3 个）的链式调用，以免影响可读性。

#### 1.3.3 字符串格式化

最初级的字符串格式化方法是使用 `+` 来拼接：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">		self.age = <span class="number">22</span></span><br><span class="line">		self.sex = &amp;<span class="comment">#39;m&amp;#39;</span></span><br><span class="line">		</span><br><span class="line">p = Person()</span><br><span class="line">print(&amp;<span class="comment">#39;Name: &amp;#39; + p.name + &amp;#39;, Age: &amp;#39; + str(p.age) + &amp;#39;, Sex: &amp;#39; + p.sex)</span></span><br><span class="line"><span class="comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span></span><br></pre></td></tr></table></figure>

这里必须要把 `int` 类型的年龄转成字符串以后才能进行拼接，这是因为 Python 是强类型语言，不支持类型的隐式转换。

这种做法的缺点在于如果输出结构比较复杂，极容易出现引号匹配错误的问题，可读性非常低。

Python 2 中的做法是使用占位符，类似于 C 语言中 `printf`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content = &amp;<span class="comment">#39;Name: %s, Age: %i, Sex: %c&amp;#39; % (p.name, p.age, p.sex)</span></span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>

从结构上看，要比上一种写法清楚得多， 但每个变量都需要指定类型，这和 Python 的简洁不符。实际上每个对象都可以通过 `str()` 函数转换成字符串，这个函数的背后是 `__str__` 魔术方法。

Python 3 中的写法是使用 `format` 函数，比如我们来实现一下 `__str__` 方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">		self.age = <span class="number">22</span></span><br><span class="line">		self.sex = &amp;<span class="comment">#39;m&amp;#39;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="comment">#39;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&amp;#39;.format(user=self)</span></span><br><span class="line">			</span><br><span class="line">p = Person()</span><br><span class="line">print(p)</span><br><span class="line"><span class="comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span></span><br></pre></td></tr></table></figure>

除了把对象传给 `format` 函数并在字符串中展开以外， 也可以传入多个参数，并且通过下标访问他们：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&amp;<span class="comment">#39;&#123;0&#125;, &#123;1&#125;, &#123;0&#125;&amp;#39;.format(1, 2))</span></span><br><span class="line"><span class="comment"># 输出：1, 2, 1，这里的 &#123;1&#125; 表示第二个参数</span></span><br></pre></td></tr></table></figure>

#### 1.3.4 HereDoc

Heredoc 不是 Python 特有的概念， 命令行和各种脚本中都会见到，它表示一种所见即所得的文本。

假设我们在写一个 HTML 的模板，绝大多数字符串都是常量，只有有限的几个地方会用变量去替换，那这个字符串该如何表示呢？一种写法是直接用单引号去定义：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;\nFriends CGI Demo&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;\n&amp;lt;BODY&amp;gt;&amp;lt;H3&amp;gt;ERROR&amp;lt;/H3&amp;gt;\n&amp;lt;B&amp;gt;%s&amp;lt;/B&amp;gt;&amp;lt;P&amp;gt;\n&amp;lt;FORM&amp;gt;&amp;lt;INPUT TYPE=button VALUE=Back\nONCLICK=\&amp;#39;window.history.back()\&amp;#39;&amp;gt;&amp;lt;/FORM&amp;gt;\n&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;&amp;#39;</span></span><br></pre></td></tr></table></figure>

这段代码是自动生成的还好，如果是手动维护的，那么可读性就非常差，因为换行符和转义后的引号增加了理解的难度。如果用 heredoc 来写，就非常简单了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;&amp;#39;&amp;#39;&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;</span></span><br><span class="line">Friends CGI Demo&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;</span><br><span class="line">&amp;lt;BODY&amp;gt;&amp;lt;H3&amp;gt;ERROR&amp;lt;/H3&amp;gt;</span><br><span class="line">&amp;lt;B&amp;gt;%s&amp;lt;/B&amp;gt;&amp;lt;P&amp;gt;</span><br><span class="line">&amp;lt;FORM&amp;gt;&amp;lt;INPUT TYPE=button VALUE=Back</span><br><span class="line">ONCLICK=&amp;<span class="comment">#39;window.history.back()&amp;#39;&amp;gt;&amp;lt;/FORM&amp;gt;</span></span><br><span class="line">&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;</span><br><span class="line">&amp;<span class="comment">#39;&amp;#39;&amp;#39;</span></span><br></pre></td></tr></table></figure>

Heredoc 主要是用来书写大段的字符串常量，比如 HTML 模板，SQL语句等等。

## 2 函数

### 2.1 函数是一等公民

一等公民指的是 Python 的函数能够动态创建，能赋值给别的变量，能作为参传给函数，也能作为函数的返回值。总而言之，函数和普通变量并没有什么区别。

函数是一等公民，这是函数式编程的基础，然而 Python 中基本上不会使用 lambda 表达式，因为在 lambda 表达式的中仅能使用单纯的表达式，不能赋值，不能使用 while、try 等语句，因此 lambda 表达式要么难以阅读，要么根本无法写出。这极大的限制了 lambda 表达式的使用场景。

上文说过，函数和普通变量没什么区别，但普通变量并不是函数，因为这些变量无法调用。但如果某个类实现了 `__call__` 这个魔术方法，这个类的实例就都可以像函数一样被调用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">		self.age = <span class="number">22</span></span><br><span class="line">		self.sex = &amp;<span class="comment">#39;m&amp;#39;</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(self)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="comment">#39;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&amp;#39;.format(user=self)</span></span><br><span class="line">			</span><br><span class="line">p = Person()</span><br><span class="line">p() <span class="comment"># 等价于 print(p)</span></span><br></pre></td></tr></table></figure>

### 2.2 函数参数

#### 2.2.1 函数传参

对于熟悉 C 系列语言的人来说，函数传参的方式一目了然。默认是拷贝传值，如果传指针是引用传值。我们先来看一段简单的 Python 代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg = <span class="number">5</span></span><br><span class="line">	print(arg)</span><br><span class="line">	</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">foo(a)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 输出 5 和 1</span></span><br></pre></td></tr></table></figure>

这段代码的结果符合我们的预期，从这段代码来看，Python 也属于拷贝传值。但如果再看这段代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg.append(<span class="number">1</span>)</span><br><span class="line">	print(arg)</span><br><span class="line">	</span><br><span class="line">a = [<span class="number">1</span>]</span><br><span class="line">foo(a)</span><br><span class="line">print(a) <span class="comment"># 输出两个 [1, 1]</span></span><br></pre></td></tr></table></figure>

你会发现参数数组在函数内部被改变了。就像是 C 语言中传递了变量的指针一样。所以 Python 到底是拷贝传值还是引用传值呢？答案**都是否定的**！

Python 的传值方式可以被理解为混合传值。对于那些不可变的对象（比如 1.1.2 节中介绍过的元组，还有数字、字符串类型），传值方式是拷贝传值；对于那些可变对象（比如数组和字典）则是引用传值。

#### 2.2.2 默认参数

Python 的函数可以有默认值，这个功能很好用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, l=[])</span>:</span></span><br><span class="line">	l.append(a)</span><br><span class="line">	<span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>,[<span class="number">1</span>])  <span class="comment"># 给数组 [1] 添加一个元素 2，得到 [1,2]</span></span><br><span class="line">foo(<span class="number">2</span>)      <span class="comment"># 没有传入数组，使用默认的空数组，得到 [2]</span></span><br></pre></td></tr></table></figure>

然而如果这样调用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">2</span>)  <span class="comment"># 利用默认参数，得到 [2]</span></span><br><span class="line">foo(<span class="number">3</span>)  <span class="comment"># 竟然得到了 [2, 3]</span></span><br></pre></td></tr></table></figure>

函数调用了两次以后，默认参数被改变了，也就是说函数调用产生了副作用。这是因为默认参数的存储并不像函数里的临时变量一样存储在栈上、随着函数调用结束而释放，而是存储在函数这个对象的内部：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.__defaults__  <span class="comment"># 一开始确实是空数组</span></span><br><span class="line">foo(<span class="number">2</span>)  <span class="comment"># 利用默认参数，得到 [2]</span></span><br><span class="line">foo.__defaults__  <span class="comment"># 如果打印出来看，已经变成 [2] 了</span></span><br><span class="line">foo(<span class="number">3</span>)  <span class="comment"># 再添加一个元素就得到了 [2, 3]</span></span><br></pre></td></tr></table></figure>

因为函数 `foo` 作为一个对象，不会被释放，因此这个对象内部的属性也不会随着多次调用而自动重置，会一直保持上次发生的变化。基于这个前提，我们得出一个结论：**函数的默认参数不允许是可变对象**，比如这里的 `foo` 函数需要这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, l=None)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> l <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">		l = []</span><br><span class="line">	l.append(a)</span><br><span class="line">	<span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">print(foo(<span class="number">2</span>)) <span class="comment"># 得到 [2]</span></span><br><span class="line">print(foo(<span class="number">3</span>)) <span class="comment"># 得到 [3]</span></span><br></pre></td></tr></table></figure>

现在，给参数添加默认值的行为在函数体中完成，不会随着函数的多次调用而累积。

对于 Python 的默认参数来说：

&gt; 如果默认值是不可变的，可以直接设置默认值，否则要设置为 None 并在函数体中设置默认值。

#### 2.2.3 多参数传递

当参数个数不确定时，可以在参数名前加一个 `*`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args)</span>:</span></span><br><span class="line">	print(args)</span><br><span class="line">	</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

如果直接把数组作为参数传入，它其实是单个参数，如果要把数组中所有元素都作为单独的参数传入，则在数组前面加上 `*`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]	</span><br><span class="line">foo(a)  <span class="comment"># 会输出 ([1,2,3], )   因为只传了一个数组作为参数</span></span><br><span class="line">foo(*a) <span class="comment"># 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

这里的单个 `*` 只能接收非关键字参数，也就是仅有参数值的哪些参数。如果想接受关键字参数，需要用 `**` 来表示：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">	print(args)</span><br><span class="line">	print(kwargs)</span><br><span class="line">	</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, a=<span class="number">61</span>, b=<span class="number">62</span>)</span><br><span class="line"><span class="comment"># 第一行输出：(1, 2, 3)</span></span><br><span class="line"><span class="comment"># 第二行输出：&#123;&amp;#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62&#125;</span></span><br></pre></td></tr></table></figure>

类似的，字典变量传入函数只能作为单个参数，如果要想展开并被 `**kwargs` 识别，需要在字典前面加上两个星号 `**`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62&#125;</span></span><br><span class="line">foo(*a, **d)</span><br></pre></td></tr></table></figure>

#### 2.2.4 参数分类

Python 中函数的参数可以分为两大类：

1. 定位参数（Positional）：表示参数的位置是固定的。比如对于函数 `foo(a, b)` 来说，`foo(1, 2)` 和 `foo(2, 1)` 就是截然不同的，a 和 b 的位置是固定的，不可随意调换。
2. 关键词参数（Keyword）：表示参数的位置不重要，但是参数名称很重要。比如 `foo(a = 1, b = 2)` 和 `foo(b = 2, a = 1)` 的含义相同。

有一种参数叫做仅限关键字（Keyword-Only）参数，比如考虑这个函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args, n=<span class="number">1</span>, **kwargs)</span>:</span></span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>

这个函数在调用时，如果参数 n 不指定名字，就会被前面的 `*args` 处理掉，如果指定的名字不是 n，又会被后面的 `**kwargs` 处理掉，所以参数 n 必须精确的以 `(n = xxx)` 的形式出现，也就是 Keyworld-Only。

### 2.3 函数内省

在 2.2.2 节中，我们查看了函数变量的 `__defaults__` 属性，其实这就是一种内省，也就是在运行时动态的查看变量的信息。

前文说过，函数也是对象，因此函数的变量个数，变量类型都应该有办法获取到，如果你需要开发一个框架，也许会对函数有各种奇葩的检查和校验。 

以下面这个函数为例：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(m, *args, n, **kwargs)</span>:</span></span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br></pre></td></tr></table></figure>

首先可以获取函数名，函数所在模块的全局变量等：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__globals__   <span class="comment"># 全局变量，包含了 g = 1</span></span><br><span class="line">foo.__name__      <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

我们还可以看到函数的参数，函数内部的局部变量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__code__.co_varnames  <span class="comment"># (&amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;args&amp;#39;, &amp;#39;kwargs&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;)</span></span><br><span class="line">foo.__code__.co_argcount  <span class="comment"># 只计算参数个数，不考虑可变参数和仅限关键字参数，所以得到 1</span></span><br></pre></td></tr></table></figure>

或者用 `inspect` 模块来查看更详细的信息：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">sig = inspect.signature(foo)  <span class="comment"># 获取函数签名</span></span><br><span class="line"></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;m&amp;#39;].kind      # POSITIONAL_OR_KEYWORD 表示可以是定位参数或关键字参数</span></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;args&amp;#39;].kind   # VAR_POSITIONAL 定位参数构成的数组</span></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;n&amp;#39;].kind      # KEYWORD_ONLY 仅限关键字参数</span></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;kwargs&amp;#39;].kind # VAR_KEYWORD 关键字参数构成的字典</span></span><br><span class="line">inspect.getfullargspec(foo)       </span><br><span class="line"><span class="comment"># 得到：ArgSpec(args=[&amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;], varargs=&amp;#39;args&amp;#39;, keywords=&amp;#39;kwargs&amp;#39;, defaults=None)</span></span><br></pre></td></tr></table></figure>

本节的新 API 比较多，但并不要求记住这些 API 的用法。再次强调，本文的写作目的是为了建立读者对 Python 的总体认知，了解 Python **能做什么**，至于怎么做，那是文档该做的事。

### 2.4 装饰器

#### 2.4.1 设计模式的消亡

经典的设计模式有 23 个，虽然设计模式都是常用代码的总结，理论上来说与语法无关。但不得不承认的是，标准的设计模式在不同的语言中，有的因为语法的限制根本无法轻易实现（比如在 C 语言中实现组合模式），有的则因为语言的特定功能，变得冗余啰嗦。

以策略模式为例，有一个抽象的策略类，定义了策略的接口，然后使用者选择一个具体的策略类，构造他们的实例并且调用策略方法。具体代码可以参考：[策略模式在百度百科的定义](https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/646307?fr=aladdin)。

然而这些对象本身并没有作用，它们仅仅是可以调用相同的方法而已，只不过在 Java 中，所有的任务都需要由对象来完成。即使策略本身就是一个函数，但也必须把它包裹在一个策略对象中。所以在 Python 中更优雅写法是直接把策略函数作为变量使用。不过这就引入一个问题，如何判断某个函数是个策略呢，毕竟在面向对象的写法中，只要检查它的父类是否是抽象的策略类即可。

也许你已经见过类似的写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@strategy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strategyA</span><span class="params">(n)</span>:</span></span><br><span class="line">	print(n * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

下面就开始介绍装饰器。

#### 2.4.2 装饰器的基本原理

首先，装饰器是个函数，它的参数是被装饰的函数，返回值也是一个函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(origin_func)</span>:</span>  <span class="comment"># 这个参数是被装饰的函数</span></span><br><span class="line">	print(<span class="number">1</span>)  <span class="comment"># 先输出点东西</span></span><br><span class="line">	<span class="keyword">return</span> origin_func  <span class="comment"># 把原函数直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate    # 注意这里不是函数调用，所以不用加括号，也不用加被修饰的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">sayHello()  <span class="comment"># 如果没有装饰器，只会打印 &amp;#39;Hello&amp;#39;，实际结果是打印 1 再打印 &amp;#39;Hello&amp;#39;</span></span><br></pre></td></tr></table></figure>

因此，使用装饰器的这种写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

和下面这种写法是完全等价的， 初学者可以把装饰器在心中默默的转换成下一种写法，以方便理解：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">foo = decorate(foo)</span><br></pre></td></tr></table></figure>

需要注意的是，装饰器函数 `decorate` 在模块被导入时就会执行，而被装饰的函数只在被调用时才会执行，也就是说即使不调用 `sayHello` 函数也会输出 1，但这样就不会输出 Hello 了。

有了装饰器，配合前面介绍的函数对象，函数内省，我们可以做很多有意思的事，至少判断上一节中某个函数是否是策略是非常容易的。在装饰器中，我们还可以把策略函数都保存到数组中， 然后提供一个“推荐最佳策略”的功能， 其实就是遍历执行所有的策略，然后选择最好的结果。

#### 2.4.3 装饰器进阶

上一节中的装饰器主要是为了介绍工作原理，它的功能非常简单，并不会改变被装饰函数的运行结果，仅仅是在导入时装饰函数，然后输出一些内容。换句话说，即使不执行函数，也要执行装饰器中的 `print` 语句，而且因为直接返回函数的缘故，其实没有真正的起到装饰的效果。

如何做到装饰时不输出任何内容，仅在函数执行最初输出一些东西呢？这是常见的 AOP（面向切片编程） 的需求。这就要求我们不能再直接返回被装饰的函数，而是应该返回一个新的函数，所以新的装饰器需要这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(origin_func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="number">1</span>)</span><br><span class="line">		origin_func()</span><br><span class="line">	<span class="keyword">return</span> new_func</span><br><span class="line"></span><br><span class="line">decorate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">sayHello() <span class="comment"># 运行结果不变，但是仅在调用函数 sayHello 时才会输出 1</span></span><br></pre></td></tr></table></figure>

这个例子的工作原理是，`sayHello` 函数作为参数 `origin_func` 被传到装饰器中，经过装饰以后，它实际上变成了 `new_func`，会先输出 1 再执行原来的函数，也就是 `sayHello`。

这个例子很简陋，因为我们知道了 `sayHello` 函数没有参数，所以才能定义一个同样没有参数的替代者：`nwe_func`。如果我们在开发一个框架，要求装饰器能对任意函数生效，就需要用到 2.2.3 中介绍的 `*` 和 `**` 这种不定参数语法了。

如果查看 `sayHello` 函数的名字，得到的结果将是 `new_func`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello.__name__  <span class="comment"># new_func</span></span><br></pre></td></tr></table></figure>

这是很自然的，因为本质上其实执行的是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_func = decorate(sayHello)</span><br></pre></td></tr></table></figure>

而装饰器的返回结果是另一个函数 `new_func`，两者仅仅是运行结果类似，但两个对象并没有什么关联。

所以为了处理不定参数，并且不改变被装饰函数的外观（比如函数名），我们需要做一些细微的修补工作。这些工作都是模板代码，所以 Python 早就提供了封装：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(origin_func)</span>:</span></span><br><span class="line"><span class="meta">	@functools.wraps(origin_func)  # 这是 Python 内置的装饰器</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="number">1</span>)</span><br><span class="line">		origin_func(*args, **kwargs)</span><br><span class="line">	<span class="keyword">return</span> new_func</span><br></pre></td></tr></table></figure>

#### 2.4.4 装饰器工厂

在 2.4.2 节的代码注释中我解释过，装饰器后面不要加括号，被装饰的函数自动作为参数，传递到装饰器函数中。如果加了括号和参数，就变成手动调用装饰器函数了，大多数时候这与预期不符（因为装饰器的参数一般都是被装饰的函数）。

不过装饰器可以接受自定义的参数，然后返回另一个装饰器，这样外面的装饰器实际上就是一个装饰器工厂，可以根据用户的参数，生成不同的装饰器。还是以上面的装饰器为例，我希望输出的内容不是固定的 1，而是用户可以指定的，代码就应该这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(content)</span>:</span>  				      <span class="comment"># 这其实是一个装饰器工厂</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">real_decorator</span><span class="params">(origin_func)</span>:</span>          <span class="comment"># 这才是刚刚的装饰器</span></span><br><span class="line"><span class="meta">		@functools.wraps(origin_func)</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">()</span>:</span></span><br><span class="line">			print(&amp;<span class="comment">#39;You said &amp;#39; + str(content)) # 现在输出内容可以由用户指定</span></span><br><span class="line">			origin_func()</span><br><span class="line">		<span class="keyword">return</span> new_func                       <span class="comment"># 在装饰器里，返回的是新的函数</span></span><br><span class="line">	<span class="keyword">return</span> real_decorator                     <span class="comment"># 装饰器工厂返回的是装饰器</span></span><br></pre></td></tr></table></figure>

装饰器工厂和装饰器的区别在于它可以接受参数，返回一个装饰器：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate(2017)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">sayHello()</span><br></pre></td></tr></table></figure>

其实等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real_decorator = decorate(<span class="number">2017</span>)      <span class="comment"># 通过装饰器工厂生成装饰器</span></span><br><span class="line">new_func = real_decorator(sayHello)  <span class="comment"># 正常的装饰器工作逻辑</span></span><br><span class="line">new_func()                           <span class="comment"># 调用的是装饰过的函数</span></span><br></pre></td></tr></table></figure>

## 3 面向对象

### 3.1 对象内存管理

#### 3.1.1 对象不是盒子

C 语言中我们定义变量用到的语法是：

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

这背后的含义是定义了一个 `int` 类型的变量 `a`，相当于申请了一个名为 `a` 的盒子（存储空间），里面装了数字 1。
![](https://diycode.b0.upaiyun.com/photo/2018/d488dd71e0be57efe82f076c550e6a22.png)


然后我们改变 `a` 的值：`a = 2;`，可以打印 `a` 的地址来证明它并没有发生变化。所以只是盒子里装的内容（指针指向的位置）发生了改变：
![](https://diycode.b0.upaiyun.com/photo/2018/63785ebe7adfb514dcc88d4b96a34cad.png)

但是在 Python 中，变量不是盒子。比如同样的定义变量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

这里就不能把 `a` 理解为 `int` 类型的变量了。因为在 Python 中，变量没有类型，值才有，或者说只有对象才有类型。因为即使是数字 1，也是 `int` 类的实例，而变量 `a` 更像是给这个对象贴的一个标签。


![](https://diycode.b0.upaiyun.com/photo/2018/6d30c0da2d2108ccc071c8751c4e7c1a.png)
如果执行赋值语句 `a = 2`，相当于把标签 a 贴在另一个对象上：
![](https://diycode.b0.upaiyun.com/photo/2018/05a4f3b25b942f0656f1759eb5b6dbc6.png)


基于这个认知，我们现在应该更容易理解 2.2.1 节中所说的函数传参规则了。如果传入的是不可变类型，比如 `int`，改变它的值实际上就是把标签挂在新的对象上，自然不会改变原来的参数。如果是可变类型，并且做了修改，那么函数中的变量和外面的变量都是指向同一个对象的标签，所以会共享变化。

#### 3.1.2 默认浅复制

根据上一节的描述，直接把变量赋值给另一个变量， 还算不上复制：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b == a   <span class="comment"># True，等同性校验，会调用 __eq__ 函数，这里只判断内容是否相等</span></span><br><span class="line">b <span class="keyword">is</span> a   <span class="comment"># True，一致性校验，会检查是否是同一个对象，调用 hash() 函数，可以理解为比较指针</span></span><br></pre></td></tr></table></figure>

可见不仅仅数组相同，就连变量也是相同的，可以把 b 理解为 a 的别名。

如果用切片，或者数组的构造函数来创建新的数组，得到的是原数组的浅拷贝：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = list(a)</span><br><span class="line">b == a   <span class="comment"># True，因为数组内容相同</span></span><br><span class="line">b <span class="keyword">is</span> a   <span class="comment"># False，现在 a 和 b 是两个变量，恰好指向同一个数组对象</span></span><br></pre></td></tr></table></figure>

但如果数组中的元素是可变的，可以看到这些元素并没有被完全拷贝：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line">b = list(a)</span><br><span class="line">b[<span class="number">0</span>].append(<span class="number">2</span>)</span><br><span class="line">a <span class="comment"># 得到 [[1, 2], [2], [3]]，因为 a[0] 和 b[0] 其实还是挂在相同对象上的不同标签</span></span><br></pre></td></tr></table></figure>

如果想要深拷贝，需要使用 `copy` 模块的 `deepcopy` 函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy </span><br><span class="line"></span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">b[<span class="number">0</span>].append(<span class="number">2</span>)</span><br><span class="line">b  <span class="comment"># 变成了 [[1, 2], [2], [3]]</span></span><br><span class="line">a  <span class="comment"># 还是 [[1], [2], [3]]</span></span><br></pre></td></tr></table></figure>

此时，不仅仅是每个元素的引用被拷贝，就连每个元素自己也被拷贝。所以现在的 `a[0]` 和 `b[0]` 是指向两个不同对象的两个不同变量（标签），自然就互不干扰了。

如果要实现自定义对象的深复制，只要实现 `__deepcopy__` 函数即可。这个概念在几乎所有面向对象的语言中都会存在，就不详细介绍了。

#### 3.1.3 弱引用

Python 内存管理使用垃圾回收的方式，当没有指向对象的引用时，对象就会被回收。然而对象一直被持有也并非什么好事，比如我们要实现一个缓存，预期目标是缓存中的内容随着真正对象的存在而存在，随着真正对象的消失而消失。如果因为缓存的存在，导致被缓存的对象无法释放，就会导致内存泄漏。

Python 提供了语言级别的支持，我们可以使用 `weakref` 模块，它提供了 `weakref.WeakValueDictionary` 这个弱引用字典来确保字典中的值不会被引用。如果想要获取某个对象的弱引用，可以使用 `weakref.ref(obj)`  函数。

### 3.2 Python 风格的对象

#### 3.2.1 静态函数与类方法

静态函数其实和类的方法没什么关系，它只是恰好定义在类的内部而已，所以这里我用函数（function) 来形容它。它可以没有参数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod   # 用 staticmethod 这个修饰器来表明函数是静态的</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">Person.sayHello() <span class="comment"># 输出 &amp;#39;Hello`</span></span><br></pre></td></tr></table></figure>

静态函数的调用方式是类名加上函数名。类方法的调用方式也是这样，唯一的不同是需要用 `@staticmethod` 修饰器，而且方法的第一个参数必须是类：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">	@classmethod    # 用 classmethod 这个修饰器来表明这是一个类方法</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(cls)</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;Hi: &amp;#39; + cls.__name__)</span></span><br><span class="line">	</span><br><span class="line">Person.sayHi() <span class="comment"># 输出 &amp;#39;Hi: Person`</span></span><br></pre></td></tr></table></figure>

类方法和静态函数的调用方法一致，在定义时除了修饰器不一样，唯一的区别就是类方法需要多声明一个参数。这样看起来比较麻烦，但静态函数无法引用到类对象，自然就无法访问类的任何属性。

于是问题来了，静态函数有何意义呢？有的人说类名可以提供命名空间的概念，但在我看来这种解释并不成立，因为每个 Python 文件都可以作为模块被别的模块引用，把静态函数从类里抽取出来，定义成全局函数，也是有命名空间的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 module1.py 文件中：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">global</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 module2.py 文件中：</span></span><br><span class="line"><span class="keyword">import</span> module1</span><br><span class="line">module1.<span class="keyword">global</span>()        <span class="comment"># 调用全局函数</span></span><br><span class="line">module1.Util.helper()   <span class="comment"># 调用静态函数</span></span><br></pre></td></tr></table></figure>

从这个角度看，定义在类中的静态函数不仅不具备命名空间的优点，甚至调用语法还更加啰嗦。对此，我的理解是：**静态函数可以被继承、重写，但全局函数不行**，由于 Python 中的函数是一等公民，因此很多时候用函数替代类都会使代码更加简洁，但缺点就是无法继承，后面还会有更多这样的例子。

#### 3.2.2 属性 attribute

Python （等多数动态语言）中的类并不像 C/OC/Java 这些静态语言一样，需要预先定义属性。我们可以直接在初始化函数中创建属性：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.name  <span class="comment"># 值是 &amp;#39;bestswifter&amp;#39;</span></span><br></pre></td></tr></table></figure>

由于 `__init__` 函数是运行时调用的，所以我们可以直接给对象添加属性：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bs.age = <span class="number">22</span></span><br><span class="line">bs.age  <span class="comment"># 因为刚刚赋值了，所以现在取到的值是 22</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">如果访问一个不存在的属性，将会抛出异常。从以上特性来看，对象其实和字典非常相似，但这种过于灵活的特性其实蕴含了潜在的风险。比如某个封装好的父类中定义了许多属性， 但是子类的使用者并不一定清楚这一点，他们很可能会不小心就重写了父类的属性。一种隐藏并保护属性的方式是在属性前面加上两个下划线：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.__name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">	</span><br><span class="line">bs = Person()</span><br><span class="line"></span><br><span class="line">bs.__name          <span class="comment"># 这样是无法获取属性的</span></span><br><span class="line">bs._Person__name   <span class="comment"># 这样还是可以读取属性</span></span><br></pre></td></tr></table></figure>

这是因为 Python 会自动处理以双下划线开头的属性，把他们重名为 `_Classname__attrname` 的格式。由于 Python 对象的所有属性都保存在实例的 `__dict__`  属性中，我们可以验证一下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bs = Person()</span><br><span class="line">bs.__dict__ </span><br><span class="line"><span class="comment"># 得到 &#123;&amp;#39;_Person__name&amp;#39;: &amp;#39;bestswifter&amp;#39;&#125;</span></span><br></pre></td></tr></table></figure>

但很多人并不认可通过名称改写（name mangling) 的方式来存储私有属性，原因很简单，只要知道改写规则，依然**很容易的**就能读写私有属性。与其自欺欺人，不如采用更简单，更通用的方法，比如给私有属性前面加上单个下划线 `_`。

注意，以单个下划线开头的属性不会触发任何操作，完全靠自觉与共识。**任何稍有追求的 Python 程序员，都不应该读写这些属性。**

#### 3.2.3 特性 property

使用过别的面向对象语言的读者应该都清楚属性的 `getter` 和 `setter` 函数的重要性。它们封装了属性的读写操作，可以添加一些额外的逻辑，比如校验新值，返回属性前做一些修饰等等。最简陋的 `getter` 和 `setter` 就是两个普通函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.name.upper()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> isinstance(new_name, str):</span><br><span class="line">			self.name = new_name.lower()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.get_name()   <span class="comment"># 得到大写的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br><span class="line">bs.set_name(<span class="number">1</span>)  <span class="comment"># 由于新的名字不是字符串，所以无法赋值</span></span><br><span class="line">bs.get_name()   <span class="comment"># 还是老的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br></pre></td></tr></table></figure>

工作虽然完成了，但方法并不高明。在 1.2.3 节中我们就见识到了 Python 的一个特点：“内部高度封装，完全对外透明”。这里手动调用 `getter` 和 `setter` 方法显得有些愚蠢、啰嗦，比如对比下面的两种写法，在变量名和函数名很长的情况下，差距会更大：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bs.name += &amp;<span class="comment">#39;1995&amp;#39;</span></span><br><span class="line">bs.set_name(bs.get_name() + &amp;<span class="comment">#39;1995&amp;#39;)</span></span><br></pre></td></tr></table></figure>

Python 提供了 `@property` 关键字来装饰 `getter` 和 `setter` 方法，这样的好处是可以直接使用点语法，了解 Objective-C 的读者对这一特性一定倍感亲切：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">	@property                        # 定义 getter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span>                  <span class="comment"># 函数名就是点语法访问的属性名</span></span><br><span class="line">		<span class="keyword">return</span> self._name.upper()    <span class="comment"># 现在真正的属性是 _name 了</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">	@name.setter	                 # 定义 setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, new_name)</span>:</span>        <span class="comment"># 函数名不变</span></span><br><span class="line">		<span class="keyword">if</span> isinstance(new_name, str):</span><br><span class="line">			self._name = new_name.lower()  <span class="comment"># 把值存到私有属性 _name 里</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.name      <span class="comment"># 其实调用了 name 函数，得到大写的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br><span class="line">bs.name = <span class="number">1</span>  <span class="comment"># 其实调用了 name 函数，因为类型不符，无法赋值</span></span><br><span class="line">bs.name      <span class="comment"># 还是老的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br></pre></td></tr></table></figure>

我们已经在 2.4 节详细学习了装饰器，应该能意识到这里的 `@property` 和 `@xxx.setter` 都是装饰器。因此上述写法实际上等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._name.upper()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> isinstance(new_name, str):</span><br><span class="line">			self._name = new_name.lower()</span><br><span class="line">	<span class="comment"># 以上是老旧的 getter 和 setter 定义</span></span><br><span class="line">	<span class="comment"># 如果不用 @property，可以定义一个 property 类的实例</span></span><br><span class="line">	name = property(get_name, set_name)</span><br></pre></td></tr></table></figure>

可见，特性的本质是给类创建了一个类属性，它是 `property` 类的实例，构造方法中需要把 `getter`、`setter` 等函数传入，我们可以打印一下类的 `name` 属性来证明：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.name  <span class="comment"># &amp;lt;property object at 0x107c99868&amp;gt;</span></span><br></pre></td></tr></table></figure>

理解特性的工作原理至关重要。以这里的 `name` 特性为例，我们访问了对象的 `name` 属性，但是它并不存在，所以会尝试访问类的 `name` 属性，这个属性是 `property` 类的实例，会对读写操作做特殊处理。这也意味着，如果我们重写了类的 `name` 属性，那么对象的读写方法就不会生效了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bs = Person()</span><br><span class="line">Person.name = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">bs.name  <span class="comment"># 实例并没有 name 属性，因此会访问到类的属性 name，现在的值是 &amp;#39;hello` 了</span></span><br></pre></td></tr></table></figure>

如果访问不存在的属性，默认会抛出异常，但如果实现了 `__getattr__` 函数，还有一次挽救的机会：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.name    <span class="comment"># 直接访问属性</span></span><br><span class="line">bs.age     <span class="comment"># 得到 0，这是 __getattr__ 方法提供的默认值</span></span><br><span class="line">bs.age = <span class="number">1</span> <span class="comment"># 动态给属性赋值</span></span><br><span class="line">bs.age     <span class="comment"># 得到 1，注意！！！这时候就不会再调用 __getattr__ 方法了</span></span><br></pre></td></tr></table></figure>

由于 `__getattr__` 只是兜底策略，处理一些异常情况，并非每次都能被调用，所以不能把重要的业务逻辑写在这个方法中。

#### 3.2.4 特性工厂

在上一节中，我们利用特性来封装 `getter` 和 `setter`，对外暴露统一的读写接口。但有些 `getter` 和 `setter` 的逻辑其实是可以复用的，比如商品的价格和剩余数量在赋值时，都必须是大于 0 的数字。这时候如果每次都要写一遍 `setter`，代码就显得很冗余，所以我们需要一个能批量生产特性的函数。由于我们已经知道了特性是 `property` 类的实例，而且是类的属性，所以代码可以这样写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">(storage_name)</span>:</span>  <span class="comment"># 定义 getter 和 setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">		    <span class="comment"># 把值保存在实例的 __dict__ 字典中</span></span><br><span class="line">			instance.__dict__[storage_name] = value </span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br><span class="line">	<span class="keyword">return</span> property(qty_getter, qty_setter) <span class="comment"># 返回 property 的实例</span></span><br></pre></td></tr></table></figure>

有了这个特性工厂，我们可以这样来定义特性：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    price = quantity(&amp;<span class="comment">#39;price&amp;#39;)</span></span><br><span class="line">    number = quantity(&amp;<span class="comment">#39;number&amp;#39;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        		</span><br><span class="line">i = Item()</span><br><span class="line">i.price = <span class="number">-1</span> </span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ValueError: value must be &amp;gt; 0</span></span><br></pre></td></tr></table></figure>

作为追求简洁的程序员，我们不禁会问，在 `price = quantity(&#39;price&#39;)` 这行代码中，属性名重复了两次，能不能在 `quantity` 函数中自动读取左边的属性名呢，这样代码就可以简化成 `price = quantity()` 了。

答案显然是否定的，因为右边的函数先被调用，然后才能把结果赋值给左边的变量。不过我们可以采用迂回策略，变相的实现上面的需求：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		quantity.count += <span class="number">1</span></span><br><span class="line">	<span class="keyword">except</span> AttributeError:</span><br><span class="line">		quantity.count = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	storage_name = &amp;<span class="comment">#39;_&#123;&#125;:&#123;&#125;&amp;#39;.format(&amp;#39;quantity&amp;#39;, quantity.count)	</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">			instance.__dict__[storage_name] = value</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br><span class="line">	<span class="keyword">return</span> property(qty_getter, qty_setter)</span><br></pre></td></tr></table></figure>

这段代码中我们利用了两个技巧。首先函数是一等公民， 所以函数也是对象，自然就有属性。所以我们利用 `try ... except` 很容易的就给函数工厂添加了一个计数器对象 `count`，它每次调用都会增加，然后再拼接成存储时用的键 `storage_name` ，并且可以保证不同 `property` 实例的存储键名各不相同。

其次，`storage_name` 在 `getter` 和 `setter` 函数中都被引用到，而这两个函数又被 `property` 的实例引用，所以 `storage_name` 会因为被持有而延长生命周期。这也正是闭包的一大特性：能够捕获自由变量并延长它的生命周期和作用域。

我们来验证一下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    price = quantity()</span><br><span class="line">    number = quantity()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">i = Item()</span><br><span class="line">i.price = <span class="number">1</span></span><br><span class="line">i.number = <span class="number">2</span></span><br><span class="line">i.price     <span class="comment"># 得到 1，可以正常访问</span></span><br><span class="line">i.number    <span class="comment"># 得到 2，可以正常访问</span></span><br><span class="line">i.__dict__  <span class="comment"># &#123;&amp;#39;_quantity:0&amp;#39;: 1, &amp;#39;_quantity:1&amp;#39;: 2&#125;</span></span><br></pre></td></tr></table></figure>

可见现在存储的键名可以被正确地自动生成。

#### 3.2.5 属性描述符

文件描述符的作用和特性工厂一样，都是为了批量的应用特性。它的写法也和特性工厂非常类似：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">		self.storage = storage_name</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[self.storage]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">			instance.__dict__[self.storage] = value</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br></pre></td></tr></table></figure>

主要有以下几个改动：

1. 不用返回 `property` 类的实例了，因此 `getter` 和 `setter` 方法的名字是固定的，这样才能满足协议。
2. `__get__` 方法的第一个参数是描述符类 `Quantity` 的实例，第二个参数 `self` 是要读取属性的实例，比如上面的 `i`，也被称作托管实例。第三个参数是托管类，也就是 `Item`。
3. `__set__` 方法的前两个参数含义类似，第三个则是要读取的属性名，比如 `price`。

和特性工厂类似，属性描述符也可以实现 `storage_name` 的自动生成，这里就不重复代码了。看起来属性描述符和特性工厂几乎一样，但由于属性描述符是类，它就可以继承。比如这里的 `Quantity` 描述符有两个功能：自动存储和值的校验。自动存储是一个非常通用的逻辑，而值的校验是可变的业务逻辑，所以我们可以先定义一个 `AutoStorage` 描述符来实现自动存储功能，然后留下一个空的 `validate` 函数交给子类去重写。

而特性工厂作为函数，自然就没有上述功能，这两者的区别类似于 3.2.1 节中介绍的静态函数与全局函数的区别。

#### 3.2.6 实例属性的查找顺序

我们知道类的属性都会存储在 `__dict__` 字典中，即使没有显式的给属性赋值，但只要字典里面有这个字段，也是可以读取到的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p.__dict__[&amp;<span class="comment">#39;name&amp;#39;] = &amp;#39;bestswifter&amp;#39;</span></span><br><span class="line">p.name  <span class="comment"># 不会报错，而是返回字典中的值，&amp;#39;bestswifter&amp;#39;</span></span><br></pre></td></tr></table></figure>

但我们在特性工厂和属性描述符的实现中，都是直接把属性的值存储在 `__dict__` 中，而且键就是属性名。之前我们还介绍过，特性的工作原理是没有直接访问实例的属性，而是读取了 `property` 的实例。那直接把值存在 `__dict__` 中，会不会导致特性失效，直接访问到原始内容呢？从之前的实践结果来看，答案是否定的，要解释这个问题，我们需要搞明白访问实例属性的查找顺序。

假设有这么一段代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o = cls()   <span class="comment"># 假设 o 是 cls 类的实例</span></span><br><span class="line">o.attr      <span class="comment"># 试图访问 o 的属性 attr</span></span><br></pre></td></tr></table></figure>

再对上一节中的属性描述符做一个简单的分类：

1. 覆盖型描述符：定义了 `__set__` 方法的描述符
2. 非覆盖型描述符：没有定义 `__set__` 方法的描述符

在执行 `o.attr` 时，查找顺序如下：

1. 如果 `attr` 出现在 `cls` 或父类的 `__dict__` 中，且 `attr` 是覆盖型描述符，那么调用 `__get__` 方法。
2. 否则，如果 `attr` 出现在 `o` 的`__dict__` 中，返回 `o.__dict__[attr]`
3. 否则，如果`attr` 出现在 `cls` 或父类的 `__dict__` 中，如果 `attr` 是非覆盖型描述符，那么调用 `__get__` 方法。
4. 否则，如果没有非覆盖型描述符，直接返回 `cls.__dict__[attr]`
5. 否则，如果 `cls` 实现了 `__getattr__` 方法，调用这个方法
6. 抛出 `AttributeError`

所以，在访问类的属性时，覆盖型描述符的优先级是高于直接存储在 `__dict__` 中的值的。

### 3.3 多继承

本节内容部分摘自我的这篇文章：[从 Swift 的面向协议编程说开去](http://www.jianshu.com/p/fc105512bf40)，本节聊的是多继承在 Python 中的知识，如果想阅读关于多继承的讨论，请参考原文。

#### 3.3.1 多继承的必要性

很多语言类的书籍都会介绍，多继承是个危险的行为。诚然，狭义上的多继承在绝大多数情况下都是不合理的。这里所谓的 **“狭义”**，指的是一个类拥有多个父类。我们要明确一个概念：继承的目的不是代码复用，而是声明一种 `is a` 的关系，代码复用只是 `is a` 关系的一种外在表现。

因此，如果你需要狭义上的多继承，还是应该先问问自己，真的存在这么多 `is a` 的关系么？你是需要声明这种关系，还是为了代码复用。如果是后者，有很多更优雅的解决方案，因为多继承的一个直接问题就是菱形问题（Diamond Problem）。

但是广义上的多继承是必须的，不能因为害怕多继承的问题就忽略多继承的优点。**广义多继承** 指的是通过定义接口（Interface）以及接口方法的默认实现，形成“一个父类，多个接口”的模式，最终实现代码的复用。当然，不是每个语言都有接口的概念，比如 Python 里面叫 Mixin，会在 3.3.3 节中介绍。

广义上的多继承非常常见，有一些教科书式的例子，比如动物可以按照哺乳动物，爬行动物等分类，也可以按照有没有翅膀来分类。某一个具体的动物可能满足上述好几类。在实际的开发中也到处都是广义多继承的使用场景，比如 iOS 或者安卓开发中，系统控件的父类都是固定的，如果想让他们复用别的父类的代码，就会比较麻烦。

#### 3.3.2 Python 的多继承

Python 语法直接支持多继承：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;A&amp;#39;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span>     <span class="comment"># 继承自 A，重写 foo 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;B&amp;#39;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span>     <span class="comment"># 继承自 A，重写 foo 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;C&amp;#39;)</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span>  <span class="comment"># 多继承的语法，父类之间用逗号间隔</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo()         <span class="comment"># 输出：&amp;#39;B&amp;#39;</span></span><br></pre></td></tr></table></figure>

这就是著名的菱形问题，D 继承自 B 和 C，而 B 和 C 都继承自 A，他们的继承关系构成一个菱形。调用 D 类实例的 `foo` 方法会让人产生疑惑，它的父类们都实现了 `foo` 方法，到底以谁为准？

Python 有一套算法来计算遍历顺序，这个顺序叫做**方法解析顺序（Method Resolution Oder，MRO）**。这个算法叫做 C3 算法，可以参考这篇官方文档：[The Python 2.3 Method Resolution Order](https://www.python.org/download/releases/2.3/mro/)

不过在绝大多数情况下，除非你的代码极度依赖多继承，否则都不需要了解这个算法的具体工作原理。一方面，我们可以调用某个特定父类的方法。我们也许已经注意到两个事实，首先类中定义的方法其实都是类的属性，但调用者都是类的实例。其次，类方法的第一个参数都是 `self`，表示方法的调用者，但我们调用时并不需要传入实例。这是因为其实实例方法的正规调用方式是这样的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C.foo(C())</span><br><span class="line"><span class="comment"># 或者是</span></span><br><span class="line">C.foo(d)</span><br></pre></td></tr></table></figure>

这种调用方式符合定义，而且能够解释上述的两个疑问。然而这种调用方式不仅写起来麻烦，还很不合理，因为我们不仅要实例对象，还需这个实例所属的类才能调用。因此，Python 的做法是将类中定义的方法绑定到每一个实例上：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D.foo  <span class="comment"># &amp;lt;function B.foo at 0x10696c158&amp;gt; 这个是真正的方法对象</span></span><br><span class="line">d      <span class="comment"># &amp;lt;__main__.D object at 0x1075fa400&amp;gt;  这个是 D 的一个实例</span></span><br><span class="line">d.foo  <span class="comment"># &amp;lt;bound method B.foo of &amp;lt;__main__.D object at 0x106967400&amp;gt;&amp;gt; 注意看地址和 d 是一致的</span></span><br><span class="line">d.foo.__self__ <span class="comment"># &amp;lt;__main__.D object at 0x1075fa400&amp;gt;，通过 __self__ 引用绑定的实例</span></span><br></pre></td></tr></table></figure>

可以清楚的从 `d.foo` 的输出结果看出来，它是绑定到 `d` 对象上的函数，第一个参数 `self` 就是 `d`。

另一方面，我们不仅可以调用任意父类的方法，还可以通过类的 `__mro__` 属性查看父类的继承顺序：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D.__mro__</span><br><span class="line"><span class="comment"># (&amp;lt;class &amp;#39;__main__.D&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.B&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.C&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.A&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;)</span></span><br></pre></td></tr></table></figure>

所以，多继承的方法调用顺序一般情况下不会对开发代码造成太大的困扰。

#### 3.3.3 Mixin

Mixin 不是 **迷信** 的拼音，它表示**混入**，可以方便的实现代码复用。在 Python 中，Mixin 是以多继承的形式实现的，比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_json</span><span class="params">(self)</span>:</span></span><br><span class="line">		 <span class="keyword">return</span> str(self.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugMixin</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">	     <span class="keyword">return</span> &amp;<span class="comment">#39;&amp;#39;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span><span class="params">(BaseController, JSONable, DebugMixin)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

Mixin 和多继承最大的区别在于它一般不产生菱形问题，但 Python 并没有语法层面的约束来保证这一点，所以对于 Mixin，我们一般需要遵守以下几个约定：

1. 一般命名以 Mixin、able、ible 结尾，明确表示混入，或者提供某种能力。
2. 一般不要有复杂的继承关系，尤其不要和被混入的类（比如上面的 `Controller` 类）有共同的父类，避免菱形问题。
3. 一般提供简单的功能，如果有多个功能，就写成多个 Mixin。
4. 功能完备、独立，不要依赖被混入的类。
4. 看到上述命名风格的类，不要实例化他们，仅用在多继承中。

在 5.3.2 节中会有实际的 Mixin 的使用场景。

#### 3.3.4 抽象类

有时候我们需要在父类定义一个方法，然后交给子类去实现。这种方法叫做抽象方法， 定义了抽象方法的类叫做抽象类。抽象类不应该被实例化，在 Java 中，`Interface` 就是抽象类，它不能被实例化，只有实现了协议的类才能创建实例。

在 Python 中，抽象类需要把自己的 `metaclass` 设置为 `abc.ABCMeta`，并且用装饰器去标记抽象函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseItem</span><span class="params">(Base, metaclass=abc.ABCMeta)</span>:</span>   <span class="comment"># 需要标记 metaclass</span></span><br><span class="line"><span class="meta">	@abc.abstractmethod                        # 抽象函数</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(self)</span>:</span></span><br><span class="line">		 &amp;quot;&amp;quot;&amp;quot;Method that should do something.&amp;quot;&amp;quot;&amp;quot;</span><br><span class="line"></span><br><span class="line">item = BaseItem()</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># TypeError: Can&amp;#39;t instantiate abstract class BaseItem with abstract methods get_price</span></span><br></pre></td></tr></table></figure>

如果设置了 `metaclass` 并且标记了抽象函数，那么任何没有实现抽象函数的子类（包括抽象类自己）都无法实例化。

### 3.4 元编程

#### 3.4.1 类工厂函数

有些类的功能很单一，仅仅用来存储数据。但如果先声明一个长长的 `__init__` 函数，再挨个写 `self.xxx = xxx` 这种模板代码，就显得很啰嗦。其实也可以自己实现一个 1.1.2 节中的具名元组。具名元zu组是一个函数，它返回一个类：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">People = collections.namedtuple(&amp;<span class="comment">#39;People&amp;#39;, [&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;])</span></span><br><span class="line">p = People(&amp;<span class="comment">#39;bestswifter&amp;#39;, &amp;#39;22&amp;#39;)</span></span><br></pre></td></tr></table></figure>

`namedtuple` 这种函数可以称为**类工厂函数**，因为它可以根据传入的参数，动态的生成类，我们来实现一个简化版的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_tuple</span><span class="params">(cls, names)</span>:</span></span><br><span class="line">	names = names.split(&amp;<span class="comment">#39; &amp;#39;)   # 这里会得到属性的数组</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> (name, value) <span class="keyword">in</span> zip(self.__slots__, args):</span><br><span class="line">		    <span class="comment"># slots 是属性名，args 是初始化的参数，一一对应起来用 setattr 给实例的属性赋值</span></span><br><span class="line">			setattr(self, name, value)	</span><br><span class="line">	</span><br><span class="line">	cls_attrs = dict(__slots__ = names, __init__ = __init__)</span><br><span class="line">	<span class="keyword">return</span> type(cls, (object, ), cls_attrs)</span><br><span class="line">	</span><br><span class="line">People = my_tuple(&amp;<span class="comment">#39;People&amp;#39;, &amp;#39;name age&amp;#39;)</span></span><br><span class="line">p = People(&amp;<span class="comment">#39;bestswifter&amp;#39;, &amp;#39;22&amp;#39;)</span></span><br><span class="line">p.name   <span class="comment"># &amp;#39;bestswifter&amp;#39;</span></span><br><span class="line">p.age    <span class="comment"># 22</span></span><br></pre></td></tr></table></figure>

这个类工厂非常简陋，比如不支持关键字参数，但用来演示类工厂的原理是已经足够了。类工厂的核心原理在于 `type` 函数，它不仅可以传入一个实例，返回实例的类型，也可以像这里的使用一样，传入三个参数，构造一个类。第一个参数表示类名，第二个参数是继承关系，最后一个则是类的属性。

#### 3.4.2 元类的概念

元类和类工厂函数的区别就像属性描述符和特性工厂函数的区别一样，**前者是类，可以继承**，后者不行。就像我们上一节中用 `type` 来生成类一样，Python 中的类都是 `type` 类的实例：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="comment">#39;bestswifter&amp;#39;.__class__  # &amp;lt;class &amp;#39;str&amp;#39;&amp;gt;，字符串都是 str 类的实例</span></span><br><span class="line">str.__class__            <span class="comment"># &amp;lt;class &amp;#39;type&amp;#39;&amp;gt; str 类是 type 类的实例</span></span><br><span class="line">int.__class__            <span class="comment"># &amp;lt;class &amp;#39;type&amp;#39;&amp;gt; int 也是 type 类的实例</span></span><br><span class="line">type.__class__           <span class="comment"># &amp;lt;class &amp;#39;type&amp;#39;&amp;gt; type 类是自己的实例，防止死循环</span></span><br></pre></td></tr></table></figure>

需要说明的是，`__class__` 表示的是元类，而不是父类，父类可以通过 3.3.2 节中介绍的 `__mro__` 属性来查看：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int.__mro__  <span class="comment"># (&amp;lt;class &amp;#39;int&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;)</span></span><br><span class="line">str.__mro__  <span class="comment"># (&amp;lt;class &amp;#39;str&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;)</span></span><br></pre></td></tr></table></figure>

可见 `int` 和 `str` 这些内置类的父类都是 `objcet`，我们可以认为 `object` 是所有类的父类，而 `type` 是所有类的元类，这个规则在这两个类之间也适用，可以验证一下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.__class__   <span class="comment"># &amp;lt;class &amp;#39;type&amp;#39;&amp;gt;</span></span><br><span class="line">type.__mro__       <span class="comment"># (&amp;lt;class &amp;#39;type&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;)</span></span><br></pre></td></tr></table></figure>

可见 `object` 是 `type` 类构建出来的实例，`type` 是 `object` 类的元类，而 `object` 则是 `type` 类的父类。如下图所示：
![](https://diycode.b0.upaiyun.com/photo/2018/7cfd0dcc1843eac2a7e4e84afd794533.png)


这里介绍元类和父类并非是为了烧脑，除了描述最基本的概念以外，我们应该意识到，类是由元类的 `__init__` 方法构造出来的实例，如果我们继承元类并且重写 `__init__` 方法，就可以控制类的初始化方法。

#### 3.4.3 元类的使用示例

在介绍属性描述符时，我们用计数器来实现 `storage_name` 的自动生成，从而避免冗余的代码，但代码的可读性会下降，因为属性的名称无法获得，只能用递增的数字来区别。利用元类，我们可以在不影响可读性的前提下，实现存储名称的自动生成：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">	__counter = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		cls = self.__class__</span><br><span class="line">		self.storage = &amp;<span class="comment">#39;_&#123;&#125;#&#123;&#125;&amp;#39;.format(cls.__name__, cls.__counter)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[self.storage]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">			instance.__dict__[self.storage] = value</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br><span class="line"><span class="comment"># Quantity 类是可以自动生成 storage 名称的描述符类，和之前的逻辑基本类似，可以不用关注</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承自 type 类，是一个自定义的元类	</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuantityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attr_dict)</span>:</span> </span><br><span class="line">	    <span class="comment"># name 表示类名，bases 是继承关系，attr_dict 则是属性列表，和 type 方法的参数含义一致</span></span><br><span class="line">		super().__init__(name, bases, attr_dict)</span><br><span class="line">		<span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():</span><br><span class="line">		    <span class="comment"># 注意，类有很多属性，但只有描述符类型的属性才需要修改</span></span><br><span class="line">			<span class="keyword">if</span> isinstance(attr, Quantity):</span><br><span class="line">				type_name = type(attr).__name__</span><br><span class="line">				<span class="comment"># 这里的 key 就是原来的属性名，比如 price、number</span></span><br><span class="line">				attr.storage = &amp;<span class="comment">#39;_&#123;&#125;#&#123;&#125;&amp;#39;.format(type_name, key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了避免让用户知道太多元类的细节，我们创建一个基类 Entity，并把它的元类设置为 QuantityMeta</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=QuantityMeta)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在用户的类只要继承自 Entity 就可以了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span><span class="params">(Entity)</span>:</span></span><br><span class="line">	price = Quantity()</span><br><span class="line">	number = Quantity()</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">				</span><br><span class="line">i = Item()</span><br><span class="line">i.price = <span class="number">1</span></span><br><span class="line">print(i.__dict__)  <span class="comment"># 得到 &#123;&amp;#39;_Quantity#price&amp;#39;: 1&#125;，可读性良好</span></span><br><span class="line"><span class="comment">#i.price = -1      # 抛出异常</span></span><br></pre></td></tr></table></figure>

虽然代码比较长，但其实核心很简单，在元类的 `__init__` 方法中，我们可以获取将要生成的类的名称、父类和属性，就像在类工厂函数中传给 `type` 类的那些参数一样。有了这些信息，我们可以把当初用计数器生成的临时存储名称给改正为可读性更高的名称。

## 4. 流程控制

### 4.1 else

除了最常见的 `if ... else ...` 语句外，还有很多地方都会用到 `else`，它的用法各不相同，但如果灵活使用，会使代码更简洁， 更具可读性。

#### 4.1.1 for else

for 语句的末尾可以加上 else，仅当 for 循环没有因为 break 而终止，顺利运行完以后才运行。这个用法看起来怪怪的，毕竟其他 for 循环后面的代码，也会正常执行。所以这个规则应该反过来理解：**如果 for 循环因为 break 而终止，else 代码块就不会执行**。

有过一些编程经验的读者应该经常会写出这样的代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">found = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">    <span class="keyword">if</span> some_judge(i):  <span class="comment"># 只要找到一个满足条件的，就把 found 置为 True</span></span><br><span class="line">        found = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> found:          <span class="comment"># 如果全都不符合条件，执行某个逻辑</span></span><br><span class="line">    print(&amp;<span class="comment">#39;Nothing found&amp;#39;)</span></span><br></pre></td></tr></table></figure>

如果用 `else` 语句，代码就会简化：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">    <span class="keyword">if</span> some_judge(i):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(&amp;<span class="comment">#39;Nothing found&amp;#39;)</span></span><br></pre></td></tr></table></figure>

如果 `if` 判断成立了，就会进入 `break`，于是 `else` 的代码就不会执行，否则就会输出 Nothing found。和上面的例子相比，使用 `else` 的代码更简洁，而且不需要再用一个变量来标记了。

#### 4.1.2 while else

仅当 `while` 循环因为判断条件不成立而退出，而不是因为 `break` 才退出时，才会执行 `else` 代码块，用法和 `for ... else ...` 基本一致。

#### 4.1.3 try else

仅当 `try` 代码块中没有抛出异常时才会执行 `else`。为了理解 `try ... else` 的使用场景，我们先看一个常见的场景。

一个很常见的错误是为了处理异常，把一大段代码都放在 `try` 语句中：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 写了几十行毫无问题的代码</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    some_dangarous_operation()</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 下面跟了几十行毫无问题的代码</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 处理异常</span></span><br></pre></td></tr></table></figure>

这种写法非常不负责任，`try` 不是防止崩溃的银弹，而是应该用在真正可能导致异常的函数上，所以要保证 `try` 的代码块尽可能简单，突出要尝试执行的代码。以这段代码为例，`some_dangarous_operation` 函数之前的代码可以放在 `try` 代码块上面写，但如果 `some_dangarous_operation` 函数之后的代码依赖于这个函数的正确执行，就不太好独立出来了。这时候就该 `try ... else` 发挥作用了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some_dangarous_operation 之前的安全代码写在这里</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    some_dangarous_operation()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 处理异常</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 依赖于 some_dangarous_operation 的安全代码</span></span><br></pre></td></tr></table></figure>

### 4.2 迭代器

#### 4.2.1 迭代器

迭代器接口定义了两个方法，`__next__`  方法没有参数，用于返回序列的下一个元素，如果没有元素就抛出 `StopIteration` 异常，`__iter__`方法返回自己。

根据鸭子类型的定义，一个类不用声明为迭代器，只要它实现了迭代器接口中定义的两个方法，就可以迭代：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span>:</span></span><br><span class="line">	index = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.index &amp;gt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">raise</span>  StopIteration</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			self.index += <span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> self.index</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">()</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">i = MyIterator()</span><br><span class="line">next(i) <span class="comment"># 得到 1，i 的 index 为 1</span></span><br><span class="line">next(i) <span class="comment"># 得到 1，i 的 index 为 2</span></span><br><span class="line">next(i) <span class="comment"># 得到 1，i 的 index 为 3</span></span><br><span class="line">next(i) <span class="comment"># 根据 if 判断的条件，抛出 StopIteration 异常，迭代结束</span></span><br></pre></td></tr></table></figure>

`next` 函数的参数是迭代器，用于获取迭代器中的下一个元素。

#### 4.2.2 可迭代对象

用 `next` 函数去迭代一个迭代器对象，不仅语法繁琐，每次还要用 `try catch` 来处理随时都有可能发生的 `StopIteration` 异常，这种写法实在是太啰嗦了。所以我们平时都用 `for in` 语法来遍历字符串、数组等可迭代对象：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> &amp;<span class="comment">#39;bestswifter&amp;#39;:</span></span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>

这种写法其实是对迭代器的封装：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it = iter(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		print(next(it))</span><br><span class="line">	<span class="keyword">except</span> StopIteration:</span><br><span class="line">		<span class="keyword">del</span> it</span><br><span class="line">		<span class="keyword">break</span></span><br></pre></td></tr></table></figure>

可见 `for in` 语法省略了大量的模板代码。可以看到这里的字符串是可迭代对象，在用 `for in` 遍历时，其实是通过 `iter` 函数获取了可迭代对象的迭代器，然后用 `next` 函数去遍历这个迭代器，这揭示了迭代器和可迭代对象之间重要的关系：**Python 用 iter 函数从可迭代对象中获取迭代器**。

#### 4.2.3 \__iter__ 方法
能够用 `for in` 语法遍历的对象必须是可迭代的，除了内置的数组、元组等类型外，自定义的类型也有办法变成可迭代的，因为 `iter` 函数最终会调用对象的  `__iter` 方法。我们只要能实现这个方法，返回适当的迭代器，就可以让对象变成可迭代的，并支持 `for in` 语法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Foo():</span><br><span class="line">	print(i) <span class="comment"># 共三行输出，分别是 1、2 和 3</span></span><br></pre></td></tr></table></figure>

没实现 `__iter__` 方法，但是实现了 `__getitem__` 方法的对象也是可迭代的，这个函数在 1.1.5 节中已经介绍过，用来处理下标访问。Python 会创建一个迭代器，并且用从 0 开始的整数调用 `__getitem__` 方法作为迭代器的 `next` 值。如果实现了 `__len__` 是最好，Python 解释器只会调用指定次数的 `__getitem__`，否则会在越界时自动停止。

再次总结下，可迭代对象和迭代器是两个概念，写在 `for in` 中的是可迭代对象，它需要实现 `__iter__` 方法为 `iter` 方法提供一个迭代器。迭代器需要满足迭代器接口， 也就是两个函数。无参数的 `__next__` 方法提供下一个元素或者抛出异常，`__iter__` 函数返回自己。从这个角度看，迭代器都是可迭代对象。

#### 4.2.4 标准迭代器

有了上述知识作为铺垫，我们来尝试实现一个定义的可迭代对象。它只需要实现一个 `__iter__` 方法，返回迭代器即可，一个常见的写法如下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	_private_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.count &amp;lt; len(self._private_data):</span><br><span class="line">			temp = self._private_data[self.count]</span><br><span class="line">			self.count += <span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> temp</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">c = MyCollection()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">	print(i) <span class="comment"># 输出三行，分别是 1，2 和 3</span></span><br></pre></td></tr></table></figure>

这段代码中，`__iter__` 函数返回了自己，并且自己实现了迭代器的接口，一切运行正常。

并且这段代码向我们展示了迭代器的第一个特点：**屏蔽内部的存取细节， 对外提供统一的访问逻辑。**

很可惜的是，这段代码是**标标准准的错误写法**，因为可迭代对象的迭代器一定不能是自己，或者说可迭代对象一定不能实现 `__next__` 方法，理由很简单，看一眼 4.2.1 节中的迭代器，它是一次性的，遍历完以后就回不去了。这里也是同理，如果我们再执行一次 `for in`，就得不到输出了。换个角度思考，上一节的结论告诉我们，同时实现了 `__iter__` 和 `__iter__` 方法的是迭代器，而迭代器是不能用于 `for in` 语句的。

正确的写法如下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>:</span></span><br><span class="line">	_private_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> MyCollectionIterator(self._private_data)</span><br><span class="line">			</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollectionIterator</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">		self.data = data</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.count &amp;lt; len(self.data):</span><br><span class="line">			temp = self.data[self.count]</span><br><span class="line">			self.count += <span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> temp</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> MyCollection():</span><br><span class="line">	print(i)</span><br></pre></td></tr></table></figure>

代码很长，但思路很简单，就是遵守迭代器和可迭代对象的定义，把一次性的迭代工作交给可以重复创建实例的  `MyCollectionIterator` 类完成。

这也正是迭代器模式的另一个特点，**对象能够正确保存多次迭代的进度，支持多次迭代。**

#### 4.2.5 初识生成器

稍有追求的程序员都难以容忍这么多模板代码（两个 `__iter__`， 一个 `__next__`），好在 Python 的生成器可以简化上述代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>:</span></span><br><span class="line">	_private_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> self._private_data:</span><br><span class="line">			<span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

从直观上看，这里用 `yield` 关键字替换了 `return`，打破了 “可迭代对象不能实现 `__next__` ” 的规定，但却能够支持多次遍历，这段代码的工作原理会在介绍完生成器以后解释。

### 4.3 生成器

#### 4.3.1 生成器的定义

先给出生成器的定义：

1. 只要函数体重有 `yield` 关键字，这个函数就是生成器函数
2. 调用生成器函数，会得到**生成器**，生成器函数可以理解为生成器的工厂
3. 调用 `next` 函数会激发生成器的下一个值

举个例子:

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    print(&amp;<span class="comment">#39;Start&amp;#39;)</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Continue&amp;#39;)</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">	</span><br><span class="line">g = gen()       <span class="comment"># 注意，这里没有输出！！！</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出两行，start 和 1</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出两行，Continue 和 2</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出 2</span></span><br><span class="line">print(next(g))  <span class="comment"># 抛出异常 StopIteration</span></span><br></pre></td></tr></table></figure>

从输出内容中可以看出，调用生成器函数会返回一个生成器对象，但生成器函数中的代码不会执行。在调用 `next(g)` 函数时才会执行生成器函数的代码，阻塞在 `yield x` 这一行，并且`next(g)` 函数的返回值就是 `x`。第几次调用 `next` 函数，就会阻塞在第几个 `yield` 处。如果是第一次接触生成器，这个逻辑需要反复体会几次。

生成器的使用方式和迭代器一致，我们可以认为生成器都是迭代器，都实现了迭代器接口。因此 4.2.5 节中的代码就很容易解释了。当外部调用 `iter()` 函数时，实际上 `__iter__` 方法中的代码并没有被立刻执行，而是返回了一个生成器。

#### 4.3.2 生成器表达式

我们在文章开头的 1.1.1 节中介绍了数组推导，生成器表达式可以理解为惰性版的数组推导：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> array] <span class="comment"># 数组推导</span></span><br><span class="line">(x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> array) <span class="comment"># 生成器表达式</span></span><br></pre></td></tr></table></figure>

两者的写法非常类似，只是把数组的大括号换成了圆括号，区别在于前者生成了一个新的数组，如果原来的数组占用 M 兆内存，现在两个数组就会占用 2 * M 兆内存。而生成器是懒计算的，并不增加内存占用。

生成器表达式对于大容量的数组，或者无尽数组特别适用，比如可以写一个斐波那契数组：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">0</span></span><br><span class="line">	b = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">		<span class="keyword">yield</span> b</span><br><span class="line">		a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># fib() 可以被当成无尽队列，我们只取前 10 个元素		</span></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(fib()):</span><br><span class="line">	<span class="keyword">if</span> i &amp;lt; <span class="number">10</span>:</span><br><span class="line">		print(n)</span><br></pre></td></tr></table></figure>

#### 4.3.3 协程

上一节中介绍的生成器有两个小缺点：

1. 这段代码无法正常退出，因为 `fib` 函数是个死循环，最终会停在第 11 个 yield 上，等待外部的 `next` 函数。
2. 现在的数据传递都是单向的，只有生成器给调用方传值，调用方无法给生成器传值。

实际上，生成器函数都是协程，我们可以利用协程的特性解决这两个问题：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fibs = fib()</span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(fibs):</span><br><span class="line">	<span class="keyword">if</span> i &amp;lt; <span class="number">10</span>:</span><br><span class="line">		print(n)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		fibs.close()</span><br></pre></td></tr></table></figure>

只要在遍历完以后调用生成器的 `close` 方法，就可以结束生成器并正确的退出了。如果需要向生成器中传值，需要调用生成器对象的 `send` 方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">0</span></span><br><span class="line">	b = <span class="number">1</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">		i = <span class="keyword">yield</span> &amp;<span class="comment">#39;第&#123;0&#125;个数是: &#123;1&#125;&amp;#39;.format(i, b)</span></span><br><span class="line">		a, b = b, a + b</span><br><span class="line">				</span><br><span class="line">fibs = fib()</span><br><span class="line">next(fibs)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	print(fibs.send(i))</span><br></pre></td></tr></table></figure>

此时，`yield` 表达式左边的值就是 `send` 函数中的参数，而 `send` 函数的返回值则是 `yield` 关键字右边的结果。

协程的用法并不复杂，但它是异步编程的基础，比如 ES 7 中的 `async/await` 语法，能将异步回调变成同步的写法，它就是依靠协程实现的。感兴趣的读者可以参考我的这篇文章：[异步与回调的设计哲学](http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/)。

#### 4.3.4 预激协程

在创建生成器时，并不会执行生成器函数中的代码，第一次调用 `next(g)` 函数时会执行到第一个 `yield` 处。而协程的 `send` 函数用来给 `yield` 左侧的变量赋值。所以在调用 `send` 函数之前一定要确保已经调用过 `next()` 函数，这样协程才会停留在 `yield` 处而不是停留在刚创建的状态。这一步操作叫做协程的预激，上一节的代码中已经演示了这一点。

在使用协程时，一般都需要预激，也就是说 `next(g)` 其实是一个模板代码，可以被优化掉。要想改变一个函数的运行逻辑，最好的方法是使用装饰器：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(original_coroutine)</span>:</span>       </span><br><span class="line"><span class="meta">	@functools.wraps(original_coroutine)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">activate</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 用 active 函数替换被装饰的 fib 函数</span></span><br><span class="line">		gen = original_coroutine(*args, **kwargs)  <span class="comment"># 调用 fib 函数</span></span><br><span class="line">		next(gen)  <span class="comment"># 预激协程</span></span><br><span class="line">		<span class="keyword">return</span> gen   <span class="comment"># 像 fib 函数一样，返回预激过的协程</span></span><br><span class="line">	<span class="keyword">return</span> activate  <span class="comment"># 被装饰的函数 fib 现在替换为了 active 函数，会自动预激</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">0</span></span><br><span class="line">	b = <span class="number">1</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">		i = <span class="keyword">yield</span> &amp;<span class="comment">#39;第&#123;0&#125;个数是: &#123;1&#125;&amp;#39;.format(i, b)</span></span><br><span class="line">		a, b = b, a + b</span><br><span class="line">					</span><br><span class="line">fibs = fib()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	print(fibs.send(i))</span><br></pre></td></tr></table></figure>

温故一下装饰器的定义，被 `coroutine` 装饰的 `fib` 函数等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_fib = coroutine(fib)</span><br><span class="line"><span class="comment"># 根据 coroutine 函数的定义，coroutine(fib) 实际上会返回下面这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activate</span><span class="params">()</span>:</span></span><br><span class="line">	gen = fib()</span><br><span class="line">	next(gen)</span><br><span class="line">	<span class="keyword">return</span> gen</span><br></pre></td></tr></table></figure>

#### 4.3.5 标准库中的生成器函数

`itertools` 模块提供了很多生成器函数，这些函数处理可迭代的对象，并且返回生成器（节省内存，可迭代）。想要了解生成器函数，唯一可能的知识来源就是这篇[官方文档](https://docs.python.org/3/library/itertools.html#module-itertools)，本节会做简单的翻译和解释。它把生成器函数分为三大类。

第一类函数返回的是无限生成器：

| 函数名        | 参数           | 返回结果  | 示例|
| :------------- |:-------------| :-----| :----|
| [count()](https://docs.python.org/3/library/itertools.html#itertools.count)| start, [step] | start, start+step, start+2*step, … |`count(10) --&gt; 10 11 12 13 14 ...`
| [copy()]()     | p（数组） | p0, p1, ...， pn, p0, p1, ... |`cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D ...`
| [repeat()](https://docs.python.org/3/library/itertools.html#itertools.repeat) | elem [,n] | elem, elem, elem, … 无尽队列或最多 n 次| `repeat(10, 3) --&gt; 10 10 10`

这三个函数的注释都说明得清楚了，配合示例应该非常容易理解。

第二类函数返回的是有限生成器，长度和传入的可迭代对象有关，我选择几个比较常用的列出来 ：

| 函数名        | 参数           | 返回结果  | 示例|
| :------------- |:-------------| :-----| :----|
|[accumulate()](https://docs.python.org/3/library/itertools.html#itertools.accumulate)|p [,func]|p0, func(p0, p1), func(p1, p2), func(p2, p3) ...|`accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15`|
|[chain()](https://docs.python.org/3/library/itertools.html#itertools.chain)|p, q, …|p0, p1, … plast, q0, q1, …|`chain(&#39;ABC&#39;, &#39;DEF&#39;) --&gt; A B C D E F`|
|[compress()](https://docs.python.org/3/library/itertools.html#itertools.compress)|data, selectors|	(d[0] if s[0]), (d[1] if s[1]), …|`compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&gt; A C E F`|
|[dropwhile()](https://docs.python.org/3/library/itertools.html#itertools.dropwhile)|pred, seq|假设 pred 在第 n 个元素开始不成立：seq[n], seq[n+1]|`dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1`|
|[tee()](https://docs.python.org/3/library/itertools.html#itertools.tee)|it, n|产出 n 各元素的数组，每个元素可以看做 it 的备份，相当于把 it 复制了 n 份|`tee(&#39;ABC&#39;, 2) --&gt; g1, g2(迭代 g1 和 g2 都会得到 A、B、C)`|

最后一类是可以实现排列组合操作的生成器函数：

| 函数名        | 参数           | 返回结果  |
| :------------- |:-------------| :-----|
|[product()](https://docs.python.org/3/library/itertools.html#itertools.product)|p, q, … [repeat=1]|生成各个可迭代对象的笛卡尔积，n 表示每个可迭代对象对象重复几次|
|[permutations()](https://docs.python.org/3/library/itertools.html#itertools.permutations)|p[, r]|序列 p 所有长度为 r 的无重复元素排列|
|[combinations()](https://docs.python.org/3/library/itertools.html#itertools.combinations)|p, [r]|序列 p 所有长度为 r 的无重复元素有序排列|
|[combinations_with_replacement()](https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement)|p, [r]|序列 p 所有长度为 r 的有重复元素有序排列|

举例说明：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># ABC 和 12 的笛卡尔积，所以共有 6 个元素</span></span><br><span class="line"><span class="comment"># 得到：A1、A2、B1、B2、C1、C2</span></span><br><span class="line">l1 = list(product(&amp;<span class="comment">#39;ABC&amp;#39;, &amp;#39;12&amp;#39;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于 product(&amp;#39;AB&amp;#39;, &amp;#39;AB&amp;#39;)</span></span><br><span class="line"><span class="comment"># 得到：AA、AB、BA、BB</span></span><br><span class="line">l2 = list(product(&amp;<span class="comment">#39;AB&amp;#39;, repeat=2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ABCD 所有所有长度为 2 的无重复、无序子排列</span></span><br><span class="line"><span class="comment"># 每个元素可以和除了自己的另外三个元素组合，因此有 4 * 3 个</span></span><br><span class="line"><span class="comment"># 得到：AB、AC、AD、BA、BC、BD、CA、CB、CD、DA、DB、DC</span></span><br><span class="line">l3 = list(permutations(&amp;<span class="comment">#39;ABCD&amp;#39;, 2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ABCD 所有所有长度为 2 的无重复、有序子排列</span></span><br><span class="line"><span class="comment"># AB 和 BA 会被认为是相同的，所以只有 12 / 2 = 6 个</span></span><br><span class="line"><span class="comment"># AB、AC、AD、BC、BD、CD</span></span><br><span class="line">l4 = list(combinations(&amp;<span class="comment">#39;ABCD&amp;#39;, 2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ABCD 所有所有长度为 2 的有重复、有序子排列</span></span><br><span class="line"><span class="comment"># AA、BB 这样的也合法，所以有 6 + 4 = 10 个</span></span><br><span class="line"><span class="comment"># 得到：AA、AB、AC、AD、BB、BC、BD、CC、CD、DD</span></span><br><span class="line">l5 = list(combinations_with_replacement(&amp;<span class="comment">#39;ABCD&amp;#39;, 2))</span></span><br></pre></td></tr></table></figure>

本节仅列出了一部分常用的生成器函数，他们是系统库提供的轮子。因此在自己实现关于序列的操作以前，应该思考下这是否是常见操作，系统是否已经提供了轮子。在[官方文档的最后一节](https://docs.python.org/3/library/itertools.html#itertools-recipes) 还有一些基于上述生成器函数的拓展，通过简单的封装了 `itertools` 模块中的生成器函数，提供了更多常见的函数，比如 `take`、`tail`、`consume`、`nth`、`flatten` 等等，**强烈建议阅读一遍并且形成基本印象!**

### 4.4 上下文管理器

#### 4.4.1 with 块

`with` 代码块的一个常见用法是用于打开文件，有经验的 Python 程序员不会建议你写出这样的代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(file_path)</span><br><span class="line">data = f.readlines()</span><br><span class="line"><span class="comment"># 处理 data</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

用 `with` 块的写法则是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    <span class="comment"># 处理 data</span></span><br></pre></td></tr></table></figure>

这样写的好处不仅仅是不用在最后关闭文件。试想一下，如果在处理文件的过程中有多个地方有可能会抛出异常，那么在所有 `try catch` 语法的最后都要写上 `finally` 以便关闭文件。如果放到 `with` 块中写，则不需要在这么多代码。

#### 4.4.2 自定义上下文

`with` 块的本质是为了简化 `try finally` 语句，以上一节的代码为例，跟在 `with` 后面的`open()` 函数会返回一个对象，它是 `TextIOWrapper` 类的实例，我们把它称为上下文管理器，上下文管理器需要实现 `__enter__` 和 `__exit__` 方法。

`__enter__` 方法的返回值可以用 `as` 来引用，这里上下文管理器的 `__enter__` 方法的返回值是 self，所以以下两种写法中的文件句柄 `fp` 是等价的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp = open(file_path)</span><br><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> fp</span><br></pre></td></tr></table></figure>

第一行中的 `fp` 可以理解为第二行中的上下文管理器，也就是 `with` 后面表达式的返回值。而 `as` 后面的 `fp` 则是上下文管理器的 `__enter__` 方法的返回值，由于这里返回的是 `self`，所以两者恰好相同。

无论以哪种方式退出 `with` 块（正常结束或者因为抛出异常而退出），都会调用上下文管理器的 `__exit__` 方法。注意，这里不是 `__enter__` 方法返回值的 `__exit__` 方法。这一点很好理解，因为前者一定实现了 `__enter__` 方法，但后者不一定。

了解了上下文的概念后，我们可以自定义一个上下文，其实也就是定义一个实现了 `__enter__` 和 `__exit__` 方法的类：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(self, content)</span>:</span></span><br><span class="line">		self.original_write(content[::<span class="number">-1</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.original_write = sys.stdout.write</span><br><span class="line">		sys.stdout.write = self.reverse_write</span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="comment">#39;Enter context&amp;#39;[::-1]  # 这个字符串会被倒序打印，所以先倒序一次</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">		sys.stdout.write = self.original_write</span><br><span class="line">		print(exc_type, exc_value, traceback)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">with</span> Reverse() <span class="keyword">as</span> r:</span><br><span class="line">	print(r)  <span class="comment"># 因为字符串已经被倒序过，所以这里输出 &amp;#39;Enter context&amp;#39;</span></span><br><span class="line">	print(&amp;<span class="comment">#39;bestswifter&amp;#39;) # 输出 &amp;#39;retfiwstseb&amp;#39;</span></span><br><span class="line">	<span class="keyword">raise</span> AttributeError <span class="comment"># 输出 &amp;lt;class &amp;#39;AttributeError&amp;#39;&amp;gt;  &amp;lt;traceback object at 0x10bcb45c8&amp;gt;</span></span><br><span class="line">	print(&amp;<span class="comment">#39;will not be print&amp;#39;)  # 因为发生了异常，所以不会执行这一行</span></span><br></pre></td></tr></table></figure>

在进入上下文的时候，我们用自定义的方法替换了系统的标准输出，所以上下文中所有的输出都是倒序的。直到上下文结束时才换回来。

`__exit__` 方法有三个参数，分别表示异常的类型，异常的实例，以及发生异常处的调用栈。如果在 `with` 块中发生了异常，异常处后面的代码都不会执行。`__exit__` 方法如果返回 True，表示异常已经被正确处理，否则异常会向上冒泡到 `with` 代码块外面。

#### 4.4.3 标准库中的上下文

使用标准库中的装饰器可以节省一些模板代码，`__enter__` 和 `__exit__` 方法可以写在一起，以 `yield` 为分界线：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reverse</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(content)</span>:</span></span><br><span class="line">		original_write(content[::<span class="number">-1</span>])</span><br><span class="line">	</span><br><span class="line">	original_write = sys.stdout.write</span><br><span class="line">	sys.stdout.write = reverse_write</span><br><span class="line">	<span class="keyword">yield</span> &amp;<span class="comment">#39;Enter context&amp;#39;[::-1] # 下一行开始，是 __exit__ 的逻辑</span></span><br><span class="line">	sys.stdout.write = original_write</span><br></pre></td></tr></table></figure>

`@contextlib.contextmanager` 的缺点是无法通过 `return True/False` 来控制是否需要冒泡异常，必须把 `yield` 代码放到 `try catch` 中。

## 5. 其他 Python 特色

### 5.1 多线程与GIL

#### 5.1.1 多线程

多线程操作一般通过 `threading` 模块来完成，启动一个线程其实就是把线程要执行的函数传递到 `Thread` 类的初始化方法中，然后调用 `Thread` 实例的 `start` 方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">think</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;start thinking in thread: &amp;#39; + threading.current_thread().name)</span></span><br><span class="line">	sleep(<span class="number">1</span>)</span><br><span class="line">	print(&amp;<span class="comment">#39;end thinking&amp;#39;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	t = threading.Thread(target = think)</span><br><span class="line">	t.start()</span><br><span class="line">print(&amp;<span class="comment">#39;Exit&amp;#39;)</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-1</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-2</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-3</span></span><br><span class="line"><span class="comment"># Exit</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br></pre></td></tr></table></figure>

从输出结果来看，Python 的线程都是异步执行，如果要同步执行某个线程，需要调用线程的 `join` 方法，表示阻塞当前线程，直到整个线程退出为止：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	t = threading.Thread(target = think)</span><br><span class="line">	t.start()</span><br><span class="line">	t.join()</span><br><span class="line">print(&amp;<span class="comment">#39;Exit&amp;#39;)</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-1</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-2</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-3</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># Exit</span></span><br></pre></td></tr></table></figure>

#### 5.1.2 线程锁

像 `a += 1` 这样的语句，是线程不安全的，因为它不是原子性操作。如果想保证某段代码最多同时被一个线程执行，可以给它加锁：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">think</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> i</span><br><span class="line">	lock.acquire()</span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line">	lock.release()</span><br></pre></td></tr></table></figure>

注意到这里的加锁和释放锁又是上下对应的模板代码，这类代码都可以用 `with` 块配合上下文解决。Python 提供了现成的写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">think</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> i</span><br><span class="line">	<span class="keyword">with</span> lock:</span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

在 `threading.Lock` 类的 `__exit__` 方法中会自动释放锁。

#### 5.1.3 GIL

我们知道 Python 这种动态语言是由解释器在运行时动态解释并执行的，如果有多个线程同时执行，就意味着有多个解释器也在运行。为了保证解释器自己的线程安全性，有些  Python 解释器（比如最常见的 CPython）采用了一种很暴力的解决方式：**全局锁**，也就是 Global Interpreter Lock， GIL。再次声明，GIL 不是 Python 的特性，仅仅是特定解释器的特性，比如另一个解释器 JPython 就没有 GIL，不过 CPython 是绝大多数场景下默认的 Python 的解释器，所以有人可能会把 GIL 与 Python 混为一谈。

GIL 最直接的副作用就是严重影响多线程的性能，因为同一时刻只有一个线程能获得锁。GIL 可以用如下伪代码表示：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    acquire GIL</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        do_something()</span><br><span class="line">    release GIL</span><br></pre></td></tr></table></figure>

当某个线程因为睡眠、IO 或超时释放 GIL 后，从代码中可以看到，它距离再次获得 GIL 仅有一条指令。所以在实际运行时，有很大可能是一个线程不断的释放、获取 GIL，而别的线程一直在等待。由于线程上下文切换存在一定的开销，多个 CPU 密集型的线程同时运行，性能反而比在同一个线程内运行要低。

如果是多个 IO 密集型的线程同时运行，GIL 不会影响性能，因为线程在执行 IO 操作时会主动释放 GIL 锁，因此会出现没有线程获取 GIL 锁（因为大家都在 IO），谁结束了 IO 谁就使用线程的情况。不过需要注意的是，多个 IO 密集型的线程和一个 CPU 密集型线程同时执行时，性能也会受到影响。因为之前解释过，CPU 密集型的线程倾向于一直占有 GIL，导致 IO 密集型线程在 IO 结束后无法立刻获取 GIL，空等一段时间。

具体的测试结果可以参考：[Python的GIL是什么鬼，多线程性能究竟如何](http://cenalulu.github.io/python/gil-in-python/)。

如果想要避免 GIL 对性能的影响，有以下几种思路：

1. 多个 IO 密集型线程不受影响，但不要混入 CPU 密集型线程
2. 使用 JPython 这样的解释器代替 CPython，但这样做就无法再使用社区已有的 C 语言模块
3. 使用多进程，多个进程有多个 GIL，自然就互不干扰

#### 5.1.4 多进程

Python 中实现多进程非常简单，因为接口与多线程基本一致：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(i)</span>:</span></span><br><span class="line">	print(i)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">	p = multiprocessing.Process(target=run_proc, args=(i,))</span><br><span class="line">	p.start()</span><br><span class="line">print(&amp;<span class="comment">#39;End&amp;#39;)</span></span><br></pre></td></tr></table></figure>

多进程中没有锁的概念，因为不同的线程可以共享进程的堆，而不同的进程就没有应用层面可以共享的内容了，只能依赖于操作系统提供的 API，比如共享内存、socket、管道、消息队列等。

以消息队列为例，简单展示下进程间共享数据：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(q)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">		i = q.get()</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		q.put(i)</span><br><span class="line">		print(i)</span><br><span class="line">	</span><br><span class="line">q = Queue()</span><br><span class="line">q.put(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p1 = Process(target=run_proc, args=(q,))</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p2 = Process(target=run_proc, args=(q,))</span><br><span class="line">p2.start()</span><br></pre></td></tr></table></figure>

每个进程都会从消息队列中读取变量，加一后放回队列，所以输出结果是 1 到 20。如果不用消息队列来共享，每个进程的变量 `i` 都是独立的，会输出两次 1 到 10。

### 5.2 我眼中的  Python
#### 5.2.1 Python 是动态强类型语言

这句话其实说了两个概念： **Python 是动态类型语言**，以及 **Python 是强类型语言**，很多人会把这两组概念混淆。

首先，动/静态类型语言的区别在于类型被确认的时机。以 C 这类语言来说，编译器会检查变量的类型，比如 `int a = &quot;hello&quot;;` 就无法通过编译，这就说明 C 语言是静态类型语言。而对于 Python 来说，`a = &quot;hello&quot;` 直到运行时，才会确定 a 引用的对象的类型是 `str`。

动态类型语言并非看上去没有类型标记那么简单，一方面，Swift 这样的语言支持类型推导，所以支持 `var s = &quot;hello&quot;` 这种写法，但这并不意味着 Swift 就是动态类型语言了，因为它的类型判断还是在编译期完成的，只不过编译器更加智能，可以推导出来而已。

另一方面，不在编译期检查类型并不意味着动态类型语言对类型的校验就是宽松的，这是另一个维度的衡量指标。如果语言对类型的校验很宽松，支持隐式转换，我们就称这种语言是 **“弱类型语言”**，否则就是**强类型语言**。强类型语言更严格，一定程度上语法会更啰嗦，弱类型语言代码更简单，更脚本化。以输出 **&quot;My age is 22&quot;** 为例：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">22</span></span><br><span class="line">string = &amp;<span class="comment">#39;My age is &amp;#39;</span></span><br><span class="line">print(string + str(number))</span><br></pre></td></tr></table></figure>

这里必须把数字先转为字符串，才能和别的字符串拼接，这是因为 `str` 类的 `__add__` 函数只支持 `str` 类型的参数。可以看到，虽然数字（或者其他实现了 `__str__` 方法的自定义类）可以转为字符串，但这种转换必须是显式写明的，Python 并不支持隐式转换。

但用别的语言，比如 JavaScript 来实现类似的逻辑就非常简单了：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">22</span></span><br><span class="line">string = &amp;#39;My age is &amp;#39;</span><br><span class="line"><span class="built_in">console</span>.log(string + number);</span><br></pre></td></tr></table></figure>

可见，JavaScript 支持从数字到字符串的隐式转换。但这种隐式的转换也不一定是好事，比如再举一个例子：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">22</span></span><br><span class="line">string = &amp;#39;2&amp;#39;</span><br><span class="line"><span class="built_in">console</span>.log(string + number)</span><br></pre></td></tr></table></figure>

它的输出结果是 &#39;222&#39;，可见是把数字隐式的转成了字符串，然而如果我的本意是要把字符串转数字呢，比如这段代码在 PHP 中的输出就是 24：

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;?php</span><br><span class="line">	$n = <span class="number">22</span>;</span><br><span class="line">	$s = &amp;quot;<span class="number">2</span>&amp;quot;;</span><br><span class="line">	<span class="keyword">print</span> $s + $n</span><br><span class="line">?&amp;gt;</span><br></pre></td></tr></table></figure>

因此，关于语言的强/弱类型，我想可以总结两点：

1. 类型的强弱是一个相对的概念，不像动态/静态类型那样有明确的判断标准。因为隐式转换可以发生在很多地方，有的语言支持的隐式转换场景很多，有的支持的场景很少，所以一般来说我们只能说某个语言的类型比较强（弱）或者说某个语言的类型比另一个语言更强（弱）。
2. 强弱类型没有优劣之分，强类型语言更严谨，不容易出现 Bug，但是代码复杂，书写成本高。弱类型语言更脚本化，写起来很简单，但很多规则并不那么显然，增加了学习成本。

#### 5.2.2 开发效率高

Python 中到处都是**鸭子类型**的实践：不关注一个类的类型本身，而是关注这个类具有什么能力。比如我们会发现，数组和字符串的下标访问高度类似，这在很多静态类型语言中是几乎不可能发生的。很多自定义类因为使用了多继承、迭代器、双下方法，使用起来与内置的数据类型基本上没有区别。

此外，脚本语言的一个主要特色就是 handy，理论上来说 Python 能做的事，没什么是 C 做不到的。然而我们希望用简单的 API，用文本编辑器花上一两分钟就写出来一个脚本，而不是查阅手册，打开 IDE，编译以后再执行。所以 Python 提供了很多语言层面的支持，比如推导、else 块、切片和功能强大的内置函数等。

另外，Python 具备强大的元编程能力，装饰器、高阶函数、函数内省、元类具有非常强的内省和动态能力。内省帮助我们在运行时获取足够多的信息，动态性帮助我们实现很多很有意思的能力。因此我们看到 Python 中很少有模板代码，虽然内部实现有时候相对晦涩难懂，但对外的接口则是高度统一。

#### 5.2.3 对新人不是很友好

开发效率高的背后也有隐患，简洁高效的语法可能意味着过度封装，因此 Python 的性能经常遭到抨击（但是脚本语言并不应该考虑这一点）。

鸭子类型容易带来太多的魔术方法。在 Java 中，一切都有迹可循，某个类能调用方法，一定是因为它自己实现了方法，或者从接口、父类那里继承来了。而 Python 不一样，方法的调用和方法的真正实现之间也许没有语言层面的直接关联，而是依靠文档规范、魔术方法或者约定。这给新手阅读 Python 代码带来了极大的困难，通常无从下手，连搜索什么关键字都不知道，这也是本文写作的目的之一。

元编程能力允许用户直接享受到大牛们封装好的库和能力，但也容易被滥用。元编程学习门槛高，而且通常实现一个需求有不止一种方法。如果大家各自造轮子，很可能质量参差不齐，互相理解起来也比较困难。

### 5.3 其它 Python 技巧

很多时候我们从网上摘抄下来的代码仅仅刚好能工作，但对它的细节却不是很了解。本节主要列出一些常用的 Python 代码或者技巧并用实际的例子解释各处细节，持续更新中。

#### 5.3.1 文件读写

读取文件时，一般会这样写代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(&amp;<span class="comment">#39;path_to_file&amp;#39;, &amp;#39;r&amp;#39;) as f:</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">	    print(line)</span><br><span class="line"><span class="comment"># first line</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># second line</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># third line</span></span><br></pre></td></tr></table></figure>

`open` 函数的第二个参数表示打开模式，`r` 表示读取，`w` 表示写入，会删除原来的所有内容，`a` 表示在文件后面追加写入。

一般来说不要用 `readlines` 读取文件，因为如果文件特别大， 读出来的数组可能会非常占用内存。我们会看到输出结果一般都有多个空行，这是因为每行的结尾都有 &#39;\n&#39; 换行符，而且 `print` 函数自己就会换行。如果想要更美观的输出，可以用 `replace` 或者 `rstrip` 函数干掉换行符。

如果我们用 `open(&#39;path_to_file&#39;. &#39;rb&#39;)` 来打开文件，就可以读取到原来的二进制：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(&amp;<span class="comment">#39;file_to_path&amp;#39;, &amp;#39;rb&amp;#39;) as f:</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">	    print(line)</span><br><span class="line"><span class="comment"># b&amp;#39;first line\n&amp;#39;</span></span><br><span class="line"><span class="comment"># b&amp;#39;second line\n&amp;#39;</span></span><br><span class="line"><span class="comment"># b&amp;#39;third line\n&amp;#39;</span></span><br></pre></td></tr></table></figure>

这里我们本来应该看到的是各个字母的 UTF-8 编码后的二进制，不过在打印的时候被系统自动转成字母了。在文件不是UTF-8 编码时，一定要用二进制格式去打开文件并且自行解码，否则 Python 会尝试用 UTF-8 去解码，极有可能会因为无法解码而导致报错。

我们可以试着把二进制写入到文件中：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello world&amp;#39;</span></span><br><span class="line">b = [x.encode(&amp;<span class="comment">#39;utf16&amp;#39;) for x in s]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(&amp;<span class="comment">#39;path_to_file&amp;#39;, &amp;#39;wb&amp;#39;) as f:</span></span><br><span class="line">	f.writelines(b)</span><br></pre></td></tr></table></figure>

`writelines` 函数的参数是数组，相当于对数组中的每个元素调用了 `write()` 方法。

感兴趣的读者可以试着分别用 `r` 和 `rb` 去打开文件，感受其中的区别。

#### 5.3.2 JSON 读写

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = &#123;&amp;<span class="comment">#39;name&amp;#39;: &amp;#39;bestswifter&amp;#39;, &amp;#39;age&amp;#39;: 22&#125;</span></span><br><span class="line">json.dumps(d)  <span class="comment"># 返回字符串：&#123;&amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;, &amp;quot;age&amp;quot;: 22&#125;</span></span><br></pre></td></tr></table></figure>

最简单的对象转 JSON 通过 `json` 模块的 `dumps` 函数来完成，最后一个字母 s 表示生成字符串，也可以用 `dump(data, fp)` 来把内容写入文件：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = &#123;&amp;<span class="comment">#39;name&amp;#39;: &amp;#39;bestswifter&amp;#39;, &amp;#39;age&amp;#39;: 22&#125;</span></span><br><span class="line"><span class="keyword">with</span> opne(&amp;<span class="comment">#39;path_to_file&amp;#39;, &amp;#39;w&amp;#39;) as f:</span></span><br><span class="line">    json.dump(d, f)</span><br></pre></td></tr></table></figure>

调用 `dumps` 参数时，有几个命令可能会派上作用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = &#123;&amp;<span class="comment">#39;name&amp;#39;: &amp;#39;bestswifter&amp;#39;, &amp;#39;age&amp;#39;: 22&#125;</span></span><br><span class="line">json.dumps(d, skipkeys=<span class="keyword">True</span>, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&#123;</span></span><br><span class="line"><span class="comment">#    &amp;quot;age&amp;quot;: 22,</span></span><br><span class="line"><span class="comment">#    &amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>

其中，`sort_keys` 表示对字典的键排序，这样输出结果一定是固定的，`indent` 用于控制多少个空格缩进，可以增加可读性。`skipkeys` 表示如果字典的键不是字符串，就忽略这一条记录。

JSON 支持的类型很有限，只有 `None` ， `bool` ， `int` ， `float` 和 `str` 这五种基本类型和包含这些类型的字典或者数组。自定义的对象如果转成 JSON 默认会报错，我们可以实现一个通用函数，读取任意对象的 `__dict__`，这样就可以用于 JSON 化了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialize_instance</span><span class="params">(obj)</span>:</span></span><br><span class="line">	d = &#123; &amp;<span class="comment">#39;class&amp;#39; : type(obj).__name__ &#125;</span></span><br><span class="line">	d.update(vars(obj))</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line"></span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;, 22)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接 dumps(bs) 会得到这个报错：</span></span><br><span class="line"><span class="comment"># TypeError: Object of type &amp;#39;Person&amp;#39; is not JSON serializable</span></span><br><span class="line"></span><br><span class="line">json.dumps(serialize_instance(bs), skipkeys=<span class="keyword">True</span>, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&#123;</span></span><br><span class="line"><span class="comment">#    &amp;quot;age&amp;quot;: 22,</span></span><br><span class="line"><span class="comment">#    &amp;quot;class&amp;quot;: &amp;quot;Person&amp;quot;,</span></span><br><span class="line"><span class="comment">#    &amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>

或者更优雅的做法是使用 3.3.3 节中介绍的 Mixin：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意 Mixin 的原则，功能要单一，实现上不能依赖子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Serializable</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self)</span>:</span></span><br><span class="line">		d = &#123; &amp;<span class="comment">#39;class&amp;#39; : type(self).__name__ &#125;</span></span><br><span class="line">		d.update(vars(self))</span><br><span class="line">		<span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混入 Serializable 立刻就有了转字典的能力，或者也可以重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Serializable)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line"></span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;, 22)</span></span><br><span class="line">	</span><br><span class="line">json.dumps(bs.serialize())</span><br></pre></td></tr></table></figure>

解析 JSON 字符串的方法也是类似的，调用 `json.loads()` 函数即可：


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">s = &amp;<span class="comment">#39;&#123;&amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;, &amp;quot;age&amp;quot;: 22&#125;&amp;#39;</span></span><br><span class="line">d = json.loads(s)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>

这里的 `loads` 表示从字符串中读取 JSON，也可以用 `load` 函数从文件中读取。不过有时候我们更希望把读取出来的字典直接转成对象。这需要调用者提供一个函数，把字典转换成对象，一般需要用到元编程。下面是一个简单的示例：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deserializable</span>:</span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(cls, d)</span>:</span></span><br><span class="line">		clsname = d.pop(&amp;<span class="comment">#39;classname&amp;#39;, None)</span></span><br><span class="line">		<span class="keyword">if</span> clsname:</span><br><span class="line">			obj = cls.__new__(cls)</span><br><span class="line">			<span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">				setattr(obj, key, value)</span><br><span class="line">			<span class="keyword">return</span> obj</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Deserializable)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line"></span><br><span class="line">s = &amp;<span class="comment">#39;&#123;&amp;quot;age&amp;quot;: 22, &amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;&#125;&amp;#39;</span></span><br><span class="line">bs = json.loads(s, object_hook = Person.deserialize)</span><br><span class="line">print(bs)</span><br></pre></td></tr></table></figure>

`Person` 类通过混入 `Deserializable` 具备了反序列化的能力，只要把这个函数传入 `loads` 方法中即可，`deserialize` 函数的第一个参数是调用类，第二个参数是解析出来的字典。这段代码其实等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = json.loads(s)</span><br><span class="line">bs = Person.deserialize(d)</span><br></pre></td></tr></table></figure>

#### 5.3.3 执行 Shell

Python 中调用 `Shell` 命令的方法有很多种，我最常用的是 `os.popen` 函数，它的返回结果是文件句柄，因此可以调用 `readlines` 函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">r = os.popen(&amp;<span class="comment">#39;pwd&amp;#39;)</span></span><br><span class="line">print(r.readlines())</span><br><span class="line"><span class="comment"># 输出 [&amp;#39;/Users/zxy/Desktop\n&amp;#39;]</span></span><br></pre></td></tr></table></figure>

这个结果表示 Shell 命令的输出只有一行，且内容是 `/Users/zxy/Desktop`。

### 5.4 Python 模块化

#### 5.4.1 Python 中的模块

Python 不仅可以用来编写短小精悍的脚本文件，也能用来开发大型项目，这就需要把代码合理的写在各个模块中，确保**高内聚、低耦合**。

每一个 Python 文件都是一个模块，我们知道 `import` 关键字可以导入系统模块，也可以用 `import module_name` 的写法导入别的模块。

假设文件路径如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package</span><br><span class="line">|-- main.py</span><br><span class="line">|-- module.py</span><br></pre></td></tr></table></figure>

那么可以这样引用别的模块 

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In module.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># In main.py</span></span><br><span class="line"><span class="keyword">import</span> module</span><br><span class="line">modul1.add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 返回 3</span></span><br></pre></td></tr></table></figure>

#### 5.4.2 模块查找顺序

对于被 `import` 的模块，Python 首先会检查它是不是内置的模块，比如我们把刚刚的 `module.py` 文件重命名为 `time.py`，再引用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 报错：AttributeError: module &amp;#39;time&amp;#39; has no attribute &amp;#39;add&amp;#39;</span></span><br></pre></td></tr></table></figure>

这是因为 Python 最先查找内置的模块，我们打印 time 模块就可以看到 `&lt;module &#39;time&#39; (built-in)&gt;` ，说明这是一个内置模块。PS：`string` 模块不是内置模块，坑了我一晚上。

如果导入的不是内置模块，Python 会依次在 `sys.path` 这个数组中的每个路径中寻找。按照查找优先级，它由三个部分组成：

1. Python 执行的入口文件（比如这里的 `main.py`）所在的路径
2. 系统的环境变量 `$PYTHONPATH` 所表示的目录
3. `site` 路径，也就是 `/usr/local/lib/python3.5/site-packages` 这种。

如果我们把 `time.py` 改名为 `string.py` 就会得到正常结果，这是因为它属于第一部分，而 Python 默认的 `string` 模块位于第三部分，优先级比较低。

一般来说，Python 工程中的文件都能在第一部分被找到，而 `pip` 安装的第三方库位于第三部分。环境变量 `PYTHONPATH` 一般都是空，但不排除某些 IDE，比如 PyCharm 会修改它。这种行为很危险，因为能在 PyCharm 中编译通过很可能是借助环境变量才找到了模块，一旦迁移到别的环境就无法编译，我似乎遇到过这个坑，将本地可以运行的代码上传到 VPS 以后就找不到模块了。

#### 5.4.3 包与 \__init__.py

当代码量进一步膨胀时，可能多个模块也无法合理的拆分逻辑了，我们可以把实现某个特定功能的若干个模块组合起来，形成一个包。包在逻辑上可以理解为若干个模块的组合， 在物理上讲，包都是文件夹，模块都是文件。

注意，**文件夹不都是包，只有存在 \__init__.py 文件的文件夹才是模块！**

在导入时，我们可以导入类，也可以导入类里面的全局变量或者全局函数，还可以导入包：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package</span><br><span class="line"><span class="keyword">import</span> module</span><br></pre></td></tr></table></figure>

如果类名和变量名太长，可以用 as 关键字重命名：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module.var <span class="keyword">as</span> v</span><br><span class="line"><span class="keyword">import</span> module.func <span class="keyword">as</span> f</span><br></pre></td></tr></table></figure>

一般来说导入包并没有太大的作用，后续还是需要导入包中的模块。如果确实需要直接用到包中的函数或者变量，可以把它定义在 `__init__.py` 文件中。

`__init__.py` 用于把一个目录标记为包，如果没有这个文件，目录又和 Python 模块重名，就会调用到 Python 的模块，假设文件层级如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">|-- main.py</span><br><span class="line">|-- string</span><br><span class="line">  |-- module1.py</span><br></pre></td></tr></table></figure>

我们尝试在 `main.py` 中导入包：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">print(string)</span><br><span class="line"><span class="comment"># &amp;lt;module &amp;#39;string&amp;#39; from &amp;#39;/usr/local/Cellar/python3/3.5.2_3/Frameworks/Python.framework/Versions/3.5/lib/python3.5/string.py&amp;#39;&amp;gt;</span></span><br></pre></td></tr></table></figure>

会发现导入的其实是模块。虽然这里 `string` 目录如果是一个文件，它的查找优先级会高于 Python 中的非内置模块，但如果当做包来导入，Python 就无法识别了。解决方案也很简单，给 `string` 目录添加一个 `__init__.py` 文件，把 `string` 目录标记为包即可。

除了标记目录为包以外，`__init__.py` 文件还可以定义一个 `__all__` 变量，用于批量导入，假设目录层级如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">|-- main.py</span><br><span class="line">|-- string</span><br><span class="line">  |-- module1.py</span><br><span class="line">  |-- module2.py</span><br><span class="line">  |-- module3.py</span><br></pre></td></tr></table></figure>

先在 `__init__` 文件中定义要批量导入的模块：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In __init__.py</span></span><br><span class="line">__all__ = [&amp;<span class="comment">#39;module1&amp;#39;, &amp;#39;module2&amp;#39;]</span></span><br></pre></td></tr></table></figure>

然后在 `main.py` 文件中用星号 `*` 批量导入：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> *</span><br><span class="line">print(module1) <span class="comment"># &amp;lt;module &amp;#39;string.module1&amp;#39; from &amp;#39;/Users/zxy/Desktop/string/module1.py&amp;#39;&amp;gt;</span></span><br><span class="line">print(module2) <span class="comment"># &amp;lt;module &amp;#39;string.module1&amp;#39; from &amp;#39;/Users/zxy/Desktop/string/module1.py&amp;#39;&amp;gt;</span></span><br><span class="line">print(module3) <span class="comment"># NameError: name &amp;#39;module3&amp;#39; is not defined</span></span><br></pre></td></tr></table></figure>

在打印 `module3` 的时候会报错，这是因为 `__all__` 变量没有暴露它，需要我们手动导入。

#### 5.5.4 相对导入和绝对导入

接上面的例子，假设我们在 `module2` 中要引用 `module1`，代码如下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string.module1</span><br></pre></td></tr></table></figure>

这样写没有问题，因为有 `__init__.py` 文件把目录标记为包，所以可以正确识别。然而如果我们的入口不是 `main.py`，而是直接执行 `python3 module2.py`，就无法识别到父目录里面的 `__init__.py` 文件了。此时可以采用相对导入：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> module1</span><br></pre></td></tr></table></figure>

一个点表示当前的包，两个点就表示上一个包，以此类推……；相对导入只能使用 `from import` 的语法，而绝对路径导入则不受限制，两种写法皆可。

相对路径的缺点在于容易丢失命名空间，比较这两种写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line">bar()     <span class="comment"># bar 在哪里定义？</span></span><br><span class="line"><span class="keyword">import</span> foo.bar</span><br><span class="line">foo.bar() <span class="comment"># 在 foo 模块中定义</span></span><br></pre></td></tr></table></figure>

前者丢失了 `bar` 的来源，而后一种写法不会。

#### 5.4.5 运行 Python 脚本

每个 Python 脚本既可以直接用 `python xxx.py` 命令执行，也可以被别的 Python 文件当做模块引入。对于一个项目来说，入口文件只有一个（就像 C 语言的 `main.c` 文件一样），其他的文件都作为模块对外提供功能。

我们也可以用 `python` 命令执行一个文件夹，此时会自动运行文件夹中的 `__main__.py` 文件。 

假设我们写了一个函数，可以爬取给定 URL 的标题：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTitle</span><span class="params">(url)</span>:</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># return html.title</span></span><br><span class="line"></span><br><span class="line">getTitle(&amp;<span class="comment">#39;https://baidu.com&amp;#39;)</span></span><br></pre></td></tr></table></figure>

直接执行或者在别的模块中导入这个文件都会调用 `getTitle` 函数，然而我们希望的效果是只有直接执行这个文件时才执行函数，被导入时只要提供方法即可。或者可以通过判断全局变量 `__name__` 来完成：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTitle</span><span class="params">(url)</span>:</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># return html.title</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__ == &amp;<span class="comment">#39;__main__&amp;#39;:</span></span><br><span class="line">    print(getTitle(&amp;<span class="comment">#39;https://baidu.com&amp;#39;))</span></span><br></pre></td></tr></table></figure>

只有当直接运行文件时，全局变量 `__name__` 的值才是 `__main__`，因此当这个模块被导入时，`if` 语句中的代码就不会被调用。

`python` 作为一个 Shell 命令，可以和其他系统命令通过管道联系在一起，比如实现一个 `show_file.py`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> sys.stdin:</span><br><span class="line">	print(file)</span><br></pre></td></tr></table></figure>

然后执行命令行脚本：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | python3 show_file.py</span><br></pre></td></tr></table></figure>

将会打印出当前目录中所有文件的名字。每个 Shell 脚本都有返回值， 用于表示脚本是否成功，通过命令 `echo $?` 可以查看上一条命令的返回结果，比如：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./create_file.sh</span><br><span class="line"><span class="keyword">if</span> [ $? = 0 ] ; <span class="keyword">then</span>  <span class="comment"># 只有成功创建文件，才会写入内容</span></span><br><span class="line">    ./write_to_file.sh</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> &amp;quot;error&amp;quot;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

由于脚本命令的返回值具有重要的参考价值，因此我们的 Python 脚本也要遵循这一规范，这样别的命令可以很容易的知道 Python 脚本的执行情况。因此，标准的入口文件总是应该套用这个模板：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># 执行某些逻辑</span></span><br><span class="line">	<span class="comment"># 如果发生错误</span></span><br><span class="line">	<span class="comment"># sys.exit(1)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__ == &amp;<span class="comment">#39;__main__&amp;#39;:</span></span><br><span class="line">	sys.exit(main())</span><br></pre></td></tr></table></figure>

### 5.5 venv

#### 5.5.1 什么是 venv

假设我们开发程序 A 是用到了 `pip install module1==1.0`，也就是安装了 `module1` 这个第三方库的 1.0 版本，同时开发程序 B 用到了这个第三方库的 2.0 版本，但是在 `/usr/local/lib/python3.5/site-packages` 这个目录下只能留一份，那么 A 和 B 就无法分别使用两个版本的第三方库了。

于是诞生了虚拟环境（virtualenv，简称 venv）的概念，它会为每个应用单独提供一份 Python 的运行环境，从而起到隔离的效果。

执行以下命令：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenv</span><br><span class="line">virtualenv <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

这首先会安装 `virtualenv` 这个工具模块，然后在当前目录下新建一个虚拟环境 `test`，其实也就是一个目录。

#### 5.5.2 venv 结构初探

观察目录的组成可以发现，主要是有三个文件夹：`bin`、`include` 和 `lib`。

`bin` 目录下主要是一些可执行文件，比如虚拟环境的激活与退出，以及 Python 和 pip 的可执行文件。比如：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> bin/active</span><br><span class="line"><span class="comment"># 现在开始，虚拟环境已经生效，安装的模块都在这个文件夹内部</span></span><br><span class="line">pip instal module1</span><br><span class="line">pip instal module2</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">deactive</span><br></pre></td></tr></table></figure>

`inlcude` 目录下的会通过软连接，导入一些 C 语言的头文件，暂时不清楚作用。

`lib` 目录下引用了 Python 自带的一些模块，以及第三方包 `site-packages` 文件夹的拷贝。如果执行的是 `virtualenv --no-site-packages test` 将会得到一个不含第三方包，纯净的虚拟环境。

#### 5.5.3 工作原理

其实 venv 的工作原理非常简单，完全集中在 `bin/active` 这个简单的脚本中，它的核心部分如下：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">deactive</span></span> () &#123;</span><br><span class="line">    <span class="comment"># 恢复环境</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VIRTUAL_ENV=&amp;quot;/Users/zxy/Desktop/testvenv&amp;quot;</span><br><span class="line"><span class="built_in">export</span> VIRTUAL_ENV</span><br><span class="line"></span><br><span class="line">_OLD_VIRTUAL_PATH=&amp;quot;<span class="variable">$PATH</span>&amp;quot;</span><br><span class="line">PATH=&amp;quot;<span class="variable">$VIRTUAL_ENV</span>/bin:<span class="variable">$PATH</span>&amp;quot;</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>

可见它把当前目录标记为 `VIRTUAL_ENV`，然后添加到系统的 `PATH` 最前面，这样我们执行 `pip` 命令时，第三方的包就会被安装虚拟环境内的 `site-packages` 文件夹中，不会与系统的干扰。

## 6 学习方向

由于作者水平和文章篇幅有限，不可能所有知识点都面面俱到，如果本文激起了你对 Python 的兴趣，我有几个建议或许能帮助你进一步的提高自己的 Python 水平，按照重要级的降序排列：

1. 先确保本文中的所有 Demo 都自己实现过一遍，看代码和写代码是两种截然不同的体验
2. 了解 Python 标准库中提供的函数，避免重复造轮子，更高效的完成需求
3. 尝试用 Tornado、Flask、Django、MITM 等著名的 Python 框架完成一些自己的需求，把 Python 知识与实践结合起来，有机会的话可以阅读这些框架的源码
4. 针对自己还不够了解的知识点，查找 Google 上的优秀博客

## 7 版本历史

#### 1.0.0

首次发布

#### 1.0.1

1. 改正了 1.1.2 节中的错别字，`精度` -&gt; `经度`，`维度` -&gt; `纬度`
2. 改正了 1.1.2 节中 `p.name` 错误的写成了 22 的问题
3. 改正了 1.2.2 节中单词拼写错误， `seddefault` -&gt; `setdefault`
4. 改正了 2.3 节中 `co_argcount` 值错误的问题，经过查阅[官方文档](https://docs.python.org/3/library/inspect.html#types-and-members)，这个值不会统计 `*`、`**` 和仅限关键字参数
5. 改正了 2.2.3 节中的输出结果，`[1, 2, 3]` -&gt; `(1, 2, 3)`
6. 改正了 3.4.1 节中的错别字，`元祖` -&gt; `元组`
7. 改正了 3.1.2 节中的代码错误，`a` -&gt; `b`
8. 改正了 1.2.5 节中的错误，`交集` -&gt; `并集`
9. 改正了 2.4.2 节中的语法错误 `decorate` -&gt; `@decorate`
10. 改正了 5.3.1 节中的代码错误 `r` -&gt; `rb`

## 参考资料：

1. [python属性查找 深入理解（attribute lookup）](http://www.cnblogs.com/xybaby/p/6270551.html)
2. [The Python 2.3 Method Resolution Order](https://www.python.org/download/releases/2.3/mro/)
3. [关于Python的Mixin模式](http://www.bjhee.com/python-mixin.html)
4. [The definitive guide on how to use static, class or abstract methods in Python](https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods)
5. [异步与回调的设计哲学](http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/)
6. [Python的GIL是什么鬼，多线程性能究竟如何](http://cenalulu.github.io/python/gil-in-python/)
7. [6.2 读写JSON数据](http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p02_read-write_json_data.html)
8. [Python 的 import 机制](https://loggerhead.me/posts/python-de-import-ji-zhi.html#_1)" link_users="{}" data-body="Python 是一门非常容易上手的语言，通过查阅资料和教程，也许一晚上就能写出一个简单的爬虫。但 Python 也是一门很难精通的语言，因为简洁的语法背后隐藏了许多黑科技。本文主要针对的读者是：

1. 毫无 Python 经验的小白
2. 有一些简单 Python 经验，但只会复制粘贴代码，不知其所以然的读者
3. 觉得单独一篇文章太琐碎，质量没保证，却没空读完一本书，但又想对 Python 有全面了解的读者

当然， 用一篇文章来讲完某个语言是不可能的事情，我希望读完本文的读者可以：

1. 对 Python 的整体知识结构形成初步的概念
2. 了解 Python 特有的知识点，比如装饰器、上下文、生成器等等，不仅会写 Demo，还对背后的原理有一定了解
3. 避免 C++/Java 等风格的 Python 代码，能够写出地道的 Python 代码
4. 能够熟练的使用 Python 编写脚本实现日常的简单需求，能够维护小型 Python 项目，能够阅读较复杂的 Python 源码

如果以上介绍符合你对自己的定位，在开始阅读前，还需要明确几点：

1. 本文不会只介绍用法，那样太肤浅
2. 本文不会深入介绍某个知识点，比如分析源码等，那样太啰嗦，我希望做一名引路人，描述各个知识点的概貌并略作引申，为读者指出下一步的研究方向
3. 代码注释非常重要，一定要看，几乎所有的代码段都可以执行，**强烈建议**手敲一遍！

[TOC]

## 0. 准备工作

请不要在学习 Python2 还是 Python3 之间犹豫了，除非你很明确自己只接触 Python2，否则就从 Python3 学起，新版本的语言总是意味着进步的生产力（Swift 和 Xcode 除外）。Python 2 和 3 之间语法不兼容，但这并不影响熟悉 Python3 的开发者迅速写出 Python 2 的代码，反之亦然。所以与其在反复纠结中浪费时间，不如立刻行动起来。

推荐使用 **CodeRunner** 来运行本文中的 demo，它比文本编辑器功能更强大，比如支持自动补全和断点调试，又比 PyCharm 轻量得多。

## 1. 数据结构

### 1.1 数组

#### 1.1.1 列表推导

如果要对数组中的所有内容做一些修改，可以用 for 循环或者 map 函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> array: </span><br><span class="line">	<span class="keyword">if</span> n &amp;lt; <span class="number">4</span>:</span><br><span class="line">		small.append(n * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(small)  <span class="comment"># [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

比较地道的 Python 写法是使用列表推导：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">small = [n * <span class="number">2</span> <span class="keyword">for</span> n <span class="keyword">in</span> array <span class="keyword">if</span> n &amp;lt; <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

`for in` 可以写两次，类似于嵌套的 for 循环，会得到一个笛卡尔积：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">signs = [&amp;<span class="comment">#39;+&amp;#39;, &amp;#39;-&amp;#39;]</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">ascii = [&amp;<span class="comment">#39;&#123;sign&#125;&#123;number&#125;&amp;#39;.format(sign=sign, number=number) </span></span><br><span class="line">		<span class="keyword">for</span> sign <span class="keyword">in</span> signs <span class="keyword">for</span> number <span class="keyword">in</span> numbers]</span><br><span class="line"><span class="comment"># 得到：[&amp;#39;+1&amp;#39;, &amp;#39;+2&amp;#39;, &amp;#39;-1&amp;#39;, &amp;#39;-2&amp;#39;]</span></span><br></pre></td></tr></table></figure>

#### 1.1.2 元组

元组可以简单的理解为不可变的数组，也就是没有 `append`、`del` 等方法，一旦创建，就无法新增或删除元素，元素自身的值也不能改变，但元素内部的属性是否可变并不受元组的影响，这一点符合其他语言中的常识。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, [])</span><br><span class="line">t[<span class="number">0</span>] = <span class="number">3</span>  <span class="comment"># 抛出错误 TypeError: &amp;#39;tuple&amp;#39; object does not support item assignment</span></span><br><span class="line">t[<span class="number">1</span>].append(<span class="number">2</span>)  <span class="comment"># 正常运行，现在的 t 是 (1, [2])</span></span><br></pre></td></tr></table></figure>

除了不可变性以外，有时候元组也会被当做不具名的数据结构，这时候元素的位置就不再是可有可无的了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coordinate = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>)</span><br><span class="line"><span class="comment"># coordinate 的第一个位置用来表示经度，第二个位置表示纬度</span></span><br></pre></td></tr></table></figure>

在解析元组数据时，可以一一对应的写上变量名：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, b = t <span class="comment"># a = 1, b = 2</span></span><br></pre></td></tr></table></figure>

有时候变量名比较长， 但我只关心其中某一个，可以这样写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a, _ = t <span class="comment"># a = 1</span></span><br></pre></td></tr></table></figure>

如果元组中元素特别多，即使挨个写下划线也比较累，可以用 \* 来批量解包：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">first, *middle, last = t</span><br><span class="line"><span class="comment"># first = 1</span></span><br><span class="line"><span class="comment"># middle = [2, 3, 4]</span></span><br><span class="line"><span class="comment"># last = 5</span></span><br></pre></td></tr></table></figure>

当然，如果元素数量较多，含义较复杂，我还是建议使用具名元组：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">People = collections.namedtuple(&amp;<span class="comment">#39;People&amp;#39;, [&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;])</span></span><br><span class="line">p = People(&amp;<span class="comment">#39;bestswifter&amp;#39;, &amp;#39;22&amp;#39;)</span></span><br><span class="line">p.name <span class="comment"># bestswifter</span></span><br></pre></td></tr></table></figure>

具名元组更像是一个不能定义方法的简化版的类，能提供友好的数据展示。


元组的一个小技巧是可以避免用临时变量来交换两个数的值：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> </span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a, b = b, a</span><br><span class="line"><span class="comment"># a = 2, b = 1</span></span><br></pre></td></tr></table></figure>

#### 1.1.3 数组切片

切片的基本格式是 `array[start:end:step]`，表示对 array 在 start 到 end 之前以 step 为间隔取切片。注意这里的区间是 [start, end)，也就是左闭右开。比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">s[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 表示取 s 的第 0、2、4 个字符，结果是 &amp;#39;hlo&amp;#39;</span></span><br></pre></td></tr></table></figure>

再举几个例子

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>:<span class="number">5</span>]  <span class="comment"># 不写 step 默认就是 1，因此得到 &amp;#39;hello&amp;#39;</span></span><br><span class="line">s[<span class="number">1</span>:]   <span class="comment"># 不写 end 默认到结尾，因此还是得到 &amp;#39;ello&amp;#39;</span></span><br><span class="line">s[n:]   <span class="comment"># 获取 s 的最后 len(s) - n 个元素</span></span><br><span class="line">s[:<span class="number">2</span>]   <span class="comment"># 不写 start 默认从 0 开始，因此得到 &amp;#39;he&amp;#39;</span></span><br><span class="line">s[:n]   <span class="comment"># 获取 s 的前 n 个元素</span></span><br><span class="line">s[:<span class="number">-1</span>]  <span class="comment"># 负数表示倒过来数，因此这会刨除最后一个字符，得到 &amp;#39;hell&amp;#39;</span></span><br><span class="line">s[<span class="number">-2</span>:]  <span class="comment"># 同上，表示获取最后两个字符，得到 &amp;#39;lo&amp;#39;</span></span><br><span class="line">s[::<span class="number">-1</span>] <span class="comment"># 获取字符串的倒序排列，相当于 reverse 函数</span></span><br></pre></td></tr></table></figure>

 step 和它前面的冒号要么同时写，要么同时不写，但 start 和 end 之间的冒号不能省，否则就不是切片而是获取元素了。再次强调 `array[start:end]` 表示的区间是 [a, b)，也许你会觉得这很难记，但同样的，这会得出以下美妙的公式：

&gt; array[:n] + array[n:] = array (0 &lt;= n &lt;= len(array))

用代码来表示就是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">s[:<span class="number">2</span>] + s[<span class="number">2</span>:] == s  </span><br><span class="line"><span class="comment"># True，因为 s[:2] 是 &amp;#39;he&amp;#39;，s[2:] 是 &amp;#39;llo&amp;#39;</span></span><br></pre></td></tr></table></figure>

切片不仅可以用来获取数组的一部分值，修改切片也可以直接修改数组的对应部分，比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"><span class="comment"># a = [1, 22, 33, 44, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

并没有人规定切片的新值必须和原来的长度一致：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">3</span>]</span><br><span class="line"><span class="comment"># a = [1, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>:<span class="number">4</span>] = []</span><br><span class="line"><span class="comment"># a = [1, 6]，相当于删除了中间的三个数字</span></span><br></pre></td></tr></table></figure>

但切片的新值必须也是可迭代的对象，比如这样写是不合法的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line"><span class="comment"># TypeError: can only assign an iterable</span></span><br></pre></td></tr></table></figure>

#### 1.1.4 循环与遍历

一般来说，在 Python 中我们不会写出 `for (int i = 0; i &lt; len(array); ++i)` 这种风格的代码，而是使用 `for in` 这种语法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

虽然大家都知道 `for in` 语法，但它的某些灵活用法或许就不是那么众所周知了。有时候，我们会在 `if` 语句中对某个变量的值做多次判断，只要满足一个条件即可：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &amp;<span class="comment">#39;bs&amp;#39;</span></span><br><span class="line"><span class="keyword">if</span> name == &amp;<span class="comment">#39;hello&amp;#39; or name == &amp;#39;hi&amp;#39; or name == &amp;#39;bs&amp;#39; or name == &amp;#39;admin&amp;#39;:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Valid&amp;#39;)</span></span><br></pre></td></tr></table></figure>

这种情况推荐用 `in` 来代替：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = &amp;<span class="comment">#39;bs&amp;#39;</span></span><br><span class="line"><span class="keyword">if</span> name <span class="keyword">in</span> (&amp;<span class="comment">#39;hello&amp;#39;, &amp;#39;hi&amp;#39;, &amp;#39;bs&amp;#39;, &amp;#39;admin&amp;#39;):</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Valid&amp;#39;)</span></span><br></pre></td></tr></table></figure>

有时候，如果我们想要把某件事重复固定的次数，用 `for in` 会显得有些啰嗦，这时候可以借助 `range` 类型：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">	print(&amp;<span class="comment">#39;Hi&amp;#39;) # 打印五次 &amp;#39;Hi&amp;#39;</span></span><br></pre></td></tr></table></figure>

`range` 的语法和切片类似，比如我们需要访问数组所有奇数下标的元素，可以这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(a), <span class="number">2</span>):</span><br><span class="line">	print(a[i])</span><br></pre></td></tr></table></figure>

在这种写法中，我们不仅能获得元素，还能知道元素的下标，这与使用 `enumerate(iterable [, start ])` 函数类似：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(a):</span><br><span class="line">	print(i, n)</span><br></pre></td></tr></table></figure>

#### 1.1.5 魔术方法

也许你已经注意到了，数组和字符串都支持切片，而且语法高度统一。这在某些强类型语言（比如我经常接触的 Objective-C 和 Java）中是不可能的，事实上，Python 能够支持这样统一的语法，并非巧合，而是因为所有用中括号进行下标访问的操作，其实都是调用这个类的 `__getitem__` 方法。

比如我们完全可以让自己的类也支持通过下标访问：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.chapters = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.chapters[n]</span><br><span class="line">				</span><br><span class="line">b = Book()</span><br><span class="line">print(b[<span class="number">1</span>]) <span class="comment"># 结果是 2</span></span><br></pre></td></tr></table></figure>

需要注意的是，这段代码几乎不会出问题（除非数组越界），这是因为我们直接把下标传到了内部的 `self.chapters` 数组上。但如果要自己处理下标，需要牢记它不一定是数字，也可以是切片，因此更完整的逻辑应该是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> isinstance(n, int): <span class="comment"># n是索引</span></span><br><span class="line">		<span class="comment"># 处理索引</span></span><br><span class="line">	<span class="keyword">if</span> isinstance(n, slice): <span class="comment"># n是切片</span></span><br><span class="line">		<span class="comment"># 通过 n.start，n.stop 和 n.step 来处理切片</span></span><br></pre></td></tr></table></figure>

与静态语言不同的是，任何实现了 `__getitem__` 都支持通过下标访问，而不用声明为实现了某个协议，这种特性也被称为 “鸭子类型”。鸭子类型并不要求某个类 **是什么**，仅仅要求这个类 **能做什么**。

顺便说一句，实现了 `__getitem__` 方法的类都是可迭代的，比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = Book()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> b:</span><br><span class="line">	print(c)</span><br></pre></td></tr></table></figure>

后续的章节还会介绍更多 Python 中的魔术方法，这种方法的名称前后都有两个下划线，如果读作 “下划线-下划线-getitem” 会比较拗口，因此可以读作 “dunder-getitem” 或者 “双下-getitem”，类似的，我想每个人都能猜到 `__setitem__` 的作用和用法。

### 1.2 字典

#### 1.2.1 初始化字典

最简单的创建一个字典的方式就是直接写字面量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62, &amp;#39;c&amp;#39;: 63, &amp;#39;d&amp;#39;: 64, &amp;#39;e&amp;#39;: 65&#125;</span></span><br></pre></td></tr></table></figure>

字典字面量由大括号包住（注意区别于数组的中括号），键值对之间由逗号分割，每个键值对内部用冒号分割键和值。

如果数组的每个元素都是二元的元组，这个数组可以直接转成字典：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict([(&amp;<span class="comment">#39;a&amp;#39;, 61), (&amp;#39;b&amp;#39;, 62), (&amp;#39;c&amp;#39;, 63), (&amp;#39;d&amp;#39;, 64), (&amp;#39;e&amp;#39;, 65)])</span></span><br></pre></td></tr></table></figure>

就像数组可以推导一样，字典也可以推导：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [(&amp;<span class="comment">#39;a&amp;#39;, 61), (&amp;#39;b&amp;#39;, 62), (&amp;#39;c&amp;#39;, 63), (&amp;#39;d&amp;#39;, 64), (&amp;#39;e&amp;#39;, 65)]</span></span><br><span class="line">d = &#123;letter: number <span class="keyword">for</span> letter, number <span class="keyword">in</span> a&#125; <span class="comment"># 这里用到了元组拆包</span></span><br></pre></td></tr></table></figure>

只要记得外面还是大括号就行了。

两个独立的数组可以被压缩成一个字典：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">65</span>]</span><br><span class="line">letters = [&amp;<span class="comment">#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br><span class="line">dict(zip(letters, numbers))</span><br></pre></td></tr></table></figure>

正如 zip 的意思所表示的，超出长处的那部分数组会被抛弃。

#### 1.2.2 查询字典

最简单方法是直接写键名，但如果键名不存在会抛出 `KeyError`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61&#125;</span></span><br><span class="line">d[&amp;<span class="comment">#39;a&amp;#39;] # 值是 61</span></span><br><span class="line">d[&amp;<span class="comment">#39;b&amp;#39;] # KeyError: &amp;#39;b&amp;#39;</span></span><br></pre></td></tr></table></figure>

可以用 `if key in dict` 的判断来检查键是否存在，甚至可以先 `try` 再 `catch KeyError` ，但更加优雅简洁一些的写法是用 `get(k, default)` 方法来提供默认值：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61&#125;</span></span><br><span class="line">d.get(&amp;<span class="comment">#39;a&amp;#39;, 62) # 得到 61</span></span><br><span class="line">d.get(&amp;<span class="comment">#39;b&amp;#39;, 62) # 得到 62</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">不过有时候，我们可能不仅仅要读出默认属性，更希望能把这个默认属性能写入到字典中，比如：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="comment"># 我们想对字典中某个 Value 做操作，如果 Key 不存在，就先写入一个空值</span></span><br><span class="line"><span class="keyword">if</span> &amp;<span class="comment">#39;list&amp;#39; not in d:</span></span><br><span class="line">	d[&amp;<span class="comment">#39;list&amp;#39;] = []</span></span><br><span class="line">d[&amp;<span class="comment">#39;list&amp;#39;].append(1)</span></span><br></pre></td></tr></table></figure>

这种情况下，`setdefault(key, default)` 函数或许更合适：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.setdefault(&amp;<span class="comment">#39;key&amp;#39;, []).append(1)</span></span><br></pre></td></tr></table></figure>

这个函数虽然名为 `set`，但作用其实是查找，仅仅在查找不到时才会把默认值写入字典。

#### 1.2.3 遍历字典

直接遍历字典实际上是遍历了字典的键，因此也可以通过键获取值：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62, &amp;#39;c&amp;#39;: 63, &amp;#39;d&amp;#39;: 64, &amp;#39;e&amp;#39;: 65&#125;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">	print(i, d[i])</span><br><span class="line"><span class="comment">#b 62</span></span><br><span class="line"><span class="comment">#a 61</span></span><br><span class="line"><span class="comment">#e 65</span></span><br><span class="line"><span class="comment">#d 64</span></span><br><span class="line"><span class="comment">#c 63</span></span><br></pre></td></tr></table></figure>

我们也可以用字典的 `keys()` 或者 `values()` 方法显式的获取键和值。字典还有一个 `items()` 方法，它返回一个数组，每个元素都是由键和值组成的二元元组：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62, &amp;#39;c&amp;#39;: 63, &amp;#39;d&amp;#39;: 64, &amp;#39;e&amp;#39;: 65&#125;</span></span><br><span class="line"><span class="keyword">for</span> (k, v) <span class="keyword">in</span> d.items():</span><br><span class="line">	print(k, v)</span><br><span class="line"><span class="comment">#e 65</span></span><br><span class="line"><span class="comment">#d 64</span></span><br><span class="line"><span class="comment">#a 61</span></span><br><span class="line"><span class="comment">#c 63</span></span><br><span class="line"><span class="comment">#b 62</span></span><br></pre></td></tr></table></figure>

可见 `items()` 方法和字典的构造方法互为逆操作，因为这个公式总是成立的：

&gt; dict(d.items()) == d

#### 1.2.4 字典的魔术方法

在 1.1.4 节中介绍过，通过下标访问最终都会由 `__getitem__` 这个魔术方法处理，因此字典的 `d[key]` 这种写法也不例外， 如果键不存在，则会走到 `__missing__` 方法，再给一次挽救的机会。比如我们可以实现一个字典， 自动忽略键的大小写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> key.islower():</span><br><span class="line">			<span class="keyword">raise</span> KeyError(key)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> self[key.lower()]</span><br><span class="line">			</span><br><span class="line">d = MyDict(&#123;&amp;<span class="comment">#39;a&amp;#39;: 61&#125;)</span></span><br><span class="line">d[&amp;<span class="comment">#39;A&amp;#39;] # 返回 61</span></span><br><span class="line">&amp;<span class="comment">#39;A&amp;#39; in d # False</span></span><br></pre></td></tr></table></figure>

这个字典比较简陋，比如 key 可能不是字符串，不过我没有处理太多情况，因为它主要是用来演示 `__missing__` 的用法，如果想要最后一行的 `in` 语法正确工作，需要重写 `__contains__` 这个魔术方法，过程类似，就不赘述了。

虽然通过自定义的函数也能实现相似的效果，不过这个自定义字典对用户更加透明，如果不在文档中说明，调用方很难察觉到字典的内部逻辑被修改了。 Python 有很多强大的功能，可以具备这种内部进行修改，但是对外保持透明的能力。这可能是我们第一次体会到，后续还会不断的经历。

#### 1.2.5 集合

集合更像是不会有重复元素的数组，但它的本质是以元素的哈希值作为 Key，从而实现去重的逻辑。因此，集合也可以推导，不过得用字典的语法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">d = &#123;i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &amp;lt; <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment"># d = &#123;1, 2, 3, 4&#125;，注意这里的大括号</span></span><br></pre></td></tr></table></figure>

回忆一下，二进制逻辑运算一共有三个运算符，按位或 `|`，按位与 `&amp;` 和异或 `^`，这三个运算符也可以用在集合之间，而且含义变化不大。比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a | b</span><br><span class="line"><span class="comment"># c = &#123;1, 2, 3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

这里的 `|` 运算表示并集，也就是 c 中的任意元素，要么在 a，要么在 b 集合中。类似的，按位与 `&amp;` 运算求的就是交集：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a &amp;amp; b</span><br><span class="line"><span class="comment"># c = &#123;3&#125;</span></span><br></pre></td></tr></table></figure>

而异或则表示那些只在 a 不在 b 或者只在 b 不在 a 的元素。或者换个说法，表示那些在集合 a 和 b 中出现了且仅出现了一次的元素：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a ^ b</span><br><span class="line"><span class="comment"># c = &#123;1, 2, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

还有一个差集运算 `-`，表示在集合 a 中但不在集合 b 中的元素：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">c = a - b</span><br><span class="line"><span class="comment"># c = &#123;1, 2&#125;</span></span><br></pre></td></tr></table></figure>

回忆一下韦恩图，就会得到以下公式（虽然并没有什么卵用）：

&gt; A | B = (A ^ B) | (A &amp; B)
&gt; A ^ B = (A - B) | (B - A)

### 1.3 字符串

#### 1.3.1 字符串编码

用 Python 写过爬虫的人都应该感受过被字符串编码支配的恐惧。简单来说，编码指的是将可读的字符串转换成不太可读的数字，用来存储或者传输。解码则指的是将数字还原成字符串的过程。常见的编码有 ASCII、GBK 等。

ASCII 编码是一个相当小的字符集合，只有一百多个常用的字符，因此只用一个字节（8 位）就能表示，为了存储本国语言，各个国家都开发出了自己的编码，比如中文的 GBK。这就带来了一个问题，如果我想要在一篇文章中同时写中文和日文，就无法实现了，除非能对每个字符指定编码，这个成本高到无法接受。

Unicode 则是一个最全的编码方式，每个 Unicode 字符占据 6 个字节，可以表示出 2 ^ 48 种字符。但随之而来的是 Unicode 编码后的内容不适合存储和发送，因此诞生了基于 Unicode 的再次编码，目的是为了更高效的存储。

更详细的概念分析和配图说明可以参考我的这篇文章：[字符串编码入门科普](http://fullstack.blog/2017/09/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E5%85%A5%E9%97%A8%E7%A7%91%E6%99%AE/)，这里我们主要聊聊 Python 对字符串编码的处理。

首先，编码的函数是 `encode`，它是字符串的方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">s.encode()         <span class="comment"># 得到 b&amp;#39;hello&amp;#39;</span></span><br><span class="line">s.encode(&amp;<span class="comment">#39;utf16&amp;#39;)  # 得到 b&amp;#39;\xff\xfeh\x00e\x00l\x00l\x00o\x00&amp;#39;</span></span><br></pre></td></tr></table></figure>

`encode` 函数有两个参数，第一个参数不写表示使用默认的 `utf8` 编码，理论上会输出二进制格式的编码结果，但在终端打印时，被自动还原回字符串了。如果用 `utf16` 进行编码，则会看到编码以后的二进制结果。

前面说过，编码是字符转到二进制的转化过程，有时候在某个编码规范中，并没有指定某个字符是如何编码的，也就是找不到对应的数字，这时候编码就会报错：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">city = &amp;<span class="comment">#39;São Paulo&amp;#39;</span></span><br><span class="line">b_city = city.encode(&amp;<span class="comment">#39;cp437&amp;#39;)</span></span><br><span class="line"><span class="comment"># UnicodeEncodeError: &amp;#39;charmap&amp;#39; codec can&amp;#39;t encode character &amp;#39;\xe3&amp;#39; in position 1: character maps to &amp;lt;undefined&amp;gt;</span></span><br></pre></td></tr></table></figure>

此时需要用到 `encode` 函数的第二个参数，用来指定遇到错误时的行为。它的值可以是 `&#39;ignore&#39;`，表示忽略这个不能编码的字符，也可以是 `&#39;replace&#39;`，表示用默认字符代替：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b_city = city.encode(&amp;<span class="comment">#39;cp437&amp;#39;, errors=&amp;#39;ignore&amp;#39;) </span></span><br><span class="line"><span class="comment"># b&amp;#39;So Paulo&amp;#39;</span></span><br><span class="line">b_city = city.encode(&amp;<span class="comment">#39;cp437&amp;#39;, errors=&amp;#39;replace&amp;#39;)</span></span><br><span class="line"><span class="comment"># b&amp;#39;S?o Paulo&amp;#39;</span></span><br></pre></td></tr></table></figure>

`decode` 完全是 `encode` 的逆操作，只有二进制类型才有这个函数。它的两个参数含义和 `encode` 函数完全一致，就不再介绍了。

从理论上来说，仅从编码后的内容上来看，是无法确定编码方式的，也无法解码出原来的字符。但不同的编码有各自的特点，虽然无法完全倒推，但可以从概率上来猜测，如果发现某个二进制内容，有 99% 的可能性是 `utf8` 编码生成的，我们就可以用 `utf8` 进行解码。Python 提供了一个强大的工具包 `Chardet`  来完成这一任务：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">octets = b&amp;<span class="comment">#39;Montr\xe9al&amp;#39;</span></span><br><span class="line">chardet.detect(octets)</span><br><span class="line"><span class="comment"># &#123;&amp;#39;encoding&amp;#39;: &amp;#39;ISO-8859-1&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;&#125;</span></span><br><span class="line">octets.decode(&amp;<span class="comment">#39;ISO-8859-1&amp;#39;)</span></span><br><span class="line"><span class="comment"># Montréal</span></span><br></pre></td></tr></table></figure>

返回结果中包含了猜测的编码方式，以及可信度。可信度越高，说明是这种编码方式的可能性越大。

有时候，我们拿到的是二进制的字符串字面量，比如 `68 65 6c 6c 6f`，前文说过只有二进制类型才有 `decode` 函数，所以需要通过二进制的字面量生成二进制变量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;68 65 6c 6c 6f&amp;#39;</span></span><br><span class="line">b = bytearray.fromhex(s)</span><br><span class="line">b.decode()  <span class="comment"># hello</span></span><br></pre></td></tr></table></figure>

#### 1.3.2 字符串的常用方法

字符串的 `split(sep, maxsplit)` 方法可以以指定的分隔符进行分割，有点类似于 Shell 中的 `awk -F &#39; &#39;`&#39;，第一个 `sep` 参数表示分隔符，不填则为空格：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;a b c d e&amp;#39;</span></span><br><span class="line">a = s.split()</span><br><span class="line"><span class="comment"># a = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br></pre></td></tr></table></figure>

第二个参数 `maxsplit` 表示最多分割多少次，因此返回数组的长度是 `maxsplit + 1`。举个例子说明下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;a;b;c;d;e&amp;#39;</span></span><br><span class="line">a = s.split(&amp;<span class="comment">#39;;&amp;#39;)</span></span><br><span class="line"><span class="comment"># a = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br><span class="line"></span><br><span class="line">b = s.split(&amp;<span class="comment">#39;;&amp;#39;, 2)</span></span><br><span class="line"><span class="comment"># b = [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c;d;e&amp;#39;]</span></span><br></pre></td></tr></table></figure>

如果想批量替换，则可以用 `replace(old, new[, count])` 方法，由中括号括起来的参数表示选填。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &amp;<span class="comment">#39;a;b;c;d;e&amp;#39;</span></span><br><span class="line">new = old.replace(&amp;<span class="comment">#39;;&amp;#39;, &amp;#39; &amp;#39;, 3)</span></span><br><span class="line"><span class="comment"># new = &amp;#39;a b c d;e&amp;#39;</span></span><br></pre></td></tr></table></figure>

`strip[chars]` 用于移除指定的字符们：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &amp;quot;*****!!!Hello!!!*****&amp;quot;</span><br><span class="line">new = old.strip(&amp;<span class="comment">#39;*&amp;#39;)  # 得到 &amp;#39;!!!Hello!!!&amp;#39;</span></span><br><span class="line">new = old.strip(&amp;<span class="comment">#39;*！&amp;#39;)  # 得到 &amp;#39;Hello&amp;#39;</span></span><br></pre></td></tr></table></figure>

如果不传参数，则默认移除空格。其实 `strip` 等价于分别执行 `lstrip()` 和 `rstrip()`，即分别从左侧和右侧进行移除。比如 `lstrip()` 表示从左侧第一个字符开始，移除空格，直到第一个非空格字符为止，所以字符串中间的空格，无论是 `lstrip` 还是 `strip()` 都是无法移除的。

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">old = &amp;<span class="comment">#39;  Hello world  &amp;#39;</span></span><br><span class="line">new = old.strip()   <span class="comment"># 得到 &amp;#39;Hello wrold&amp;#39;</span></span><br><span class="line">new = old.lstrip()  <span class="comment"># 得到 &amp;#39;Hello world  &amp;#39;</span></span><br></pre></td></tr></table></figure>

最后一个常用方法是 `join`，其实这个可以理解为字符串的构造方法，它可以把数组转换成字符串：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = &amp;<span class="comment">#39;a b c d e&amp;#39;.split() # 之前说过，结果是 [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;e&amp;#39;]</span></span><br><span class="line">s = &amp;<span class="comment">#39;;&amp;#39;.join(array) # 以分号为连接符，把数组中的元素连接起来</span></span><br><span class="line"><span class="comment"># s = &amp;#39;a;b;c;d;e&amp;#39;</span></span><br></pre></td></tr></table></figure>

所以 `join` 可以理解为 `split` 的逆操作，这个公式始终是成立的：

&gt; c.join(string.split(c)) = string

上面这些字符串处理的函数，大多返回的还是字符串，因此可以链式调用，避免使用临时变量和多行代码，但也要避免过长（超过 3 个）的链式调用，以免影响可读性。

#### 1.3.3 字符串格式化

最初级的字符串格式化方法是使用 `+` 来拼接：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">		self.age = <span class="number">22</span></span><br><span class="line">		self.sex = &amp;<span class="comment">#39;m&amp;#39;</span></span><br><span class="line">		</span><br><span class="line">p = Person()</span><br><span class="line">print(&amp;<span class="comment">#39;Name: &amp;#39; + p.name + &amp;#39;, Age: &amp;#39; + str(p.age) + &amp;#39;, Sex: &amp;#39; + p.sex)</span></span><br><span class="line"><span class="comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span></span><br></pre></td></tr></table></figure>

这里必须要把 `int` 类型的年龄转成字符串以后才能进行拼接，这是因为 Python 是强类型语言，不支持类型的隐式转换。

这种做法的缺点在于如果输出结构比较复杂，极容易出现引号匹配错误的问题，可读性非常低。

Python 2 中的做法是使用占位符，类似于 C 语言中 `printf`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content = &amp;<span class="comment">#39;Name: %s, Age: %i, Sex: %c&amp;#39; % (p.name, p.age, p.sex)</span></span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure>

从结构上看，要比上一种写法清楚得多， 但每个变量都需要指定类型，这和 Python 的简洁不符。实际上每个对象都可以通过 `str()` 函数转换成字符串，这个函数的背后是 `__str__` 魔术方法。

Python 3 中的写法是使用 `format` 函数，比如我们来实现一下 `__str__` 方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">		self.age = <span class="number">22</span></span><br><span class="line">		self.sex = &amp;<span class="comment">#39;m&amp;#39;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="comment">#39;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&amp;#39;.format(user=self)</span></span><br><span class="line">			</span><br><span class="line">p = Person()</span><br><span class="line">print(p)</span><br><span class="line"><span class="comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span></span><br></pre></td></tr></table></figure>

除了把对象传给 `format` 函数并在字符串中展开以外， 也可以传入多个参数，并且通过下标访问他们：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(&amp;<span class="comment">#39;&#123;0&#125;, &#123;1&#125;, &#123;0&#125;&amp;#39;.format(1, 2))</span></span><br><span class="line"><span class="comment"># 输出：1, 2, 1，这里的 &#123;1&#125; 表示第二个参数</span></span><br></pre></td></tr></table></figure>

#### 1.3.4 HereDoc

Heredoc 不是 Python 特有的概念， 命令行和各种脚本中都会见到，它表示一种所见即所得的文本。

假设我们在写一个 HTML 的模板，绝大多数字符串都是常量，只有有限的几个地方会用变量去替换，那这个字符串该如何表示呢？一种写法是直接用单引号去定义：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;\nFriends CGI Demo&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;\n&amp;lt;BODY&amp;gt;&amp;lt;H3&amp;gt;ERROR&amp;lt;/H3&amp;gt;\n&amp;lt;B&amp;gt;%s&amp;lt;/B&amp;gt;&amp;lt;P&amp;gt;\n&amp;lt;FORM&amp;gt;&amp;lt;INPUT TYPE=button VALUE=Back\nONCLICK=\&amp;#39;window.history.back()\&amp;#39;&amp;gt;&amp;lt;/FORM&amp;gt;\n&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;&amp;#39;</span></span><br></pre></td></tr></table></figure>

这段代码是自动生成的还好，如果是手动维护的，那么可读性就非常差，因为换行符和转义后的引号增加了理解的难度。如果用 heredoc 来写，就非常简单了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;&amp;#39;&amp;#39;&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;</span></span><br><span class="line">Friends CGI Demo&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;</span><br><span class="line">&amp;lt;BODY&amp;gt;&amp;lt;H3&amp;gt;ERROR&amp;lt;/H3&amp;gt;</span><br><span class="line">&amp;lt;B&amp;gt;%s&amp;lt;/B&amp;gt;&amp;lt;P&amp;gt;</span><br><span class="line">&amp;lt;FORM&amp;gt;&amp;lt;INPUT TYPE=button VALUE=Back</span><br><span class="line">ONCLICK=&amp;<span class="comment">#39;window.history.back()&amp;#39;&amp;gt;&amp;lt;/FORM&amp;gt;</span></span><br><span class="line">&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;</span><br><span class="line">&amp;<span class="comment">#39;&amp;#39;&amp;#39;</span></span><br></pre></td></tr></table></figure>

Heredoc 主要是用来书写大段的字符串常量，比如 HTML 模板，SQL语句等等。

## 2 函数

### 2.1 函数是一等公民

一等公民指的是 Python 的函数能够动态创建，能赋值给别的变量，能作为参传给函数，也能作为函数的返回值。总而言之，函数和普通变量并没有什么区别。

函数是一等公民，这是函数式编程的基础，然而 Python 中基本上不会使用 lambda 表达式，因为在 lambda 表达式的中仅能使用单纯的表达式，不能赋值，不能使用 while、try 等语句，因此 lambda 表达式要么难以阅读，要么根本无法写出。这极大的限制了 lambda 表达式的使用场景。

上文说过，函数和普通变量没什么区别，但普通变量并不是函数，因为这些变量无法调用。但如果某个类实现了 `__call__` 这个魔术方法，这个类的实例就都可以像函数一样被调用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">		self.age = <span class="number">22</span></span><br><span class="line">		self.sex = &amp;<span class="comment">#39;m&amp;#39;</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(self)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="comment">#39;Name: &#123;user.name&#125;, Age: &#123;user.age&#125;, Sex: &#123;user.sex&#125;&amp;#39;.format(user=self)</span></span><br><span class="line">			</span><br><span class="line">p = Person()</span><br><span class="line">p() <span class="comment"># 等价于 print(p)</span></span><br></pre></td></tr></table></figure>

### 2.2 函数参数

#### 2.2.1 函数传参

对于熟悉 C 系列语言的人来说，函数传参的方式一目了然。默认是拷贝传值，如果传指针是引用传值。我们先来看一段简单的 Python 代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg = <span class="number">5</span></span><br><span class="line">	print(arg)</span><br><span class="line">	</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">foo(a)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 输出 5 和 1</span></span><br></pre></td></tr></table></figure>

这段代码的结果符合我们的预期，从这段代码来看，Python 也属于拷贝传值。但如果再看这段代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(arg)</span>:</span></span><br><span class="line">	arg.append(<span class="number">1</span>)</span><br><span class="line">	print(arg)</span><br><span class="line">	</span><br><span class="line">a = [<span class="number">1</span>]</span><br><span class="line">foo(a)</span><br><span class="line">print(a) <span class="comment"># 输出两个 [1, 1]</span></span><br></pre></td></tr></table></figure>

你会发现参数数组在函数内部被改变了。就像是 C 语言中传递了变量的指针一样。所以 Python 到底是拷贝传值还是引用传值呢？答案**都是否定的**！

Python 的传值方式可以被理解为混合传值。对于那些不可变的对象（比如 1.1.2 节中介绍过的元组，还有数字、字符串类型），传值方式是拷贝传值；对于那些可变对象（比如数组和字典）则是引用传值。

#### 2.2.2 默认参数

Python 的函数可以有默认值，这个功能很好用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, l=[])</span>:</span></span><br><span class="line">	l.append(a)</span><br><span class="line">	<span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>,[<span class="number">1</span>])  <span class="comment"># 给数组 [1] 添加一个元素 2，得到 [1,2]</span></span><br><span class="line">foo(<span class="number">2</span>)      <span class="comment"># 没有传入数组，使用默认的空数组，得到 [2]</span></span><br></pre></td></tr></table></figure>

然而如果这样调用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">2</span>)  <span class="comment"># 利用默认参数，得到 [2]</span></span><br><span class="line">foo(<span class="number">3</span>)  <span class="comment"># 竟然得到了 [2, 3]</span></span><br></pre></td></tr></table></figure>

函数调用了两次以后，默认参数被改变了，也就是说函数调用产生了副作用。这是因为默认参数的存储并不像函数里的临时变量一样存储在栈上、随着函数调用结束而释放，而是存储在函数这个对象的内部：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.__defaults__  <span class="comment"># 一开始确实是空数组</span></span><br><span class="line">foo(<span class="number">2</span>)  <span class="comment"># 利用默认参数，得到 [2]</span></span><br><span class="line">foo.__defaults__  <span class="comment"># 如果打印出来看，已经变成 [2] 了</span></span><br><span class="line">foo(<span class="number">3</span>)  <span class="comment"># 再添加一个元素就得到了 [2, 3]</span></span><br></pre></td></tr></table></figure>

因为函数 `foo` 作为一个对象，不会被释放，因此这个对象内部的属性也不会随着多次调用而自动重置，会一直保持上次发生的变化。基于这个前提，我们得出一个结论：**函数的默认参数不允许是可变对象**，比如这里的 `foo` 函数需要这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, l=None)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> l <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">		l = []</span><br><span class="line">	l.append(a)</span><br><span class="line">	<span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line">print(foo(<span class="number">2</span>)) <span class="comment"># 得到 [2]</span></span><br><span class="line">print(foo(<span class="number">3</span>)) <span class="comment"># 得到 [3]</span></span><br></pre></td></tr></table></figure>

现在，给参数添加默认值的行为在函数体中完成，不会随着函数的多次调用而累积。

对于 Python 的默认参数来说：

&gt; 如果默认值是不可变的，可以直接设置默认值，否则要设置为 None 并在函数体中设置默认值。

#### 2.2.3 多参数传递

当参数个数不确定时，可以在参数名前加一个 `*`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args)</span>:</span></span><br><span class="line">	print(args)</span><br><span class="line">	</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

如果直接把数组作为参数传入，它其实是单个参数，如果要把数组中所有元素都作为单独的参数传入，则在数组前面加上 `*`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]	</span><br><span class="line">foo(a)  <span class="comment"># 会输出 ([1,2,3], )   因为只传了一个数组作为参数</span></span><br><span class="line">foo(*a) <span class="comment"># 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

这里的单个 `*` 只能接收非关键字参数，也就是仅有参数值的哪些参数。如果想接受关键字参数，需要用 `**` 来表示：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">	print(args)</span><br><span class="line">	print(kwargs)</span><br><span class="line">	</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, a=<span class="number">61</span>, b=<span class="number">62</span>)</span><br><span class="line"><span class="comment"># 第一行输出：(1, 2, 3)</span></span><br><span class="line"><span class="comment"># 第二行输出：&#123;&amp;#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62&#125;</span></span><br></pre></td></tr></table></figure>

类似的，字典变量传入函数只能作为单个参数，如果要想展开并被 `**kwargs` 识别，需要在字典前面加上两个星号 `**`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">d = &#123;&amp;<span class="comment">#39;a&amp;#39;: 61, &amp;#39;b&amp;#39;: 62&#125;</span></span><br><span class="line">foo(*a, **d)</span><br></pre></td></tr></table></figure>

#### 2.2.4 参数分类

Python 中函数的参数可以分为两大类：

1. 定位参数（Positional）：表示参数的位置是固定的。比如对于函数 `foo(a, b)` 来说，`foo(1, 2)` 和 `foo(2, 1)` 就是截然不同的，a 和 b 的位置是固定的，不可随意调换。
2. 关键词参数（Keyword）：表示参数的位置不重要，但是参数名称很重要。比如 `foo(a = 1, b = 2)` 和 `foo(b = 2, a = 1)` 的含义相同。

有一种参数叫做仅限关键字（Keyword-Only）参数，比如考虑这个函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(*args, n=<span class="number">1</span>, **kwargs)</span>:</span></span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>

这个函数在调用时，如果参数 n 不指定名字，就会被前面的 `*args` 处理掉，如果指定的名字不是 n，又会被后面的 `**kwargs` 处理掉，所以参数 n 必须精确的以 `(n = xxx)` 的形式出现，也就是 Keyworld-Only。

### 2.3 函数内省

在 2.2.2 节中，我们查看了函数变量的 `__defaults__` 属性，其实这就是一种内省，也就是在运行时动态的查看变量的信息。

前文说过，函数也是对象，因此函数的变量个数，变量类型都应该有办法获取到，如果你需要开发一个框架，也许会对函数有各种奇葩的检查和校验。 

以下面这个函数为例：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(m, *args, n, **kwargs)</span>:</span></span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br></pre></td></tr></table></figure>

首先可以获取函数名，函数所在模块的全局变量等：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__globals__   <span class="comment"># 全局变量，包含了 g = 1</span></span><br><span class="line">foo.__name__      <span class="comment"># foo</span></span><br></pre></td></tr></table></figure>

我们还可以看到函数的参数，函数内部的局部变量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.__code__.co_varnames  <span class="comment"># (&amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;args&amp;#39;, &amp;#39;kwargs&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;)</span></span><br><span class="line">foo.__code__.co_argcount  <span class="comment"># 只计算参数个数，不考虑可变参数和仅限关键字参数，所以得到 1</span></span><br></pre></td></tr></table></figure>

或者用 `inspect` 模块来查看更详细的信息：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">sig = inspect.signature(foo)  <span class="comment"># 获取函数签名</span></span><br><span class="line"></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;m&amp;#39;].kind      # POSITIONAL_OR_KEYWORD 表示可以是定位参数或关键字参数</span></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;args&amp;#39;].kind   # VAR_POSITIONAL 定位参数构成的数组</span></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;n&amp;#39;].kind      # KEYWORD_ONLY 仅限关键字参数</span></span><br><span class="line">sig.parameters[&amp;<span class="comment">#39;kwargs&amp;#39;].kind # VAR_KEYWORD 关键字参数构成的字典</span></span><br><span class="line">inspect.getfullargspec(foo)       </span><br><span class="line"><span class="comment"># 得到：ArgSpec(args=[&amp;#39;m&amp;#39;, &amp;#39;n&amp;#39;], varargs=&amp;#39;args&amp;#39;, keywords=&amp;#39;kwargs&amp;#39;, defaults=None)</span></span><br></pre></td></tr></table></figure>

本节的新 API 比较多，但并不要求记住这些 API 的用法。再次强调，本文的写作目的是为了建立读者对 Python 的总体认知，了解 Python **能做什么**，至于怎么做，那是文档该做的事。

### 2.4 装饰器

#### 2.4.1 设计模式的消亡

经典的设计模式有 23 个，虽然设计模式都是常用代码的总结，理论上来说与语法无关。但不得不承认的是，标准的设计模式在不同的语言中，有的因为语法的限制根本无法轻易实现（比如在 C 语言中实现组合模式），有的则因为语言的特定功能，变得冗余啰嗦。

以策略模式为例，有一个抽象的策略类，定义了策略的接口，然后使用者选择一个具体的策略类，构造他们的实例并且调用策略方法。具体代码可以参考：[策略模式在百度百科的定义](https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/646307?fr=aladdin)。

然而这些对象本身并没有作用，它们仅仅是可以调用相同的方法而已，只不过在 Java 中，所有的任务都需要由对象来完成。即使策略本身就是一个函数，但也必须把它包裹在一个策略对象中。所以在 Python 中更优雅写法是直接把策略函数作为变量使用。不过这就引入一个问题，如何判断某个函数是个策略呢，毕竟在面向对象的写法中，只要检查它的父类是否是抽象的策略类即可。

也许你已经见过类似的写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@strategy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strategyA</span><span class="params">(n)</span>:</span></span><br><span class="line">	print(n * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

下面就开始介绍装饰器。

#### 2.4.2 装饰器的基本原理

首先，装饰器是个函数，它的参数是被装饰的函数，返回值也是一个函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(origin_func)</span>:</span>  <span class="comment"># 这个参数是被装饰的函数</span></span><br><span class="line">	print(<span class="number">1</span>)  <span class="comment"># 先输出点东西</span></span><br><span class="line">	<span class="keyword">return</span> origin_func  <span class="comment"># 把原函数直接返回</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@decorate    # 注意这里不是函数调用，所以不用加括号，也不用加被修饰的函数名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">sayHello()  <span class="comment"># 如果没有装饰器，只会打印 &amp;#39;Hello&amp;#39;，实际结果是打印 1 再打印 &amp;#39;Hello&amp;#39;</span></span><br></pre></td></tr></table></figure>

因此，使用装饰器的这种写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

和下面这种写法是完全等价的， 初学者可以把装饰器在心中默默的转换成下一种写法，以方便理解：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">foo = decorate(foo)</span><br></pre></td></tr></table></figure>

需要注意的是，装饰器函数 `decorate` 在模块被导入时就会执行，而被装饰的函数只在被调用时才会执行，也就是说即使不调用 `sayHello` 函数也会输出 1，但这样就不会输出 Hello 了。

有了装饰器，配合前面介绍的函数对象，函数内省，我们可以做很多有意思的事，至少判断上一节中某个函数是否是策略是非常容易的。在装饰器中，我们还可以把策略函数都保存到数组中， 然后提供一个“推荐最佳策略”的功能， 其实就是遍历执行所有的策略，然后选择最好的结果。

#### 2.4.3 装饰器进阶

上一节中的装饰器主要是为了介绍工作原理，它的功能非常简单，并不会改变被装饰函数的运行结果，仅仅是在导入时装饰函数，然后输出一些内容。换句话说，即使不执行函数，也要执行装饰器中的 `print` 语句，而且因为直接返回函数的缘故，其实没有真正的起到装饰的效果。

如何做到装饰时不输出任何内容，仅在函数执行最初输出一些东西呢？这是常见的 AOP（面向切片编程） 的需求。这就要求我们不能再直接返回被装饰的函数，而是应该返回一个新的函数，所以新的装饰器需要这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(origin_func)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">()</span>:</span></span><br><span class="line">		print(<span class="number">1</span>)</span><br><span class="line">		origin_func()</span><br><span class="line">	<span class="keyword">return</span> new_func</span><br><span class="line"></span><br><span class="line">decorate</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">sayHello() <span class="comment"># 运行结果不变，但是仅在调用函数 sayHello 时才会输出 1</span></span><br></pre></td></tr></table></figure>

这个例子的工作原理是，`sayHello` 函数作为参数 `origin_func` 被传到装饰器中，经过装饰以后，它实际上变成了 `new_func`，会先输出 1 再执行原来的函数，也就是 `sayHello`。

这个例子很简陋，因为我们知道了 `sayHello` 函数没有参数，所以才能定义一个同样没有参数的替代者：`nwe_func`。如果我们在开发一个框架，要求装饰器能对任意函数生效，就需要用到 2.2.3 中介绍的 `*` 和 `**` 这种不定参数语法了。

如果查看 `sayHello` 函数的名字，得到的结果将是 `new_func`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello.__name__  <span class="comment"># new_func</span></span><br></pre></td></tr></table></figure>

这是很自然的，因为本质上其实执行的是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_func = decorate(sayHello)</span><br></pre></td></tr></table></figure>

而装饰器的返回结果是另一个函数 `new_func`，两者仅仅是运行结果类似，但两个对象并没有什么关联。

所以为了处理不定参数，并且不改变被装饰函数的外观（比如函数名），我们需要做一些细微的修补工作。这些工作都是模板代码，所以 Python 早就提供了封装：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(origin_func)</span>:</span></span><br><span class="line"><span class="meta">	@functools.wraps(origin_func)  # 这是 Python 内置的装饰器</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">		print(<span class="number">1</span>)</span><br><span class="line">		origin_func(*args, **kwargs)</span><br><span class="line">	<span class="keyword">return</span> new_func</span><br></pre></td></tr></table></figure>

#### 2.4.4 装饰器工厂

在 2.4.2 节的代码注释中我解释过，装饰器后面不要加括号，被装饰的函数自动作为参数，传递到装饰器函数中。如果加了括号和参数，就变成手动调用装饰器函数了，大多数时候这与预期不符（因为装饰器的参数一般都是被装饰的函数）。

不过装饰器可以接受自定义的参数，然后返回另一个装饰器，这样外面的装饰器实际上就是一个装饰器工厂，可以根据用户的参数，生成不同的装饰器。还是以上面的装饰器为例，我希望输出的内容不是固定的 1，而是用户可以指定的，代码就应该这么写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(content)</span>:</span>  				      <span class="comment"># 这其实是一个装饰器工厂</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">real_decorator</span><span class="params">(origin_func)</span>:</span>          <span class="comment"># 这才是刚刚的装饰器</span></span><br><span class="line"><span class="meta">		@functools.wraps(origin_func)</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">new_func</span><span class="params">()</span>:</span></span><br><span class="line">			print(&amp;<span class="comment">#39;You said &amp;#39; + str(content)) # 现在输出内容可以由用户指定</span></span><br><span class="line">			origin_func()</span><br><span class="line">		<span class="keyword">return</span> new_func                       <span class="comment"># 在装饰器里，返回的是新的函数</span></span><br><span class="line">	<span class="keyword">return</span> real_decorator                     <span class="comment"># 装饰器工厂返回的是装饰器</span></span><br></pre></td></tr></table></figure>

装饰器工厂和装饰器的区别在于它可以接受参数，返回一个装饰器：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate(2017)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">sayHello()</span><br></pre></td></tr></table></figure>

其实等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real_decorator = decorate(<span class="number">2017</span>)      <span class="comment"># 通过装饰器工厂生成装饰器</span></span><br><span class="line">new_func = real_decorator(sayHello)  <span class="comment"># 正常的装饰器工作逻辑</span></span><br><span class="line">new_func()                           <span class="comment"># 调用的是装饰过的函数</span></span><br></pre></td></tr></table></figure>

## 3 面向对象

### 3.1 对象内存管理

#### 3.1.1 对象不是盒子

C 语言中我们定义变量用到的语法是：

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

这背后的含义是定义了一个 `int` 类型的变量 `a`，相当于申请了一个名为 `a` 的盒子（存储空间），里面装了数字 1。
![](https://diycode.b0.upaiyun.com/photo/2018/d488dd71e0be57efe82f076c550e6a22.png)


然后我们改变 `a` 的值：`a = 2;`，可以打印 `a` 的地址来证明它并没有发生变化。所以只是盒子里装的内容（指针指向的位置）发生了改变：
![](https://diycode.b0.upaiyun.com/photo/2018/63785ebe7adfb514dcc88d4b96a34cad.png)

但是在 Python 中，变量不是盒子。比如同样的定义变量：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br></pre></td></tr></table></figure>

这里就不能把 `a` 理解为 `int` 类型的变量了。因为在 Python 中，变量没有类型，值才有，或者说只有对象才有类型。因为即使是数字 1，也是 `int` 类的实例，而变量 `a` 更像是给这个对象贴的一个标签。


![](https://diycode.b0.upaiyun.com/photo/2018/6d30c0da2d2108ccc071c8751c4e7c1a.png)
如果执行赋值语句 `a = 2`，相当于把标签 a 贴在另一个对象上：
![](https://diycode.b0.upaiyun.com/photo/2018/05a4f3b25b942f0656f1759eb5b6dbc6.png)


基于这个认知，我们现在应该更容易理解 2.2.1 节中所说的函数传参规则了。如果传入的是不可变类型，比如 `int`，改变它的值实际上就是把标签挂在新的对象上，自然不会改变原来的参数。如果是可变类型，并且做了修改，那么函数中的变量和外面的变量都是指向同一个对象的标签，所以会共享变化。

#### 3.1.2 默认浅复制

根据上一节的描述，直接把变量赋值给另一个变量， 还算不上复制：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b == a   <span class="comment"># True，等同性校验，会调用 __eq__ 函数，这里只判断内容是否相等</span></span><br><span class="line">b <span class="keyword">is</span> a   <span class="comment"># True，一致性校验，会检查是否是同一个对象，调用 hash() 函数，可以理解为比较指针</span></span><br></pre></td></tr></table></figure>

可见不仅仅数组相同，就连变量也是相同的，可以把 b 理解为 a 的别名。

如果用切片，或者数组的构造函数来创建新的数组，得到的是原数组的浅拷贝：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = list(a)</span><br><span class="line">b == a   <span class="comment"># True，因为数组内容相同</span></span><br><span class="line">b <span class="keyword">is</span> a   <span class="comment"># False，现在 a 和 b 是两个变量，恰好指向同一个数组对象</span></span><br></pre></td></tr></table></figure>

但如果数组中的元素是可变的，可以看到这些元素并没有被完全拷贝：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</span><br><span class="line">b = list(a)</span><br><span class="line">b[<span class="number">0</span>].append(<span class="number">2</span>)</span><br><span class="line">a <span class="comment"># 得到 [[1, 2], [2], [3]]，因为 a[0] 和 b[0] 其实还是挂在相同对象上的不同标签</span></span><br></pre></td></tr></table></figure>

如果想要深拷贝，需要使用 `copy` 模块的 `deepcopy` 函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy </span><br><span class="line"></span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">b[<span class="number">0</span>].append(<span class="number">2</span>)</span><br><span class="line">b  <span class="comment"># 变成了 [[1, 2], [2], [3]]</span></span><br><span class="line">a  <span class="comment"># 还是 [[1], [2], [3]]</span></span><br></pre></td></tr></table></figure>

此时，不仅仅是每个元素的引用被拷贝，就连每个元素自己也被拷贝。所以现在的 `a[0]` 和 `b[0]` 是指向两个不同对象的两个不同变量（标签），自然就互不干扰了。

如果要实现自定义对象的深复制，只要实现 `__deepcopy__` 函数即可。这个概念在几乎所有面向对象的语言中都会存在，就不详细介绍了。

#### 3.1.3 弱引用

Python 内存管理使用垃圾回收的方式，当没有指向对象的引用时，对象就会被回收。然而对象一直被持有也并非什么好事，比如我们要实现一个缓存，预期目标是缓存中的内容随着真正对象的存在而存在，随着真正对象的消失而消失。如果因为缓存的存在，导致被缓存的对象无法释放，就会导致内存泄漏。

Python 提供了语言级别的支持，我们可以使用 `weakref` 模块，它提供了 `weakref.WeakValueDictionary` 这个弱引用字典来确保字典中的值不会被引用。如果想要获取某个对象的弱引用，可以使用 `weakref.ref(obj)`  函数。

### 3.2 Python 风格的对象

#### 3.2.1 静态函数与类方法

静态函数其实和类的方法没什么关系，它只是恰好定义在类的内部而已，所以这里我用函数（function) 来形容它。它可以没有参数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod   # 用 staticmethod 这个修饰器来表明函数是静态的</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">()</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;Hello&amp;#39;)</span></span><br><span class="line">	</span><br><span class="line">Person.sayHello() <span class="comment"># 输出 &amp;#39;Hello`</span></span><br></pre></td></tr></table></figure>

静态函数的调用方式是类名加上函数名。类方法的调用方式也是这样，唯一的不同是需要用 `@staticmethod` 修饰器，而且方法的第一个参数必须是类：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">	@classmethod    # 用 classmethod 这个修饰器来表明这是一个类方法</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sayHi</span><span class="params">(cls)</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;Hi: &amp;#39; + cls.__name__)</span></span><br><span class="line">	</span><br><span class="line">Person.sayHi() <span class="comment"># 输出 &amp;#39;Hi: Person`</span></span><br></pre></td></tr></table></figure>

类方法和静态函数的调用方法一致，在定义时除了修饰器不一样，唯一的区别就是类方法需要多声明一个参数。这样看起来比较麻烦，但静态函数无法引用到类对象，自然就无法访问类的任何属性。

于是问题来了，静态函数有何意义呢？有的人说类名可以提供命名空间的概念，但在我看来这种解释并不成立，因为每个 Python 文件都可以作为模块被别的模块引用，把静态函数从类里抽取出来，定义成全局函数，也是有命名空间的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 module1.py 文件中：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">global</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 module2.py 文件中：</span></span><br><span class="line"><span class="keyword">import</span> module1</span><br><span class="line">module1.<span class="keyword">global</span>()        <span class="comment"># 调用全局函数</span></span><br><span class="line">module1.Util.helper()   <span class="comment"># 调用静态函数</span></span><br></pre></td></tr></table></figure>

从这个角度看，定义在类中的静态函数不仅不具备命名空间的优点，甚至调用语法还更加啰嗦。对此，我的理解是：**静态函数可以被继承、重写，但全局函数不行**，由于 Python 中的函数是一等公民，因此很多时候用函数替代类都会使代码更加简洁，但缺点就是无法继承，后面还会有更多这样的例子。

#### 3.2.2 属性 attribute

Python （等多数动态语言）中的类并不像 C/OC/Java 这些静态语言一样，需要预先定义属性。我们可以直接在初始化函数中创建属性：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.name  <span class="comment"># 值是 &amp;#39;bestswifter&amp;#39;</span></span><br></pre></td></tr></table></figure>

由于 `__init__` 函数是运行时调用的，所以我们可以直接给对象添加属性：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bs.age = <span class="number">22</span></span><br><span class="line">bs.age  <span class="comment"># 因为刚刚赋值了，所以现在取到的值是 22</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">如果访问一个不存在的属性，将会抛出异常。从以上特性来看，对象其实和字典非常相似，但这种过于灵活的特性其实蕴含了潜在的风险。比如某个封装好的父类中定义了许多属性， 但是子类的使用者并不一定清楚这一点，他们很可能会不小心就重写了父类的属性。一种隐藏并保护属性的方式是在属性前面加上两个下划线：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.__name = &amp;<span class="comment">#39;bestswifter&amp;#39;</span></span><br><span class="line">	</span><br><span class="line">bs = Person()</span><br><span class="line"></span><br><span class="line">bs.__name          <span class="comment"># 这样是无法获取属性的</span></span><br><span class="line">bs._Person__name   <span class="comment"># 这样还是可以读取属性</span></span><br></pre></td></tr></table></figure>

这是因为 Python 会自动处理以双下划线开头的属性，把他们重名为 `_Classname__attrname` 的格式。由于 Python 对象的所有属性都保存在实例的 `__dict__`  属性中，我们可以验证一下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bs = Person()</span><br><span class="line">bs.__dict__ </span><br><span class="line"><span class="comment"># 得到 &#123;&amp;#39;_Person__name&amp;#39;: &amp;#39;bestswifter&amp;#39;&#125;</span></span><br></pre></td></tr></table></figure>

但很多人并不认可通过名称改写（name mangling) 的方式来存储私有属性，原因很简单，只要知道改写规则，依然**很容易的**就能读写私有属性。与其自欺欺人，不如采用更简单，更通用的方法，比如给私有属性前面加上单个下划线 `_`。

注意，以单个下划线开头的属性不会触发任何操作，完全靠自觉与共识。**任何稍有追求的 Python 程序员，都不应该读写这些属性。**

#### 3.2.3 特性 property

使用过别的面向对象语言的读者应该都清楚属性的 `getter` 和 `setter` 函数的重要性。它们封装了属性的读写操作，可以添加一些额外的逻辑，比如校验新值，返回属性前做一些修饰等等。最简陋的 `getter` 和 `setter` 就是两个普通函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self.name.upper()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> isinstance(new_name, str):</span><br><span class="line">			self.name = new_name.lower()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.get_name()   <span class="comment"># 得到大写的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br><span class="line">bs.set_name(<span class="number">1</span>)  <span class="comment"># 由于新的名字不是字符串，所以无法赋值</span></span><br><span class="line">bs.get_name()   <span class="comment"># 还是老的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br></pre></td></tr></table></figure>

工作虽然完成了，但方法并不高明。在 1.2.3 节中我们就见识到了 Python 的一个特点：“内部高度封装，完全对外透明”。这里手动调用 `getter` 和 `setter` 方法显得有些愚蠢、啰嗦，比如对比下面的两种写法，在变量名和函数名很长的情况下，差距会更大：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bs.name += &amp;<span class="comment">#39;1995&amp;#39;</span></span><br><span class="line">bs.set_name(bs.get_name() + &amp;<span class="comment">#39;1995&amp;#39;)</span></span><br></pre></td></tr></table></figure>

Python 提供了 `@property` 关键字来装饰 `getter` 和 `setter` 方法，这样的好处是可以直接使用点语法，了解 Objective-C 的读者对这一特性一定倍感亲切：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line"><span class="meta">	@property                        # 定义 getter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span>                  <span class="comment"># 函数名就是点语法访问的属性名</span></span><br><span class="line">		<span class="keyword">return</span> self._name.upper()    <span class="comment"># 现在真正的属性是 _name 了</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">	@name.setter	                 # 定义 setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self, new_name)</span>:</span>        <span class="comment"># 函数名不变</span></span><br><span class="line">		<span class="keyword">if</span> isinstance(new_name, str):</span><br><span class="line">			self._name = new_name.lower()  <span class="comment"># 把值存到私有属性 _name 里</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.name      <span class="comment"># 其实调用了 name 函数，得到大写的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br><span class="line">bs.name = <span class="number">1</span>  <span class="comment"># 其实调用了 name 函数，因为类型不符，无法赋值</span></span><br><span class="line">bs.name      <span class="comment"># 还是老的名字： &amp;#39;BESTSWIFTER&amp;#39;</span></span><br></pre></td></tr></table></figure>

我们已经在 2.4 节详细学习了装饰器，应该能意识到这里的 `@property` 和 `@xxx.setter` 都是装饰器。因此上述写法实际上等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._name.upper()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> isinstance(new_name, str):</span><br><span class="line">			self._name = new_name.lower()</span><br><span class="line">	<span class="comment"># 以上是老旧的 getter 和 setter 定义</span></span><br><span class="line">	<span class="comment"># 如果不用 @property，可以定义一个 property 类的实例</span></span><br><span class="line">	name = property(get_name, set_name)</span><br></pre></td></tr></table></figure>

可见，特性的本质是给类创建了一个类属性，它是 `property` 类的实例，构造方法中需要把 `getter`、`setter` 等函数传入，我们可以打印一下类的 `name` 属性来证明：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.name  <span class="comment"># &amp;lt;property object at 0x107c99868&amp;gt;</span></span><br></pre></td></tr></table></figure>

理解特性的工作原理至关重要。以这里的 `name` 特性为例，我们访问了对象的 `name` 属性，但是它并不存在，所以会尝试访问类的 `name` 属性，这个属性是 `property` 类的实例，会对读写操作做特殊处理。这也意味着，如果我们重写了类的 `name` 属性，那么对象的读写方法就不会生效了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bs = Person()</span><br><span class="line">Person.name = &amp;<span class="comment">#39;hello&amp;#39;</span></span><br><span class="line">bs.name  <span class="comment"># 实例并没有 name 属性，因此会访问到类的属性 name，现在的值是 &amp;#39;hello` 了</span></span><br></pre></td></tr></table></figure>

如果访问不存在的属性，默认会抛出异常，但如果实现了 `__getattr__` 函数，还有一次挽救的机会：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">	</span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line">bs.name    <span class="comment"># 直接访问属性</span></span><br><span class="line">bs.age     <span class="comment"># 得到 0，这是 __getattr__ 方法提供的默认值</span></span><br><span class="line">bs.age = <span class="number">1</span> <span class="comment"># 动态给属性赋值</span></span><br><span class="line">bs.age     <span class="comment"># 得到 1，注意！！！这时候就不会再调用 __getattr__ 方法了</span></span><br></pre></td></tr></table></figure>

由于 `__getattr__` 只是兜底策略，处理一些异常情况，并非每次都能被调用，所以不能把重要的业务逻辑写在这个方法中。

#### 3.2.4 特性工厂

在上一节中，我们利用特性来封装 `getter` 和 `setter`，对外暴露统一的读写接口。但有些 `getter` 和 `setter` 的逻辑其实是可以复用的，比如商品的价格和剩余数量在赋值时，都必须是大于 0 的数字。这时候如果每次都要写一遍 `setter`，代码就显得很冗余，所以我们需要一个能批量生产特性的函数。由于我们已经知道了特性是 `property` 类的实例，而且是类的属性，所以代码可以这样写：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">(storage_name)</span>:</span>  <span class="comment"># 定义 getter 和 setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">		    <span class="comment"># 把值保存在实例的 __dict__ 字典中</span></span><br><span class="line">			instance.__dict__[storage_name] = value </span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br><span class="line">	<span class="keyword">return</span> property(qty_getter, qty_setter) <span class="comment"># 返回 property 的实例</span></span><br></pre></td></tr></table></figure>

有了这个特性工厂，我们可以这样来定义特性：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    price = quantity(&amp;<span class="comment">#39;price&amp;#39;)</span></span><br><span class="line">    number = quantity(&amp;<span class="comment">#39;number&amp;#39;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        		</span><br><span class="line">i = Item()</span><br><span class="line">i.price = <span class="number">-1</span> </span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># ValueError: value must be &amp;gt; 0</span></span><br></pre></td></tr></table></figure>

作为追求简洁的程序员，我们不禁会问，在 `price = quantity(&#39;price&#39;)` 这行代码中，属性名重复了两次，能不能在 `quantity` 函数中自动读取左边的属性名呢，这样代码就可以简化成 `price = quantity()` 了。

答案显然是否定的，因为右边的函数先被调用，然后才能把结果赋值给左边的变量。不过我们可以采用迂回策略，变相的实现上面的需求：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		quantity.count += <span class="number">1</span></span><br><span class="line">	<span class="keyword">except</span> AttributeError:</span><br><span class="line">		quantity.count = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	storage_name = &amp;<span class="comment">#39;_&#123;&#125;:&#123;&#125;&amp;#39;.format(&amp;#39;quantity&amp;#39;, quantity.count)	</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">			instance.__dict__[storage_name] = value</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br><span class="line">	<span class="keyword">return</span> property(qty_getter, qty_setter)</span><br></pre></td></tr></table></figure>

这段代码中我们利用了两个技巧。首先函数是一等公民， 所以函数也是对象，自然就有属性。所以我们利用 `try ... except` 很容易的就给函数工厂添加了一个计数器对象 `count`，它每次调用都会增加，然后再拼接成存储时用的键 `storage_name` ，并且可以保证不同 `property` 实例的存储键名各不相同。

其次，`storage_name` 在 `getter` 和 `setter` 函数中都被引用到，而这两个函数又被 `property` 的实例引用，所以 `storage_name` 会因为被持有而延长生命周期。这也正是闭包的一大特性：能够捕获自由变量并延长它的生命周期和作用域。

我们来验证一下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    price = quantity()</span><br><span class="line">    number = quantity()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">i = Item()</span><br><span class="line">i.price = <span class="number">1</span></span><br><span class="line">i.number = <span class="number">2</span></span><br><span class="line">i.price     <span class="comment"># 得到 1，可以正常访问</span></span><br><span class="line">i.number    <span class="comment"># 得到 2，可以正常访问</span></span><br><span class="line">i.__dict__  <span class="comment"># &#123;&amp;#39;_quantity:0&amp;#39;: 1, &amp;#39;_quantity:1&amp;#39;: 2&#125;</span></span><br></pre></td></tr></table></figure>

可见现在存储的键名可以被正确地自动生成。

#### 3.2.5 属性描述符

文件描述符的作用和特性工厂一样，都是为了批量的应用特性。它的写法也和特性工厂非常类似：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">		self.storage = storage_name</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[self.storage]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">			instance.__dict__[self.storage] = value</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br></pre></td></tr></table></figure>

主要有以下几个改动：

1. 不用返回 `property` 类的实例了，因此 `getter` 和 `setter` 方法的名字是固定的，这样才能满足协议。
2. `__get__` 方法的第一个参数是描述符类 `Quantity` 的实例，第二个参数 `self` 是要读取属性的实例，比如上面的 `i`，也被称作托管实例。第三个参数是托管类，也就是 `Item`。
3. `__set__` 方法的前两个参数含义类似，第三个则是要读取的属性名，比如 `price`。

和特性工厂类似，属性描述符也可以实现 `storage_name` 的自动生成，这里就不重复代码了。看起来属性描述符和特性工厂几乎一样，但由于属性描述符是类，它就可以继承。比如这里的 `Quantity` 描述符有两个功能：自动存储和值的校验。自动存储是一个非常通用的逻辑，而值的校验是可变的业务逻辑，所以我们可以先定义一个 `AutoStorage` 描述符来实现自动存储功能，然后留下一个空的 `validate` 函数交给子类去重写。

而特性工厂作为函数，自然就没有上述功能，这两者的区别类似于 3.2.1 节中介绍的静态函数与全局函数的区别。

#### 3.2.6 实例属性的查找顺序

我们知道类的属性都会存储在 `__dict__` 字典中，即使没有显式的给属性赋值，但只要字典里面有这个字段，也是可以读取到的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p.__dict__[&amp;<span class="comment">#39;name&amp;#39;] = &amp;#39;bestswifter&amp;#39;</span></span><br><span class="line">p.name  <span class="comment"># 不会报错，而是返回字典中的值，&amp;#39;bestswifter&amp;#39;</span></span><br></pre></td></tr></table></figure>

但我们在特性工厂和属性描述符的实现中，都是直接把属性的值存储在 `__dict__` 中，而且键就是属性名。之前我们还介绍过，特性的工作原理是没有直接访问实例的属性，而是读取了 `property` 的实例。那直接把值存在 `__dict__` 中，会不会导致特性失效，直接访问到原始内容呢？从之前的实践结果来看，答案是否定的，要解释这个问题，我们需要搞明白访问实例属性的查找顺序。

假设有这么一段代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o = cls()   <span class="comment"># 假设 o 是 cls 类的实例</span></span><br><span class="line">o.attr      <span class="comment"># 试图访问 o 的属性 attr</span></span><br></pre></td></tr></table></figure>

再对上一节中的属性描述符做一个简单的分类：

1. 覆盖型描述符：定义了 `__set__` 方法的描述符
2. 非覆盖型描述符：没有定义 `__set__` 方法的描述符

在执行 `o.attr` 时，查找顺序如下：

1. 如果 `attr` 出现在 `cls` 或父类的 `__dict__` 中，且 `attr` 是覆盖型描述符，那么调用 `__get__` 方法。
2. 否则，如果 `attr` 出现在 `o` 的`__dict__` 中，返回 `o.__dict__[attr]`
3. 否则，如果`attr` 出现在 `cls` 或父类的 `__dict__` 中，如果 `attr` 是非覆盖型描述符，那么调用 `__get__` 方法。
4. 否则，如果没有非覆盖型描述符，直接返回 `cls.__dict__[attr]`
5. 否则，如果 `cls` 实现了 `__getattr__` 方法，调用这个方法
6. 抛出 `AttributeError`

所以，在访问类的属性时，覆盖型描述符的优先级是高于直接存储在 `__dict__` 中的值的。

### 3.3 多继承

本节内容部分摘自我的这篇文章：[从 Swift 的面向协议编程说开去](http://www.jianshu.com/p/fc105512bf40)，本节聊的是多继承在 Python 中的知识，如果想阅读关于多继承的讨论，请参考原文。

#### 3.3.1 多继承的必要性

很多语言类的书籍都会介绍，多继承是个危险的行为。诚然，狭义上的多继承在绝大多数情况下都是不合理的。这里所谓的 **“狭义”**，指的是一个类拥有多个父类。我们要明确一个概念：继承的目的不是代码复用，而是声明一种 `is a` 的关系，代码复用只是 `is a` 关系的一种外在表现。

因此，如果你需要狭义上的多继承，还是应该先问问自己，真的存在这么多 `is a` 的关系么？你是需要声明这种关系，还是为了代码复用。如果是后者，有很多更优雅的解决方案，因为多继承的一个直接问题就是菱形问题（Diamond Problem）。

但是广义上的多继承是必须的，不能因为害怕多继承的问题就忽略多继承的优点。**广义多继承** 指的是通过定义接口（Interface）以及接口方法的默认实现，形成“一个父类，多个接口”的模式，最终实现代码的复用。当然，不是每个语言都有接口的概念，比如 Python 里面叫 Mixin，会在 3.3.3 节中介绍。

广义上的多继承非常常见，有一些教科书式的例子，比如动物可以按照哺乳动物，爬行动物等分类，也可以按照有没有翅膀来分类。某一个具体的动物可能满足上述好几类。在实际的开发中也到处都是广义多继承的使用场景，比如 iOS 或者安卓开发中，系统控件的父类都是固定的，如果想让他们复用别的父类的代码，就会比较麻烦。

#### 3.3.2 Python 的多继承

Python 语法直接支持多继承：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;A&amp;#39;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span>     <span class="comment"># 继承自 A，重写 foo 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;B&amp;#39;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span>     <span class="comment"># 继承自 A，重写 foo 方法</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(&amp;<span class="comment">#39;C&amp;#39;)</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span>  <span class="comment"># 多继承的语法，父类之间用逗号间隔</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.foo()         <span class="comment"># 输出：&amp;#39;B&amp;#39;</span></span><br></pre></td></tr></table></figure>

这就是著名的菱形问题，D 继承自 B 和 C，而 B 和 C 都继承自 A，他们的继承关系构成一个菱形。调用 D 类实例的 `foo` 方法会让人产生疑惑，它的父类们都实现了 `foo` 方法，到底以谁为准？

Python 有一套算法来计算遍历顺序，这个顺序叫做**方法解析顺序（Method Resolution Oder，MRO）**。这个算法叫做 C3 算法，可以参考这篇官方文档：[The Python 2.3 Method Resolution Order](https://www.python.org/download/releases/2.3/mro/)

不过在绝大多数情况下，除非你的代码极度依赖多继承，否则都不需要了解这个算法的具体工作原理。一方面，我们可以调用某个特定父类的方法。我们也许已经注意到两个事实，首先类中定义的方法其实都是类的属性，但调用者都是类的实例。其次，类方法的第一个参数都是 `self`，表示方法的调用者，但我们调用时并不需要传入实例。这是因为其实实例方法的正规调用方式是这样的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C.foo(C())</span><br><span class="line"><span class="comment"># 或者是</span></span><br><span class="line">C.foo(d)</span><br></pre></td></tr></table></figure>

这种调用方式符合定义，而且能够解释上述的两个疑问。然而这种调用方式不仅写起来麻烦，还很不合理，因为我们不仅要实例对象，还需这个实例所属的类才能调用。因此，Python 的做法是将类中定义的方法绑定到每一个实例上：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D.foo  <span class="comment"># &amp;lt;function B.foo at 0x10696c158&amp;gt; 这个是真正的方法对象</span></span><br><span class="line">d      <span class="comment"># &amp;lt;__main__.D object at 0x1075fa400&amp;gt;  这个是 D 的一个实例</span></span><br><span class="line">d.foo  <span class="comment"># &amp;lt;bound method B.foo of &amp;lt;__main__.D object at 0x106967400&amp;gt;&amp;gt; 注意看地址和 d 是一致的</span></span><br><span class="line">d.foo.__self__ <span class="comment"># &amp;lt;__main__.D object at 0x1075fa400&amp;gt;，通过 __self__ 引用绑定的实例</span></span><br></pre></td></tr></table></figure>

可以清楚的从 `d.foo` 的输出结果看出来，它是绑定到 `d` 对象上的函数，第一个参数 `self` 就是 `d`。

另一方面，我们不仅可以调用任意父类的方法，还可以通过类的 `__mro__` 属性查看父类的继承顺序：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D.__mro__</span><br><span class="line"><span class="comment"># (&amp;lt;class &amp;#39;__main__.D&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.B&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.C&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;__main__.A&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;)</span></span><br></pre></td></tr></table></figure>

所以，多继承的方法调用顺序一般情况下不会对开发代码造成太大的困扰。

#### 3.3.3 Mixin

Mixin 不是 **迷信** 的拼音，它表示**混入**，可以方便的实现代码复用。在 Python 中，Mixin 是以多继承的形式实现的，比如：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONable</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_json</span><span class="params">(self)</span>:</span></span><br><span class="line">		 <span class="keyword">return</span> str(self.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugMixin</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">	     <span class="keyword">return</span> &amp;<span class="comment">#39;&amp;#39;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span><span class="params">(BaseController, JSONable, DebugMixin)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

Mixin 和多继承最大的区别在于它一般不产生菱形问题，但 Python 并没有语法层面的约束来保证这一点，所以对于 Mixin，我们一般需要遵守以下几个约定：

1. 一般命名以 Mixin、able、ible 结尾，明确表示混入，或者提供某种能力。
2. 一般不要有复杂的继承关系，尤其不要和被混入的类（比如上面的 `Controller` 类）有共同的父类，避免菱形问题。
3. 一般提供简单的功能，如果有多个功能，就写成多个 Mixin。
4. 功能完备、独立，不要依赖被混入的类。
4. 看到上述命名风格的类，不要实例化他们，仅用在多继承中。

在 5.3.2 节中会有实际的 Mixin 的使用场景。

#### 3.3.4 抽象类

有时候我们需要在父类定义一个方法，然后交给子类去实现。这种方法叫做抽象方法， 定义了抽象方法的类叫做抽象类。抽象类不应该被实例化，在 Java 中，`Interface` 就是抽象类，它不能被实例化，只有实现了协议的类才能创建实例。

在 Python 中，抽象类需要把自己的 `metaclass` 设置为 `abc.ABCMeta`，并且用装饰器去标记抽象函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseItem</span><span class="params">(Base, metaclass=abc.ABCMeta)</span>:</span>   <span class="comment"># 需要标记 metaclass</span></span><br><span class="line"><span class="meta">	@abc.abstractmethod                        # 抽象函数</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_price</span><span class="params">(self)</span>:</span></span><br><span class="line">		 &amp;quot;&amp;quot;&amp;quot;Method that should do something.&amp;quot;&amp;quot;&amp;quot;</span><br><span class="line"></span><br><span class="line">item = BaseItem()</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># TypeError: Can&amp;#39;t instantiate abstract class BaseItem with abstract methods get_price</span></span><br></pre></td></tr></table></figure>

如果设置了 `metaclass` 并且标记了抽象函数，那么任何没有实现抽象函数的子类（包括抽象类自己）都无法实例化。

### 3.4 元编程

#### 3.4.1 类工厂函数

有些类的功能很单一，仅仅用来存储数据。但如果先声明一个长长的 `__init__` 函数，再挨个写 `self.xxx = xxx` 这种模板代码，就显得很啰嗦。其实也可以自己实现一个 1.1.2 节中的具名元组。具名元zu组是一个函数，它返回一个类：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">People = collections.namedtuple(&amp;<span class="comment">#39;People&amp;#39;, [&amp;#39;name&amp;#39;, &amp;#39;age&amp;#39;])</span></span><br><span class="line">p = People(&amp;<span class="comment">#39;bestswifter&amp;#39;, &amp;#39;22&amp;#39;)</span></span><br></pre></td></tr></table></figure>

`namedtuple` 这种函数可以称为**类工厂函数**，因为它可以根据传入的参数，动态的生成类，我们来实现一个简化版的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_tuple</span><span class="params">(cls, names)</span>:</span></span><br><span class="line">	names = names.split(&amp;<span class="comment">#39; &amp;#39;)   # 这里会得到属性的数组</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> (name, value) <span class="keyword">in</span> zip(self.__slots__, args):</span><br><span class="line">		    <span class="comment"># slots 是属性名，args 是初始化的参数，一一对应起来用 setattr 给实例的属性赋值</span></span><br><span class="line">			setattr(self, name, value)	</span><br><span class="line">	</span><br><span class="line">	cls_attrs = dict(__slots__ = names, __init__ = __init__)</span><br><span class="line">	<span class="keyword">return</span> type(cls, (object, ), cls_attrs)</span><br><span class="line">	</span><br><span class="line">People = my_tuple(&amp;<span class="comment">#39;People&amp;#39;, &amp;#39;name age&amp;#39;)</span></span><br><span class="line">p = People(&amp;<span class="comment">#39;bestswifter&amp;#39;, &amp;#39;22&amp;#39;)</span></span><br><span class="line">p.name   <span class="comment"># &amp;#39;bestswifter&amp;#39;</span></span><br><span class="line">p.age    <span class="comment"># 22</span></span><br></pre></td></tr></table></figure>

这个类工厂非常简陋，比如不支持关键字参数，但用来演示类工厂的原理是已经足够了。类工厂的核心原理在于 `type` 函数，它不仅可以传入一个实例，返回实例的类型，也可以像这里的使用一样，传入三个参数，构造一个类。第一个参数表示类名，第二个参数是继承关系，最后一个则是类的属性。

#### 3.4.2 元类的概念

元类和类工厂函数的区别就像属性描述符和特性工厂函数的区别一样，**前者是类，可以继承**，后者不行。就像我们上一节中用 `type` 来生成类一样，Python 中的类都是 `type` 类的实例：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="comment">#39;bestswifter&amp;#39;.__class__  # &amp;lt;class &amp;#39;str&amp;#39;&amp;gt;，字符串都是 str 类的实例</span></span><br><span class="line">str.__class__            <span class="comment"># &amp;lt;class &amp;#39;type&amp;#39;&amp;gt; str 类是 type 类的实例</span></span><br><span class="line">int.__class__            <span class="comment"># &amp;lt;class &amp;#39;type&amp;#39;&amp;gt; int 也是 type 类的实例</span></span><br><span class="line">type.__class__           <span class="comment"># &amp;lt;class &amp;#39;type&amp;#39;&amp;gt; type 类是自己的实例，防止死循环</span></span><br></pre></td></tr></table></figure>

需要说明的是，`__class__` 表示的是元类，而不是父类，父类可以通过 3.3.2 节中介绍的 `__mro__` 属性来查看：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int.__mro__  <span class="comment"># (&amp;lt;class &amp;#39;int&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;)</span></span><br><span class="line">str.__mro__  <span class="comment"># (&amp;lt;class &amp;#39;str&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;)</span></span><br></pre></td></tr></table></figure>

可见 `int` 和 `str` 这些内置类的父类都是 `objcet`，我们可以认为 `object` 是所有类的父类，而 `type` 是所有类的元类，这个规则在这两个类之间也适用，可以验证一下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.__class__   <span class="comment"># &amp;lt;class &amp;#39;type&amp;#39;&amp;gt;</span></span><br><span class="line">type.__mro__       <span class="comment"># (&amp;lt;class &amp;#39;type&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;object&amp;#39;&amp;gt;)</span></span><br></pre></td></tr></table></figure>

可见 `object` 是 `type` 类构建出来的实例，`type` 是 `object` 类的元类，而 `object` 则是 `type` 类的父类。如下图所示：
![](https://diycode.b0.upaiyun.com/photo/2018/7cfd0dcc1843eac2a7e4e84afd794533.png)


这里介绍元类和父类并非是为了烧脑，除了描述最基本的概念以外，我们应该意识到，类是由元类的 `__init__` 方法构造出来的实例，如果我们继承元类并且重写 `__init__` 方法，就可以控制类的初始化方法。

#### 3.4.3 元类的使用示例

在介绍属性描述符时，我们用计数器来实现 `storage_name` 的自动生成，从而避免冗余的代码，但代码的可读性会下降，因为属性的名称无法获得，只能用递增的数字来区别。利用元类，我们可以在不影响可读性的前提下，实现存储名称的自动生成：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span></span><br><span class="line">	__counter = <span class="number">0</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		cls = self.__class__</span><br><span class="line">		self.storage = &amp;<span class="comment">#39;_&#123;&#125;#&#123;&#125;&amp;#39;.format(cls.__name__, cls.__counter)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> instance.__dict__[self.storage]</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> value &amp;gt; <span class="number">0</span>:</span><br><span class="line">			instance.__dict__[self.storage] = value</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> ValueError(&amp;<span class="comment">#39;value must be &amp;gt; 0&amp;#39;)</span></span><br><span class="line"><span class="comment"># Quantity 类是可以自动生成 storage 名称的描述符类，和之前的逻辑基本类似，可以不用关注</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承自 type 类，是一个自定义的元类	</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuantityMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, bases, attr_dict)</span>:</span> </span><br><span class="line">	    <span class="comment"># name 表示类名，bases 是继承关系，attr_dict 则是属性列表，和 type 方法的参数含义一致</span></span><br><span class="line">		super().__init__(name, bases, attr_dict)</span><br><span class="line">		<span class="keyword">for</span> key, attr <span class="keyword">in</span> attr_dict.items():</span><br><span class="line">		    <span class="comment"># 注意，类有很多属性，但只有描述符类型的属性才需要修改</span></span><br><span class="line">			<span class="keyword">if</span> isinstance(attr, Quantity):</span><br><span class="line">				type_name = type(attr).__name__</span><br><span class="line">				<span class="comment"># 这里的 key 就是原来的属性名，比如 price、number</span></span><br><span class="line">				attr.storage = &amp;<span class="comment">#39;_&#123;&#125;#&#123;&#125;&amp;#39;.format(type_name, key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了避免让用户知道太多元类的细节，我们创建一个基类 Entity，并把它的元类设置为 QuantityMeta</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span><span class="params">(metaclass=QuantityMeta)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在用户的类只要继承自 Entity 就可以了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span><span class="params">(Entity)</span>:</span></span><br><span class="line">	price = Quantity()</span><br><span class="line">	number = Quantity()</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">				</span><br><span class="line">i = Item()</span><br><span class="line">i.price = <span class="number">1</span></span><br><span class="line">print(i.__dict__)  <span class="comment"># 得到 &#123;&amp;#39;_Quantity#price&amp;#39;: 1&#125;，可读性良好</span></span><br><span class="line"><span class="comment">#i.price = -1      # 抛出异常</span></span><br></pre></td></tr></table></figure>

虽然代码比较长，但其实核心很简单，在元类的 `__init__` 方法中，我们可以获取将要生成的类的名称、父类和属性，就像在类工厂函数中传给 `type` 类的那些参数一样。有了这些信息，我们可以把当初用计数器生成的临时存储名称给改正为可读性更高的名称。

## 4. 流程控制

### 4.1 else

除了最常见的 `if ... else ...` 语句外，还有很多地方都会用到 `else`，它的用法各不相同，但如果灵活使用，会使代码更简洁， 更具可读性。

#### 4.1.1 for else

for 语句的末尾可以加上 else，仅当 for 循环没有因为 break 而终止，顺利运行完以后才运行。这个用法看起来怪怪的，毕竟其他 for 循环后面的代码，也会正常执行。所以这个规则应该反过来理解：**如果 for 循环因为 break 而终止，else 代码块就不会执行**。

有过一些编程经验的读者应该经常会写出这样的代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">found = <span class="keyword">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">    <span class="keyword">if</span> some_judge(i):  <span class="comment"># 只要找到一个满足条件的，就把 found 置为 True</span></span><br><span class="line">        found = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> found:          <span class="comment"># 如果全都不符合条件，执行某个逻辑</span></span><br><span class="line">    print(&amp;<span class="comment">#39;Nothing found&amp;#39;)</span></span><br></pre></td></tr></table></figure>

如果用 `else` 语句，代码就会简化：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">    <span class="keyword">if</span> some_judge(i):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(&amp;<span class="comment">#39;Nothing found&amp;#39;)</span></span><br></pre></td></tr></table></figure>

如果 `if` 判断成立了，就会进入 `break`，于是 `else` 的代码就不会执行，否则就会输出 Nothing found。和上面的例子相比，使用 `else` 的代码更简洁，而且不需要再用一个变量来标记了。

#### 4.1.2 while else

仅当 `while` 循环因为判断条件不成立而退出，而不是因为 `break` 才退出时，才会执行 `else` 代码块，用法和 `for ... else ...` 基本一致。

#### 4.1.3 try else

仅当 `try` 代码块中没有抛出异常时才会执行 `else`。为了理解 `try ... else` 的使用场景，我们先看一个常见的场景。

一个很常见的错误是为了处理异常，把一大段代码都放在 `try` 语句中：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 写了几十行毫无问题的代码</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    some_dangarous_operation()</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 下面跟了几十行毫无问题的代码</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 处理异常</span></span><br></pre></td></tr></table></figure>

这种写法非常不负责任，`try` 不是防止崩溃的银弹，而是应该用在真正可能导致异常的函数上，所以要保证 `try` 的代码块尽可能简单，突出要尝试执行的代码。以这段代码为例，`some_dangarous_operation` 函数之前的代码可以放在 `try` 代码块上面写，但如果 `some_dangarous_operation` 函数之后的代码依赖于这个函数的正确执行，就不太好独立出来了。这时候就该 `try ... else` 发挥作用了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some_dangarous_operation 之前的安全代码写在这里</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    some_dangarous_operation()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 处理异常</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">    <span class="comment"># 依赖于 some_dangarous_operation 的安全代码</span></span><br></pre></td></tr></table></figure>

### 4.2 迭代器

#### 4.2.1 迭代器

迭代器接口定义了两个方法，`__next__`  方法没有参数，用于返回序列的下一个元素，如果没有元素就抛出 `StopIteration` 异常，`__iter__`方法返回自己。

根据鸭子类型的定义，一个类不用声明为迭代器，只要它实现了迭代器接口中定义的两个方法，就可以迭代：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span>:</span></span><br><span class="line">	index = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.index &amp;gt; <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">raise</span>  StopIteration</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			self.index += <span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> self.index</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">()</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">i = MyIterator()</span><br><span class="line">next(i) <span class="comment"># 得到 1，i 的 index 为 1</span></span><br><span class="line">next(i) <span class="comment"># 得到 1，i 的 index 为 2</span></span><br><span class="line">next(i) <span class="comment"># 得到 1，i 的 index 为 3</span></span><br><span class="line">next(i) <span class="comment"># 根据 if 判断的条件，抛出 StopIteration 异常，迭代结束</span></span><br></pre></td></tr></table></figure>

`next` 函数的参数是迭代器，用于获取迭代器中的下一个元素。

#### 4.2.2 可迭代对象

用 `next` 函数去迭代一个迭代器对象，不仅语法繁琐，每次还要用 `try catch` 来处理随时都有可能发生的 `StopIteration` 异常，这种写法实在是太啰嗦了。所以我们平时都用 `for in` 语法来遍历字符串、数组等可迭代对象：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> &amp;<span class="comment">#39;bestswifter&amp;#39;:</span></span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>

这种写法其实是对迭代器的封装：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">it = iter(&amp;<span class="comment">#39;bestswifter&amp;#39;)</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		print(next(it))</span><br><span class="line">	<span class="keyword">except</span> StopIteration:</span><br><span class="line">		<span class="keyword">del</span> it</span><br><span class="line">		<span class="keyword">break</span></span><br></pre></td></tr></table></figure>

可见 `for in` 语法省略了大量的模板代码。可以看到这里的字符串是可迭代对象，在用 `for in` 遍历时，其实是通过 `iter` 函数获取了可迭代对象的迭代器，然后用 `next` 函数去遍历这个迭代器，这揭示了迭代器和可迭代对象之间重要的关系：**Python 用 iter 函数从可迭代对象中获取迭代器**。

#### 4.2.3 \__iter__ 方法
能够用 `for in` 语法遍历的对象必须是可迭代的，除了内置的数组、元组等类型外，自定义的类型也有办法变成可迭代的，因为 `iter` 函数最终会调用对象的  `__iter` 方法。我们只要能实现这个方法，返回适当的迭代器，就可以让对象变成可迭代的，并支持 `for in` 语法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Foo():</span><br><span class="line">	print(i) <span class="comment"># 共三行输出，分别是 1、2 和 3</span></span><br></pre></td></tr></table></figure>

没实现 `__iter__` 方法，但是实现了 `__getitem__` 方法的对象也是可迭代的，这个函数在 1.1.5 节中已经介绍过，用来处理下标访问。Python 会创建一个迭代器，并且用从 0 开始的整数调用 `__getitem__` 方法作为迭代器的 `next` 值。如果实现了 `__len__` 是最好，Python 解释器只会调用指定次数的 `__getitem__`，否则会在越界时自动停止。

再次总结下，可迭代对象和迭代器是两个概念，写在 `for in` 中的是可迭代对象，它需要实现 `__iter__` 方法为 `iter` 方法提供一个迭代器。迭代器需要满足迭代器接口， 也就是两个函数。无参数的 `__next__` 方法提供下一个元素或者抛出异常，`__iter__` 函数返回自己。从这个角度看，迭代器都是可迭代对象。

#### 4.2.4 标准迭代器

有了上述知识作为铺垫，我们来尝试实现一个定义的可迭代对象。它只需要实现一个 `__iter__` 方法，返回迭代器即可，一个常见的写法如下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	_private_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.count &amp;lt; len(self._private_data):</span><br><span class="line">			temp = self._private_data[self.count]</span><br><span class="line">			self.count += <span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> temp</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">c = MyCollection()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">	print(i) <span class="comment"># 输出三行，分别是 1，2 和 3</span></span><br></pre></td></tr></table></figure>

这段代码中，`__iter__` 函数返回了自己，并且自己实现了迭代器的接口，一切运行正常。

并且这段代码向我们展示了迭代器的第一个特点：**屏蔽内部的存取细节， 对外提供统一的访问逻辑。**

很可惜的是，这段代码是**标标准准的错误写法**，因为可迭代对象的迭代器一定不能是自己，或者说可迭代对象一定不能实现 `__next__` 方法，理由很简单，看一眼 4.2.1 节中的迭代器，它是一次性的，遍历完以后就回不去了。这里也是同理，如果我们再执行一次 `for in`，就得不到输出了。换个角度思考，上一节的结论告诉我们，同时实现了 `__iter__` 和 `__iter__` 方法的是迭代器，而迭代器是不能用于 `for in` 语句的。

正确的写法如下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>:</span></span><br><span class="line">	_private_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> MyCollectionIterator(self._private_data)</span><br><span class="line">			</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollectionIterator</span>:</span></span><br><span class="line">	count = <span class="number">0</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">		self.data = data</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">if</span> self.count &amp;lt; len(self.data):</span><br><span class="line">			temp = self.data[self.count]</span><br><span class="line">			self.count += <span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> temp</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">raise</span> StopIteration</span><br><span class="line">		</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> MyCollection():</span><br><span class="line">	print(i)</span><br></pre></td></tr></table></figure>

代码很长，但思路很简单，就是遵守迭代器和可迭代对象的定义，把一次性的迭代工作交给可以重复创建实例的  `MyCollectionIterator` 类完成。

这也正是迭代器模式的另一个特点，**对象能够正确保存多次迭代的进度，支持多次迭代。**

#### 4.2.5 初识生成器

稍有追求的程序员都难以容忍这么多模板代码（两个 `__iter__`， 一个 `__next__`），好在 Python 的生成器可以简化上述代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>:</span></span><br><span class="line">	_private_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> self._private_data:</span><br><span class="line">			<span class="keyword">yield</span> i</span><br></pre></td></tr></table></figure>

从直观上看，这里用 `yield` 关键字替换了 `return`，打破了 “可迭代对象不能实现 `__next__` ” 的规定，但却能够支持多次遍历，这段代码的工作原理会在介绍完生成器以后解释。

### 4.3 生成器

#### 4.3.1 生成器的定义

先给出生成器的定义：

1. 只要函数体重有 `yield` 关键字，这个函数就是生成器函数
2. 调用生成器函数，会得到**生成器**，生成器函数可以理解为生成器的工厂
3. 调用 `next` 函数会激发生成器的下一个值

举个例子:

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    print(&amp;<span class="comment">#39;Start&amp;#39;)</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">	print(&amp;<span class="comment">#39;Continue&amp;#39;)</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">	</span><br><span class="line">g = gen()       <span class="comment"># 注意，这里没有输出！！！</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出两行，start 和 1</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出两行，Continue 和 2</span></span><br><span class="line">print(next(g))  <span class="comment"># 输出 2</span></span><br><span class="line">print(next(g))  <span class="comment"># 抛出异常 StopIteration</span></span><br></pre></td></tr></table></figure>

从输出内容中可以看出，调用生成器函数会返回一个生成器对象，但生成器函数中的代码不会执行。在调用 `next(g)` 函数时才会执行生成器函数的代码，阻塞在 `yield x` 这一行，并且`next(g)` 函数的返回值就是 `x`。第几次调用 `next` 函数，就会阻塞在第几个 `yield` 处。如果是第一次接触生成器，这个逻辑需要反复体会几次。

生成器的使用方式和迭代器一致，我们可以认为生成器都是迭代器，都实现了迭代器接口。因此 4.2.5 节中的代码就很容易解释了。当外部调用 `iter()` 函数时，实际上 `__iter__` 方法中的代码并没有被立刻执行，而是返回了一个生成器。

#### 4.3.2 生成器表达式

我们在文章开头的 1.1.1 节中介绍了数组推导，生成器表达式可以理解为惰性版的数组推导：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> array] <span class="comment"># 数组推导</span></span><br><span class="line">(x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> array) <span class="comment"># 生成器表达式</span></span><br></pre></td></tr></table></figure>

两者的写法非常类似，只是把数组的大括号换成了圆括号，区别在于前者生成了一个新的数组，如果原来的数组占用 M 兆内存，现在两个数组就会占用 2 * M 兆内存。而生成器是懒计算的，并不增加内存占用。

生成器表达式对于大容量的数组，或者无尽数组特别适用，比如可以写一个斐波那契数组：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">0</span></span><br><span class="line">	b = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">		<span class="keyword">yield</span> b</span><br><span class="line">		a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># fib() 可以被当成无尽队列，我们只取前 10 个元素		</span></span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(fib()):</span><br><span class="line">	<span class="keyword">if</span> i &amp;lt; <span class="number">10</span>:</span><br><span class="line">		print(n)</span><br></pre></td></tr></table></figure>

#### 4.3.3 协程

上一节中介绍的生成器有两个小缺点：

1. 这段代码无法正常退出，因为 `fib` 函数是个死循环，最终会停在第 11 个 yield 上，等待外部的 `next` 函数。
2. 现在的数据传递都是单向的，只有生成器给调用方传值，调用方无法给生成器传值。

实际上，生成器函数都是协程，我们可以利用协程的特性解决这两个问题：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fibs = fib()</span><br><span class="line"><span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(fibs):</span><br><span class="line">	<span class="keyword">if</span> i &amp;lt; <span class="number">10</span>:</span><br><span class="line">		print(n)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		fibs.close()</span><br></pre></td></tr></table></figure>

只要在遍历完以后调用生成器的 `close` 方法，就可以结束生成器并正确的退出了。如果需要向生成器中传值，需要调用生成器对象的 `send` 方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">0</span></span><br><span class="line">	b = <span class="number">1</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">		i = <span class="keyword">yield</span> &amp;<span class="comment">#39;第&#123;0&#125;个数是: &#123;1&#125;&amp;#39;.format(i, b)</span></span><br><span class="line">		a, b = b, a + b</span><br><span class="line">				</span><br><span class="line">fibs = fib()</span><br><span class="line">next(fibs)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	print(fibs.send(i))</span><br></pre></td></tr></table></figure>

此时，`yield` 表达式左边的值就是 `send` 函数中的参数，而 `send` 函数的返回值则是 `yield` 关键字右边的结果。

协程的用法并不复杂，但它是异步编程的基础，比如 ES 7 中的 `async/await` 语法，能将异步回调变成同步的写法，它就是依靠协程实现的。感兴趣的读者可以参考我的这篇文章：[异步与回调的设计哲学](http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/)。

#### 4.3.4 预激协程

在创建生成器时，并不会执行生成器函数中的代码，第一次调用 `next(g)` 函数时会执行到第一个 `yield` 处。而协程的 `send` 函数用来给 `yield` 左侧的变量赋值。所以在调用 `send` 函数之前一定要确保已经调用过 `next()` 函数，这样协程才会停留在 `yield` 处而不是停留在刚创建的状态。这一步操作叫做协程的预激，上一节的代码中已经演示了这一点。

在使用协程时，一般都需要预激，也就是说 `next(g)` 其实是一个模板代码，可以被优化掉。要想改变一个函数的运行逻辑，最好的方法是使用装饰器：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine</span><span class="params">(original_coroutine)</span>:</span>       </span><br><span class="line"><span class="meta">	@functools.wraps(original_coroutine)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">activate</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># 用 active 函数替换被装饰的 fib 函数</span></span><br><span class="line">		gen = original_coroutine(*args, **kwargs)  <span class="comment"># 调用 fib 函数</span></span><br><span class="line">		next(gen)  <span class="comment"># 预激协程</span></span><br><span class="line">		<span class="keyword">return</span> gen   <span class="comment"># 像 fib 函数一样，返回预激过的协程</span></span><br><span class="line">	<span class="keyword">return</span> activate  <span class="comment"># 被装饰的函数 fib 现在替换为了 active 函数，会自动预激</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">	a = <span class="number">0</span></span><br><span class="line">	b = <span class="number">1</span></span><br><span class="line">	i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">		i = <span class="keyword">yield</span> &amp;<span class="comment">#39;第&#123;0&#125;个数是: &#123;1&#125;&amp;#39;.format(i, b)</span></span><br><span class="line">		a, b = b, a + b</span><br><span class="line">					</span><br><span class="line">fibs = fib()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	print(fibs.send(i))</span><br></pre></td></tr></table></figure>

温故一下装饰器的定义，被 `coroutine` 装饰的 `fib` 函数等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_fib = coroutine(fib)</span><br><span class="line"><span class="comment"># 根据 coroutine 函数的定义，coroutine(fib) 实际上会返回下面这个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activate</span><span class="params">()</span>:</span></span><br><span class="line">	gen = fib()</span><br><span class="line">	next(gen)</span><br><span class="line">	<span class="keyword">return</span> gen</span><br></pre></td></tr></table></figure>

#### 4.3.5 标准库中的生成器函数

`itertools` 模块提供了很多生成器函数，这些函数处理可迭代的对象，并且返回生成器（节省内存，可迭代）。想要了解生成器函数，唯一可能的知识来源就是这篇[官方文档](https://docs.python.org/3/library/itertools.html#module-itertools)，本节会做简单的翻译和解释。它把生成器函数分为三大类。

第一类函数返回的是无限生成器：

| 函数名        | 参数           | 返回结果  | 示例|
| :------------- |:-------------| :-----| :----|
| [count()](https://docs.python.org/3/library/itertools.html#itertools.count)| start, [step] | start, start+step, start+2*step, … |`count(10) --&gt; 10 11 12 13 14 ...`
| [copy()]()     | p（数组） | p0, p1, ...， pn, p0, p1, ... |`cycle(&#39;ABCD&#39;) --&gt; A B C D A B C D ...`
| [repeat()](https://docs.python.org/3/library/itertools.html#itertools.repeat) | elem [,n] | elem, elem, elem, … 无尽队列或最多 n 次| `repeat(10, 3) --&gt; 10 10 10`

这三个函数的注释都说明得清楚了，配合示例应该非常容易理解。

第二类函数返回的是有限生成器，长度和传入的可迭代对象有关，我选择几个比较常用的列出来 ：

| 函数名        | 参数           | 返回结果  | 示例|
| :------------- |:-------------| :-----| :----|
|[accumulate()](https://docs.python.org/3/library/itertools.html#itertools.accumulate)|p [,func]|p0, func(p0, p1), func(p1, p2), func(p2, p3) ...|`accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15`|
|[chain()](https://docs.python.org/3/library/itertools.html#itertools.chain)|p, q, …|p0, p1, … plast, q0, q1, …|`chain(&#39;ABC&#39;, &#39;DEF&#39;) --&gt; A B C D E F`|
|[compress()](https://docs.python.org/3/library/itertools.html#itertools.compress)|data, selectors|	(d[0] if s[0]), (d[1] if s[1]), …|`compress(&#39;ABCDEF&#39;, [1,0,1,0,1,1]) --&gt; A C E F`|
|[dropwhile()](https://docs.python.org/3/library/itertools.html#itertools.dropwhile)|pred, seq|假设 pred 在第 n 个元素开始不成立：seq[n], seq[n+1]|`dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1`|
|[tee()](https://docs.python.org/3/library/itertools.html#itertools.tee)|it, n|产出 n 各元素的数组，每个元素可以看做 it 的备份，相当于把 it 复制了 n 份|`tee(&#39;ABC&#39;, 2) --&gt; g1, g2(迭代 g1 和 g2 都会得到 A、B、C)`|

最后一类是可以实现排列组合操作的生成器函数：

| 函数名        | 参数           | 返回结果  |
| :------------- |:-------------| :-----|
|[product()](https://docs.python.org/3/library/itertools.html#itertools.product)|p, q, … [repeat=1]|生成各个可迭代对象的笛卡尔积，n 表示每个可迭代对象对象重复几次|
|[permutations()](https://docs.python.org/3/library/itertools.html#itertools.permutations)|p[, r]|序列 p 所有长度为 r 的无重复元素排列|
|[combinations()](https://docs.python.org/3/library/itertools.html#itertools.combinations)|p, [r]|序列 p 所有长度为 r 的无重复元素有序排列|
|[combinations_with_replacement()](https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement)|p, [r]|序列 p 所有长度为 r 的有重复元素有序排列|

举例说明：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># ABC 和 12 的笛卡尔积，所以共有 6 个元素</span></span><br><span class="line"><span class="comment"># 得到：A1、A2、B1、B2、C1、C2</span></span><br><span class="line">l1 = list(product(&amp;<span class="comment">#39;ABC&amp;#39;, &amp;#39;12&amp;#39;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于 product(&amp;#39;AB&amp;#39;, &amp;#39;AB&amp;#39;)</span></span><br><span class="line"><span class="comment"># 得到：AA、AB、BA、BB</span></span><br><span class="line">l2 = list(product(&amp;<span class="comment">#39;AB&amp;#39;, repeat=2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ABCD 所有所有长度为 2 的无重复、无序子排列</span></span><br><span class="line"><span class="comment"># 每个元素可以和除了自己的另外三个元素组合，因此有 4 * 3 个</span></span><br><span class="line"><span class="comment"># 得到：AB、AC、AD、BA、BC、BD、CA、CB、CD、DA、DB、DC</span></span><br><span class="line">l3 = list(permutations(&amp;<span class="comment">#39;ABCD&amp;#39;, 2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ABCD 所有所有长度为 2 的无重复、有序子排列</span></span><br><span class="line"><span class="comment"># AB 和 BA 会被认为是相同的，所以只有 12 / 2 = 6 个</span></span><br><span class="line"><span class="comment"># AB、AC、AD、BC、BD、CD</span></span><br><span class="line">l4 = list(combinations(&amp;<span class="comment">#39;ABCD&amp;#39;, 2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ABCD 所有所有长度为 2 的有重复、有序子排列</span></span><br><span class="line"><span class="comment"># AA、BB 这样的也合法，所以有 6 + 4 = 10 个</span></span><br><span class="line"><span class="comment"># 得到：AA、AB、AC、AD、BB、BC、BD、CC、CD、DD</span></span><br><span class="line">l5 = list(combinations_with_replacement(&amp;<span class="comment">#39;ABCD&amp;#39;, 2))</span></span><br></pre></td></tr></table></figure>

本节仅列出了一部分常用的生成器函数，他们是系统库提供的轮子。因此在自己实现关于序列的操作以前，应该思考下这是否是常见操作，系统是否已经提供了轮子。在[官方文档的最后一节](https://docs.python.org/3/library/itertools.html#itertools-recipes) 还有一些基于上述生成器函数的拓展，通过简单的封装了 `itertools` 模块中的生成器函数，提供了更多常见的函数，比如 `take`、`tail`、`consume`、`nth`、`flatten` 等等，**强烈建议阅读一遍并且形成基本印象!**

### 4.4 上下文管理器

#### 4.4.1 with 块

`with` 代码块的一个常见用法是用于打开文件，有经验的 Python 程序员不会建议你写出这样的代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = open(file_path)</span><br><span class="line">data = f.readlines()</span><br><span class="line"><span class="comment"># 处理 data</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

用 `with` 块的写法则是：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.readlines()</span><br><span class="line">    <span class="comment"># 处理 data</span></span><br></pre></td></tr></table></figure>

这样写的好处不仅仅是不用在最后关闭文件。试想一下，如果在处理文件的过程中有多个地方有可能会抛出异常，那么在所有 `try catch` 语法的最后都要写上 `finally` 以便关闭文件。如果放到 `with` 块中写，则不需要在这么多代码。

#### 4.4.2 自定义上下文

`with` 块的本质是为了简化 `try finally` 语句，以上一节的代码为例，跟在 `with` 后面的`open()` 函数会返回一个对象，它是 `TextIOWrapper` 类的实例，我们把它称为上下文管理器，上下文管理器需要实现 `__enter__` 和 `__exit__` 方法。

`__enter__` 方法的返回值可以用 `as` 来引用，这里上下文管理器的 `__enter__` 方法的返回值是 self，所以以下两种写法中的文件句柄 `fp` 是等价的：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp = open(file_path)</span><br><span class="line"><span class="keyword">with</span> open(file_path) <span class="keyword">as</span> fp</span><br></pre></td></tr></table></figure>

第一行中的 `fp` 可以理解为第二行中的上下文管理器，也就是 `with` 后面表达式的返回值。而 `as` 后面的 `fp` 则是上下文管理器的 `__enter__` 方法的返回值，由于这里返回的是 `self`，所以两者恰好相同。

无论以哪种方式退出 `with` 块（正常结束或者因为抛出异常而退出），都会调用上下文管理器的 `__exit__` 方法。注意，这里不是 `__enter__` 方法返回值的 `__exit__` 方法。这一点很好理解，因为前者一定实现了 `__enter__` 方法，但后者不一定。

了解了上下文的概念后，我们可以自定义一个上下文，其实也就是定义一个实现了 `__enter__` 和 `__exit__` 方法的类：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(self, content)</span>:</span></span><br><span class="line">		self.original_write(content[::<span class="number">-1</span>])</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.original_write = sys.stdout.write</span><br><span class="line">		sys.stdout.write = self.reverse_write</span><br><span class="line">		<span class="keyword">return</span> &amp;<span class="comment">#39;Enter context&amp;#39;[::-1]  # 这个字符串会被倒序打印，所以先倒序一次</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">		sys.stdout.write = self.original_write</span><br><span class="line">		print(exc_type, exc_value, traceback)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">with</span> Reverse() <span class="keyword">as</span> r:</span><br><span class="line">	print(r)  <span class="comment"># 因为字符串已经被倒序过，所以这里输出 &amp;#39;Enter context&amp;#39;</span></span><br><span class="line">	print(&amp;<span class="comment">#39;bestswifter&amp;#39;) # 输出 &amp;#39;retfiwstseb&amp;#39;</span></span><br><span class="line">	<span class="keyword">raise</span> AttributeError <span class="comment"># 输出 &amp;lt;class &amp;#39;AttributeError&amp;#39;&amp;gt;  &amp;lt;traceback object at 0x10bcb45c8&amp;gt;</span></span><br><span class="line">	print(&amp;<span class="comment">#39;will not be print&amp;#39;)  # 因为发生了异常，所以不会执行这一行</span></span><br></pre></td></tr></table></figure>

在进入上下文的时候，我们用自定义的方法替换了系统的标准输出，所以上下文中所有的输出都是倒序的。直到上下文结束时才换回来。

`__exit__` 方法有三个参数，分别表示异常的类型，异常的实例，以及发生异常处的调用栈。如果在 `with` 块中发生了异常，异常处后面的代码都不会执行。`__exit__` 方法如果返回 True，表示异常已经被正确处理，否则异常会向上冒泡到 `with` 代码块外面。

#### 4.4.3 标准库中的上下文

使用标准库中的装饰器可以节省一些模板代码，`__enter__` 和 `__exit__` 方法可以写在一起，以 `yield` 为分界线：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Reverse</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">reverse_write</span><span class="params">(content)</span>:</span></span><br><span class="line">		original_write(content[::<span class="number">-1</span>])</span><br><span class="line">	</span><br><span class="line">	original_write = sys.stdout.write</span><br><span class="line">	sys.stdout.write = reverse_write</span><br><span class="line">	<span class="keyword">yield</span> &amp;<span class="comment">#39;Enter context&amp;#39;[::-1] # 下一行开始，是 __exit__ 的逻辑</span></span><br><span class="line">	sys.stdout.write = original_write</span><br></pre></td></tr></table></figure>

`@contextlib.contextmanager` 的缺点是无法通过 `return True/False` 来控制是否需要冒泡异常，必须把 `yield` 代码放到 `try catch` 中。

## 5. 其他 Python 特色

### 5.1 多线程与GIL

#### 5.1.1 多线程

多线程操作一般通过 `threading` 模块来完成，启动一个线程其实就是把线程要执行的函数传递到 `Thread` 类的初始化方法中，然后调用 `Thread` 实例的 `start` 方法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">think</span><span class="params">()</span>:</span></span><br><span class="line">	print(&amp;<span class="comment">#39;start thinking in thread: &amp;#39; + threading.current_thread().name)</span></span><br><span class="line">	sleep(<span class="number">1</span>)</span><br><span class="line">	print(&amp;<span class="comment">#39;end thinking&amp;#39;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	t = threading.Thread(target = think)</span><br><span class="line">	t.start()</span><br><span class="line">print(&amp;<span class="comment">#39;Exit&amp;#39;)</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-1</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-2</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-3</span></span><br><span class="line"><span class="comment"># Exit</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br></pre></td></tr></table></figure>

从输出结果来看，Python 的线程都是异步执行，如果要同步执行某个线程，需要调用线程的 `join` 方法，表示阻塞当前线程，直到整个线程退出为止：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">	t = threading.Thread(target = think)</span><br><span class="line">	t.start()</span><br><span class="line">	t.join()</span><br><span class="line">print(&amp;<span class="comment">#39;Exit&amp;#39;)</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-1</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-2</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># start thinking in thread: Thread-3</span></span><br><span class="line"><span class="comment"># end thinking</span></span><br><span class="line"><span class="comment"># Exit</span></span><br></pre></td></tr></table></figure>

#### 5.1.2 线程锁

像 `a += 1` 这样的语句，是线程不安全的，因为它不是原子性操作。如果想保证某段代码最多同时被一个线程执行，可以给它加锁：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">think</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> i</span><br><span class="line">	lock.acquire()</span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line">	lock.release()</span><br></pre></td></tr></table></figure>

注意到这里的加锁和释放锁又是上下对应的模板代码，这类代码都可以用 `with` 块配合上下文解决。Python 提供了现成的写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">think</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">global</span> i</span><br><span class="line">	<span class="keyword">with</span> lock:</span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>

在 `threading.Lock` 类的 `__exit__` 方法中会自动释放锁。

#### 5.1.3 GIL

我们知道 Python 这种动态语言是由解释器在运行时动态解释并执行的，如果有多个线程同时执行，就意味着有多个解释器也在运行。为了保证解释器自己的线程安全性，有些  Python 解释器（比如最常见的 CPython）采用了一种很暴力的解决方式：**全局锁**，也就是 Global Interpreter Lock， GIL。再次声明，GIL 不是 Python 的特性，仅仅是特定解释器的特性，比如另一个解释器 JPython 就没有 GIL，不过 CPython 是绝大多数场景下默认的 Python 的解释器，所以有人可能会把 GIL 与 Python 混为一谈。

GIL 最直接的副作用就是严重影响多线程的性能，因为同一时刻只有一个线程能获得锁。GIL 可以用如下伪代码表示：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    acquire GIL</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        do_something()</span><br><span class="line">    release GIL</span><br></pre></td></tr></table></figure>

当某个线程因为睡眠、IO 或超时释放 GIL 后，从代码中可以看到，它距离再次获得 GIL 仅有一条指令。所以在实际运行时，有很大可能是一个线程不断的释放、获取 GIL，而别的线程一直在等待。由于线程上下文切换存在一定的开销，多个 CPU 密集型的线程同时运行，性能反而比在同一个线程内运行要低。

如果是多个 IO 密集型的线程同时运行，GIL 不会影响性能，因为线程在执行 IO 操作时会主动释放 GIL 锁，因此会出现没有线程获取 GIL 锁（因为大家都在 IO），谁结束了 IO 谁就使用线程的情况。不过需要注意的是，多个 IO 密集型的线程和一个 CPU 密集型线程同时执行时，性能也会受到影响。因为之前解释过，CPU 密集型的线程倾向于一直占有 GIL，导致 IO 密集型线程在 IO 结束后无法立刻获取 GIL，空等一段时间。

具体的测试结果可以参考：[Python的GIL是什么鬼，多线程性能究竟如何](http://cenalulu.github.io/python/gil-in-python/)。

如果想要避免 GIL 对性能的影响，有以下几种思路：

1. 多个 IO 密集型线程不受影响，但不要混入 CPU 密集型线程
2. 使用 JPython 这样的解释器代替 CPython，但这样做就无法再使用社区已有的 C 语言模块
3. 使用多进程，多个进程有多个 GIL，自然就互不干扰

#### 5.1.4 多进程

Python 中实现多进程非常简单，因为接口与多线程基本一致：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(i)</span>:</span></span><br><span class="line">	print(i)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">	p = multiprocessing.Process(target=run_proc, args=(i,))</span><br><span class="line">	p.start()</span><br><span class="line">print(&amp;<span class="comment">#39;End&amp;#39;)</span></span><br></pre></td></tr></table></figure>

多进程中没有锁的概念，因为不同的线程可以共享进程的堆，而不同的进程就没有应用层面可以共享的内容了，只能依赖于操作系统提供的 API，比如共享内存、socket、管道、消息队列等。

以消息队列为例，简单展示下进程间共享数据：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_proc</span><span class="params">(q)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">		i = q.get()</span><br><span class="line">		i += <span class="number">1</span></span><br><span class="line">		q.put(i)</span><br><span class="line">		print(i)</span><br><span class="line">	</span><br><span class="line">q = Queue()</span><br><span class="line">q.put(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p1 = Process(target=run_proc, args=(q,))</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p2 = Process(target=run_proc, args=(q,))</span><br><span class="line">p2.start()</span><br></pre></td></tr></table></figure>

每个进程都会从消息队列中读取变量，加一后放回队列，所以输出结果是 1 到 20。如果不用消息队列来共享，每个进程的变量 `i` 都是独立的，会输出两次 1 到 10。

### 5.2 我眼中的  Python
#### 5.2.1 Python 是动态强类型语言

这句话其实说了两个概念： **Python 是动态类型语言**，以及 **Python 是强类型语言**，很多人会把这两组概念混淆。

首先，动/静态类型语言的区别在于类型被确认的时机。以 C 这类语言来说，编译器会检查变量的类型，比如 `int a = &quot;hello&quot;;` 就无法通过编译，这就说明 C 语言是静态类型语言。而对于 Python 来说，`a = &quot;hello&quot;` 直到运行时，才会确定 a 引用的对象的类型是 `str`。

动态类型语言并非看上去没有类型标记那么简单，一方面，Swift 这样的语言支持类型推导，所以支持 `var s = &quot;hello&quot;` 这种写法，但这并不意味着 Swift 就是动态类型语言了，因为它的类型判断还是在编译期完成的，只不过编译器更加智能，可以推导出来而已。

另一方面，不在编译期检查类型并不意味着动态类型语言对类型的校验就是宽松的，这是另一个维度的衡量指标。如果语言对类型的校验很宽松，支持隐式转换，我们就称这种语言是 **“弱类型语言”**，否则就是**强类型语言**。强类型语言更严格，一定程度上语法会更啰嗦，弱类型语言代码更简单，更脚本化。以输出 **&quot;My age is 22&quot;** 为例：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">22</span></span><br><span class="line">string = &amp;<span class="comment">#39;My age is &amp;#39;</span></span><br><span class="line">print(string + str(number))</span><br></pre></td></tr></table></figure>

这里必须把数字先转为字符串，才能和别的字符串拼接，这是因为 `str` 类的 `__add__` 函数只支持 `str` 类型的参数。可以看到，虽然数字（或者其他实现了 `__str__` 方法的自定义类）可以转为字符串，但这种转换必须是显式写明的，Python 并不支持隐式转换。

但用别的语言，比如 JavaScript 来实现类似的逻辑就非常简单了：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">22</span></span><br><span class="line">string = &amp;#39;My age is &amp;#39;</span><br><span class="line"><span class="built_in">console</span>.log(string + number);</span><br></pre></td></tr></table></figure>

可见，JavaScript 支持从数字到字符串的隐式转换。但这种隐式的转换也不一定是好事，比如再举一个例子：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">22</span></span><br><span class="line">string = &amp;#39;2&amp;#39;</span><br><span class="line"><span class="built_in">console</span>.log(string + number)</span><br></pre></td></tr></table></figure>

它的输出结果是 &#39;222&#39;，可见是把数字隐式的转成了字符串，然而如果我的本意是要把字符串转数字呢，比如这段代码在 PHP 中的输出就是 24：

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;?php</span><br><span class="line">	$n = <span class="number">22</span>;</span><br><span class="line">	$s = &amp;quot;<span class="number">2</span>&amp;quot;;</span><br><span class="line">	<span class="keyword">print</span> $s + $n</span><br><span class="line">?&amp;gt;</span><br></pre></td></tr></table></figure>

因此，关于语言的强/弱类型，我想可以总结两点：

1. 类型的强弱是一个相对的概念，不像动态/静态类型那样有明确的判断标准。因为隐式转换可以发生在很多地方，有的语言支持的隐式转换场景很多，有的支持的场景很少，所以一般来说我们只能说某个语言的类型比较强（弱）或者说某个语言的类型比另一个语言更强（弱）。
2. 强弱类型没有优劣之分，强类型语言更严谨，不容易出现 Bug，但是代码复杂，书写成本高。弱类型语言更脚本化，写起来很简单，但很多规则并不那么显然，增加了学习成本。

#### 5.2.2 开发效率高

Python 中到处都是**鸭子类型**的实践：不关注一个类的类型本身，而是关注这个类具有什么能力。比如我们会发现，数组和字符串的下标访问高度类似，这在很多静态类型语言中是几乎不可能发生的。很多自定义类因为使用了多继承、迭代器、双下方法，使用起来与内置的数据类型基本上没有区别。

此外，脚本语言的一个主要特色就是 handy，理论上来说 Python 能做的事，没什么是 C 做不到的。然而我们希望用简单的 API，用文本编辑器花上一两分钟就写出来一个脚本，而不是查阅手册，打开 IDE，编译以后再执行。所以 Python 提供了很多语言层面的支持，比如推导、else 块、切片和功能强大的内置函数等。

另外，Python 具备强大的元编程能力，装饰器、高阶函数、函数内省、元类具有非常强的内省和动态能力。内省帮助我们在运行时获取足够多的信息，动态性帮助我们实现很多很有意思的能力。因此我们看到 Python 中很少有模板代码，虽然内部实现有时候相对晦涩难懂，但对外的接口则是高度统一。

#### 5.2.3 对新人不是很友好

开发效率高的背后也有隐患，简洁高效的语法可能意味着过度封装，因此 Python 的性能经常遭到抨击（但是脚本语言并不应该考虑这一点）。

鸭子类型容易带来太多的魔术方法。在 Java 中，一切都有迹可循，某个类能调用方法，一定是因为它自己实现了方法，或者从接口、父类那里继承来了。而 Python 不一样，方法的调用和方法的真正实现之间也许没有语言层面的直接关联，而是依靠文档规范、魔术方法或者约定。这给新手阅读 Python 代码带来了极大的困难，通常无从下手，连搜索什么关键字都不知道，这也是本文写作的目的之一。

元编程能力允许用户直接享受到大牛们封装好的库和能力，但也容易被滥用。元编程学习门槛高，而且通常实现一个需求有不止一种方法。如果大家各自造轮子，很可能质量参差不齐，互相理解起来也比较困难。

### 5.3 其它 Python 技巧

很多时候我们从网上摘抄下来的代码仅仅刚好能工作，但对它的细节却不是很了解。本节主要列出一些常用的 Python 代码或者技巧并用实际的例子解释各处细节，持续更新中。

#### 5.3.1 文件读写

读取文件时，一般会这样写代码：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(&amp;<span class="comment">#39;path_to_file&amp;#39;, &amp;#39;r&amp;#39;) as f:</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">	    print(line)</span><br><span class="line"><span class="comment"># first line</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># second line</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># third line</span></span><br></pre></td></tr></table></figure>

`open` 函数的第二个参数表示打开模式，`r` 表示读取，`w` 表示写入，会删除原来的所有内容，`a` 表示在文件后面追加写入。

一般来说不要用 `readlines` 读取文件，因为如果文件特别大， 读出来的数组可能会非常占用内存。我们会看到输出结果一般都有多个空行，这是因为每行的结尾都有 &#39;\n&#39; 换行符，而且 `print` 函数自己就会换行。如果想要更美观的输出，可以用 `replace` 或者 `rstrip` 函数干掉换行符。

如果我们用 `open(&#39;path_to_file&#39;. &#39;rb&#39;)` 来打开文件，就可以读取到原来的二进制：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(&amp;<span class="comment">#39;file_to_path&amp;#39;, &amp;#39;rb&amp;#39;) as f:</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">	    print(line)</span><br><span class="line"><span class="comment"># b&amp;#39;first line\n&amp;#39;</span></span><br><span class="line"><span class="comment"># b&amp;#39;second line\n&amp;#39;</span></span><br><span class="line"><span class="comment"># b&amp;#39;third line\n&amp;#39;</span></span><br></pre></td></tr></table></figure>

这里我们本来应该看到的是各个字母的 UTF-8 编码后的二进制，不过在打印的时候被系统自动转成字母了。在文件不是UTF-8 编码时，一定要用二进制格式去打开文件并且自行解码，否则 Python 会尝试用 UTF-8 去解码，极有可能会因为无法解码而导致报错。

我们可以试着把二进制写入到文件中：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &amp;<span class="comment">#39;hello world&amp;#39;</span></span><br><span class="line">b = [x.encode(&amp;<span class="comment">#39;utf16&amp;#39;) for x in s]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(&amp;<span class="comment">#39;path_to_file&amp;#39;, &amp;#39;wb&amp;#39;) as f:</span></span><br><span class="line">	f.writelines(b)</span><br></pre></td></tr></table></figure>

`writelines` 函数的参数是数组，相当于对数组中的每个元素调用了 `write()` 方法。

感兴趣的读者可以试着分别用 `r` 和 `rb` 去打开文件，感受其中的区别。

#### 5.3.2 JSON 读写

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = &#123;&amp;<span class="comment">#39;name&amp;#39;: &amp;#39;bestswifter&amp;#39;, &amp;#39;age&amp;#39;: 22&#125;</span></span><br><span class="line">json.dumps(d)  <span class="comment"># 返回字符串：&#123;&amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;, &amp;quot;age&amp;quot;: 22&#125;</span></span><br></pre></td></tr></table></figure>

最简单的对象转 JSON 通过 `json` 模块的 `dumps` 函数来完成，最后一个字母 s 表示生成字符串，也可以用 `dump(data, fp)` 来把内容写入文件：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = &#123;&amp;<span class="comment">#39;name&amp;#39;: &amp;#39;bestswifter&amp;#39;, &amp;#39;age&amp;#39;: 22&#125;</span></span><br><span class="line"><span class="keyword">with</span> opne(&amp;<span class="comment">#39;path_to_file&amp;#39;, &amp;#39;w&amp;#39;) as f:</span></span><br><span class="line">    json.dump(d, f)</span><br></pre></td></tr></table></figure>

调用 `dumps` 参数时，有几个命令可能会派上作用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = &#123;&amp;<span class="comment">#39;name&amp;#39;: &amp;#39;bestswifter&amp;#39;, &amp;#39;age&amp;#39;: 22&#125;</span></span><br><span class="line">json.dumps(d, skipkeys=<span class="keyword">True</span>, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&#123;</span></span><br><span class="line"><span class="comment">#    &amp;quot;age&amp;quot;: 22,</span></span><br><span class="line"><span class="comment">#    &amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>

其中，`sort_keys` 表示对字典的键排序，这样输出结果一定是固定的，`indent` 用于控制多少个空格缩进，可以增加可读性。`skipkeys` 表示如果字典的键不是字符串，就忽略这一条记录。

JSON 支持的类型很有限，只有 `None` ， `bool` ， `int` ， `float` 和 `str` 这五种基本类型和包含这些类型的字典或者数组。自定义的对象如果转成 JSON 默认会报错，我们可以实现一个通用函数，读取任意对象的 `__dict__`，这样就可以用于 JSON 化了：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serialize_instance</span><span class="params">(obj)</span>:</span></span><br><span class="line">	d = &#123; &amp;<span class="comment">#39;class&amp;#39; : type(obj).__name__ &#125;</span></span><br><span class="line">	d.update(vars(obj))</span><br><span class="line">	<span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line"></span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;, 22)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接 dumps(bs) 会得到这个报错：</span></span><br><span class="line"><span class="comment"># TypeError: Object of type &amp;#39;Person&amp;#39; is not JSON serializable</span></span><br><span class="line"></span><br><span class="line">json.dumps(serialize_instance(bs), skipkeys=<span class="keyword">True</span>, sort_keys=<span class="keyword">True</span>, indent=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#&#123;</span></span><br><span class="line"><span class="comment">#    &amp;quot;age&amp;quot;: 22,</span></span><br><span class="line"><span class="comment">#    &amp;quot;class&amp;quot;: &amp;quot;Person&amp;quot;,</span></span><br><span class="line"><span class="comment">#    &amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>

或者更优雅的做法是使用 3.3.3 节中介绍的 Mixin：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意 Mixin 的原则，功能要单一，实现上不能依赖子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Serializable</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self)</span>:</span></span><br><span class="line">		d = &#123; &amp;<span class="comment">#39;class&amp;#39; : type(self).__name__ &#125;</span></span><br><span class="line">		d.update(vars(self))</span><br><span class="line">		<span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 混入 Serializable 立刻就有了转字典的能力，或者也可以重写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Serializable)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line"></span><br><span class="line">bs = Person(&amp;<span class="comment">#39;bestswifter&amp;#39;, 22)</span></span><br><span class="line">	</span><br><span class="line">json.dumps(bs.serialize())</span><br></pre></td></tr></table></figure>

解析 JSON 字符串的方法也是类似的，调用 `json.loads()` 函数即可：


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">s = &amp;<span class="comment">#39;&#123;&amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;, &amp;quot;age&amp;quot;: 22&#125;&amp;#39;</span></span><br><span class="line">d = json.loads(s)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>

这里的 `loads` 表示从字符串中读取 JSON，也可以用 `load` 函数从文件中读取。不过有时候我们更希望把读取出来的字典直接转成对象。这需要调用者提供一个函数，把字典转换成对象，一般需要用到元编程。下面是一个简单的示例：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deserializable</span>:</span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(cls, d)</span>:</span></span><br><span class="line">		clsname = d.pop(&amp;<span class="comment">#39;classname&amp;#39;, None)</span></span><br><span class="line">		<span class="keyword">if</span> clsname:</span><br><span class="line">			obj = cls.__new__(cls)</span><br><span class="line">			<span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">				setattr(obj, key, value)</span><br><span class="line">			<span class="keyword">return</span> obj</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Deserializable)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		self.age = age</span><br><span class="line"></span><br><span class="line">s = &amp;<span class="comment">#39;&#123;&amp;quot;age&amp;quot;: 22, &amp;quot;name&amp;quot;: &amp;quot;bestswifter&amp;quot;&#125;&amp;#39;</span></span><br><span class="line">bs = json.loads(s, object_hook = Person.deserialize)</span><br><span class="line">print(bs)</span><br></pre></td></tr></table></figure>

`Person` 类通过混入 `Deserializable` 具备了反序列化的能力，只要把这个函数传入 `loads` 方法中即可，`deserialize` 函数的第一个参数是调用类，第二个参数是解析出来的字典。这段代码其实等价于：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = json.loads(s)</span><br><span class="line">bs = Person.deserialize(d)</span><br></pre></td></tr></table></figure>

#### 5.3.3 执行 Shell

Python 中调用 `Shell` 命令的方法有很多种，我最常用的是 `os.popen` 函数，它的返回结果是文件句柄，因此可以调用 `readlines` 函数：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">r = os.popen(&amp;<span class="comment">#39;pwd&amp;#39;)</span></span><br><span class="line">print(r.readlines())</span><br><span class="line"><span class="comment"># 输出 [&amp;#39;/Users/zxy/Desktop\n&amp;#39;]</span></span><br></pre></td></tr></table></figure>

这个结果表示 Shell 命令的输出只有一行，且内容是 `/Users/zxy/Desktop`。

### 5.4 Python 模块化

#### 5.4.1 Python 中的模块

Python 不仅可以用来编写短小精悍的脚本文件，也能用来开发大型项目，这就需要把代码合理的写在各个模块中，确保**高内聚、低耦合**。

每一个 Python 文件都是一个模块，我们知道 `import` 关键字可以导入系统模块，也可以用 `import module_name` 的写法导入别的模块。

假设文件路径如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package</span><br><span class="line">|-- main.py</span><br><span class="line">|-- module.py</span><br></pre></td></tr></table></figure>

那么可以这样引用别的模块 

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In module.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># In main.py</span></span><br><span class="line"><span class="keyword">import</span> module</span><br><span class="line">modul1.add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 返回 3</span></span><br></pre></td></tr></table></figure>

#### 5.4.2 模块查找顺序

对于被 `import` 的模块，Python 首先会检查它是不是内置的模块，比如我们把刚刚的 `module.py` 文件重命名为 `time.py`，再引用：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 报错：AttributeError: module &amp;#39;time&amp;#39; has no attribute &amp;#39;add&amp;#39;</span></span><br></pre></td></tr></table></figure>

这是因为 Python 最先查找内置的模块，我们打印 time 模块就可以看到 `&lt;module &#39;time&#39; (built-in)&gt;` ，说明这是一个内置模块。PS：`string` 模块不是内置模块，坑了我一晚上。

如果导入的不是内置模块，Python 会依次在 `sys.path` 这个数组中的每个路径中寻找。按照查找优先级，它由三个部分组成：

1. Python 执行的入口文件（比如这里的 `main.py`）所在的路径
2. 系统的环境变量 `$PYTHONPATH` 所表示的目录
3. `site` 路径，也就是 `/usr/local/lib/python3.5/site-packages` 这种。

如果我们把 `time.py` 改名为 `string.py` 就会得到正常结果，这是因为它属于第一部分，而 Python 默认的 `string` 模块位于第三部分，优先级比较低。

一般来说，Python 工程中的文件都能在第一部分被找到，而 `pip` 安装的第三方库位于第三部分。环境变量 `PYTHONPATH` 一般都是空，但不排除某些 IDE，比如 PyCharm 会修改它。这种行为很危险，因为能在 PyCharm 中编译通过很可能是借助环境变量才找到了模块，一旦迁移到别的环境就无法编译，我似乎遇到过这个坑，将本地可以运行的代码上传到 VPS 以后就找不到模块了。

#### 5.4.3 包与 \__init__.py

当代码量进一步膨胀时，可能多个模块也无法合理的拆分逻辑了，我们可以把实现某个特定功能的若干个模块组合起来，形成一个包。包在逻辑上可以理解为若干个模块的组合， 在物理上讲，包都是文件夹，模块都是文件。

注意，**文件夹不都是包，只有存在 \__init__.py 文件的文件夹才是模块！**

在导入时，我们可以导入类，也可以导入类里面的全局变量或者全局函数，还可以导入包：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package</span><br><span class="line"><span class="keyword">import</span> module</span><br></pre></td></tr></table></figure>

如果类名和变量名太长，可以用 as 关键字重命名：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module.var <span class="keyword">as</span> v</span><br><span class="line"><span class="keyword">import</span> module.func <span class="keyword">as</span> f</span><br></pre></td></tr></table></figure>

一般来说导入包并没有太大的作用，后续还是需要导入包中的模块。如果确实需要直接用到包中的函数或者变量，可以把它定义在 `__init__.py` 文件中。

`__init__.py` 用于把一个目录标记为包，如果没有这个文件，目录又和 Python 模块重名，就会调用到 Python 的模块，假设文件层级如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">|-- main.py</span><br><span class="line">|-- string</span><br><span class="line">  |-- module1.py</span><br></pre></td></tr></table></figure>

我们尝试在 `main.py` 中导入包：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">print(string)</span><br><span class="line"><span class="comment"># &amp;lt;module &amp;#39;string&amp;#39; from &amp;#39;/usr/local/Cellar/python3/3.5.2_3/Frameworks/Python.framework/Versions/3.5/lib/python3.5/string.py&amp;#39;&amp;gt;</span></span><br></pre></td></tr></table></figure>

会发现导入的其实是模块。虽然这里 `string` 目录如果是一个文件，它的查找优先级会高于 Python 中的非内置模块，但如果当做包来导入，Python 就无法识别了。解决方案也很简单，给 `string` 目录添加一个 `__init__.py` 文件，把 `string` 目录标记为包即可。

除了标记目录为包以外，`__init__.py` 文件还可以定义一个 `__all__` 变量，用于批量导入，假设目录层级如下：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">|-- main.py</span><br><span class="line">|-- string</span><br><span class="line">  |-- module1.py</span><br><span class="line">  |-- module2.py</span><br><span class="line">  |-- module3.py</span><br></pre></td></tr></table></figure>

先在 `__init__` 文件中定义要批量导入的模块：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In __init__.py</span></span><br><span class="line">__all__ = [&amp;<span class="comment">#39;module1&amp;#39;, &amp;#39;module2&amp;#39;]</span></span><br></pre></td></tr></table></figure>

然后在 `main.py` 文件中用星号 `*` 批量导入：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> *</span><br><span class="line">print(module1) <span class="comment"># &amp;lt;module &amp;#39;string.module1&amp;#39; from &amp;#39;/Users/zxy/Desktop/string/module1.py&amp;#39;&amp;gt;</span></span><br><span class="line">print(module2) <span class="comment"># &amp;lt;module &amp;#39;string.module1&amp;#39; from &amp;#39;/Users/zxy/Desktop/string/module1.py&amp;#39;&amp;gt;</span></span><br><span class="line">print(module3) <span class="comment"># NameError: name &amp;#39;module3&amp;#39; is not defined</span></span><br></pre></td></tr></table></figure>

在打印 `module3` 的时候会报错，这是因为 `__all__` 变量没有暴露它，需要我们手动导入。

#### 5.5.4 相对导入和绝对导入

接上面的例子，假设我们在 `module2` 中要引用 `module1`，代码如下：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string.module1</span><br></pre></td></tr></table></figure>

这样写没有问题，因为有 `__init__.py` 文件把目录标记为包，所以可以正确识别。然而如果我们的入口不是 `main.py`，而是直接执行 `python3 module2.py`，就无法识别到父目录里面的 `__init__.py` 文件了。此时可以采用相对导入：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> module1</span><br></pre></td></tr></table></figure>

一个点表示当前的包，两个点就表示上一个包，以此类推……；相对导入只能使用 `from import` 的语法，而绝对路径导入则不受限制，两种写法皆可。

相对路径的缺点在于容易丢失命名空间，比较这两种写法：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line">bar()     <span class="comment"># bar 在哪里定义？</span></span><br><span class="line"><span class="keyword">import</span> foo.bar</span><br><span class="line">foo.bar() <span class="comment"># 在 foo 模块中定义</span></span><br></pre></td></tr></table></figure>

前者丢失了 `bar` 的来源，而后一种写法不会。

#### 5.4.5 运行 Python 脚本

每个 Python 脚本既可以直接用 `python xxx.py` 命令执行，也可以被别的 Python 文件当做模块引入。对于一个项目来说，入口文件只有一个（就像 C 语言的 `main.c` 文件一样），其他的文件都作为模块对外提供功能。

我们也可以用 `python` 命令执行一个文件夹，此时会自动运行文件夹中的 `__main__.py` 文件。 

假设我们写了一个函数，可以爬取给定 URL 的标题：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTitle</span><span class="params">(url)</span>:</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># return html.title</span></span><br><span class="line"></span><br><span class="line">getTitle(&amp;<span class="comment">#39;https://baidu.com&amp;#39;)</span></span><br></pre></td></tr></table></figure>

直接执行或者在别的模块中导入这个文件都会调用 `getTitle` 函数，然而我们希望的效果是只有直接执行这个文件时才执行函数，被导入时只要提供方法即可。或者可以通过判断全局变量 `__name__` 来完成：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTitle</span><span class="params">(url)</span>:</span></span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line">	<span class="comment"># return html.title</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__ == &amp;<span class="comment">#39;__main__&amp;#39;:</span></span><br><span class="line">    print(getTitle(&amp;<span class="comment">#39;https://baidu.com&amp;#39;))</span></span><br></pre></td></tr></table></figure>

只有当直接运行文件时，全局变量 `__name__` 的值才是 `__main__`，因此当这个模块被导入时，`if` 语句中的代码就不会被调用。

`python` 作为一个 Shell 命令，可以和其他系统命令通过管道联系在一起，比如实现一个 `show_file.py`：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> sys.stdin:</span><br><span class="line">	print(file)</span><br></pre></td></tr></table></figure>

然后执行命令行脚本：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | python3 show_file.py</span><br></pre></td></tr></table></figure>

将会打印出当前目录中所有文件的名字。每个 Shell 脚本都有返回值， 用于表示脚本是否成功，通过命令 `echo $?` 可以查看上一条命令的返回结果，比如：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./create_file.sh</span><br><span class="line"><span class="keyword">if</span> [ $? = 0 ] ; <span class="keyword">then</span>  <span class="comment"># 只有成功创建文件，才会写入内容</span></span><br><span class="line">    ./write_to_file.sh</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> &amp;quot;error&amp;quot;</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

由于脚本命令的返回值具有重要的参考价值，因此我们的 Python 脚本也要遵循这一规范，这样别的命令可以很容易的知道 Python 脚本的执行情况。因此，标准的入口文件总是应该套用这个模板：

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="comment"># 执行某些逻辑</span></span><br><span class="line">	<span class="comment"># 如果发生错误</span></span><br><span class="line">	<span class="comment"># sys.exit(1)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__ == &amp;<span class="comment">#39;__main__&amp;#39;:</span></span><br><span class="line">	sys.exit(main())</span><br></pre></td></tr></table></figure>

### 5.5 venv

#### 5.5.1 什么是 venv

假设我们开发程序 A 是用到了 `pip install module1==1.0`，也就是安装了 `module1` 这个第三方库的 1.0 版本，同时开发程序 B 用到了这个第三方库的 2.0 版本，但是在 `/usr/local/lib/python3.5/site-packages` 这个目录下只能留一份，那么 A 和 B 就无法分别使用两个版本的第三方库了。

于是诞生了虚拟环境（virtualenv，简称 venv）的概念，它会为每个应用单独提供一份 Python 的运行环境，从而起到隔离的效果。

执行以下命令：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenv</span><br><span class="line">virtualenv <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

这首先会安装 `virtualenv` 这个工具模块，然后在当前目录下新建一个虚拟环境 `test`，其实也就是一个目录。

#### 5.5.2 venv 结构初探

观察目录的组成可以发现，主要是有三个文件夹：`bin`、`include` 和 `lib`。

`bin` 目录下主要是一些可执行文件，比如虚拟环境的激活与退出，以及 Python 和 pip 的可执行文件。比如：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> bin/active</span><br><span class="line"><span class="comment"># 现在开始，虚拟环境已经生效，安装的模块都在这个文件夹内部</span></span><br><span class="line">pip instal module1</span><br><span class="line">pip instal module2</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">deactive</span><br></pre></td></tr></table></figure>

`inlcude` 目录下的会通过软连接，导入一些 C 语言的头文件，暂时不清楚作用。

`lib` 目录下引用了 Python 自带的一些模块，以及第三方包 `site-packages` 文件夹的拷贝。如果执行的是 `virtualenv --no-site-packages test` 将会得到一个不含第三方包，纯净的虚拟环境。

#### 5.5.3 工作原理

其实 venv 的工作原理非常简单，完全集中在 `bin/active` 这个简单的脚本中，它的核心部分如下：

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">deactive</span></span> () &#123;</span><br><span class="line">    <span class="comment"># 恢复环境</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VIRTUAL_ENV=&amp;quot;/Users/zxy/Desktop/testvenv&amp;quot;</span><br><span class="line"><span class="built_in">export</span> VIRTUAL_ENV</span><br><span class="line"></span><br><span class="line">_OLD_VIRTUAL_PATH=&amp;quot;<span class="variable">$PATH</span>&amp;quot;</span><br><span class="line">PATH=&amp;quot;<span class="variable">$VIRTUAL_ENV</span>/bin:<span class="variable">$PATH</span>&amp;quot;</span><br><span class="line"><span class="built_in">export</span> PATH</span><br></pre></td></tr></table></figure>

可见它把当前目录标记为 `VIRTUAL_ENV`，然后添加到系统的 `PATH` 最前面，这样我们执行 `pip` 命令时，第三方的包就会被安装虚拟环境内的 `site-packages` 文件夹中，不会与系统的干扰。

## 6 学习方向

由于作者水平和文章篇幅有限，不可能所有知识点都面面俱到，如果本文激起了你对 Python 的兴趣，我有几个建议或许能帮助你进一步的提高自己的 Python 水平，按照重要级的降序排列：

1. 先确保本文中的所有 Demo 都自己实现过一遍，看代码和写代码是两种截然不同的体验
2. 了解 Python 标准库中提供的函数，避免重复造轮子，更高效的完成需求
3. 尝试用 Tornado、Flask、Django、MITM 等著名的 Python 框架完成一些自己的需求，把 Python 知识与实践结合起来，有机会的话可以阅读这些框架的源码
4. 针对自己还不够了解的知识点，查找 Google 上的优秀博客

## 7 版本历史

#### 1.0.0

首次发布

#### 1.0.1

1. 改正了 1.1.2 节中的错别字，`精度` -&gt; `经度`，`维度` -&gt; `纬度`
2. 改正了 1.1.2 节中 `p.name` 错误的写成了 22 的问题
3. 改正了 1.2.2 节中单词拼写错误， `seddefault` -&gt; `setdefault`
4. 改正了 2.3 节中 `co_argcount` 值错误的问题，经过查阅[官方文档](https://docs.python.org/3/library/inspect.html#types-and-members)，这个值不会统计 `*`、`**` 和仅限关键字参数
5. 改正了 2.2.3 节中的输出结果，`[1, 2, 3]` -&gt; `(1, 2, 3)`
6. 改正了 3.4.1 节中的错别字，`元祖` -&gt; `元组`
7. 改正了 3.1.2 节中的代码错误，`a` -&gt; `b`
8. 改正了 1.2.5 节中的错误，`交集` -&gt; `并集`
9. 改正了 2.4.2 节中的语法错误 `decorate` -&gt; `@decorate`
10. 改正了 5.3.1 节中的代码错误 `r` -&gt; `rb`

## 参考资料：

1. [python属性查找 深入理解（attribute lookup）](http://www.cnblogs.com/xybaby/p/6270551.html)
2. [The Python 2.3 Method Resolution Order](https://www.python.org/download/releases/2.3/mro/)
3. [关于Python的Mixin模式](http://www.bjhee.com/python-mixin.html)
4. [The definitive guide on how to use static, class or abstract methods in Python](https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods)
5. [异步与回调的设计哲学](http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/)
6. [Python的GIL是什么鬼，多线程性能究竟如何](http://cenalulu.github.io/python/gil-in-python/)
7. [6.2 读写JSON数据](http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p02_read-write_json_data.html)
8. [Python 的 import 机制](https://loggerhead.me/posts/python-de-import-ji-zhi.html#_1)"></textarea>
                <div class="markdown topic-body" data-enable-update-html="" data-update-token="" data-url="/topic/1053427869/update_html">
                  <div class="xzl-topic-content" id="xzl-topic-content"><p>Python 是一门非常容易上手的语言，通过查阅资料和教程，也许一晚上就能写出一个简单的爬虫。但 Python 也是一门很难精通的语言，因为简洁的语法背后隐藏了许多黑科技。本文主要针对的读者是：</p>
<ol>
<li>毫无 Python 经验的小白</li>
<li>有一些简单 Python 经验，但只会复制粘贴代码，不知其所以然的读者</li>
<li>觉得单独一篇文章太琐碎，质量没保证，却没空读完一本书，但又想对 Python 有全面了解的读者</li>
</ol>
<p>当然， 用一篇文章来讲完某个语言是不可能的事情，我希望读完本文的读者可以：</p>
<ol>
<li>对 Python 的整体知识结构形成初步的概念</li>
<li>了解 Python 特有的知识点，比如装饰器、上下文、生成器等等，不仅会写 Demo，还对背后的原理有一定了解</li>
<li>避免 C++/Java 等风格的 Python 代码，能够写出地道的 Python 代码</li>
<li>能够熟练的使用 Python 编写脚本实现日常的简单需求，能够维护小型 Python 项目，能够阅读较复杂的 Python 源码</li>
</ol>
<p>如果以上介绍符合你对自己的定位，在开始阅读前，还需要明确几点：</p>
<ol>
<li>本文不会只介绍用法，那样太肤浅</li>
<li>本文不会深入介绍某个知识点，比如分析源码等，那样太啰嗦，我希望做一名引路人，描述各个知识点的概貌并略作引申，为读者指出下一步的研究方向</li>
<li>代码注释非常重要，一定要看，几乎所有的代码段都可以执行，<strong>强烈建议</strong>手敲一遍！</li>
</ol>
<p></p><div class="toc">
<ul>
<li><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section0" target="_blank" rel="noopener">0. 准备工作</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section1" target="_blank" rel="noopener">1. 数据结构</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section11" target="_blank" rel="noopener">1.1 数组</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section111" target="_blank" rel="noopener">1.1.1 列表推导</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section112" target="_blank" rel="noopener">1.1.2 元组</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section113" target="_blank" rel="noopener">1.1.3 数组切片</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section114" target="_blank" rel="noopener">1.1.4 循环与遍历</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section115" target="_blank" rel="noopener">1.1.5 魔术方法</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section12" target="_blank" rel="noopener">1.2 字典</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section121" target="_blank" rel="noopener">1.2.1 初始化字典</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section122" target="_blank" rel="noopener">1.2.2 查询字典</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section123" target="_blank" rel="noopener">1.2.3 遍历字典</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section124" target="_blank" rel="noopener">1.2.4 字典的魔术方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section125" target="_blank" rel="noopener">1.2.5 集合</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section13" target="_blank" rel="noopener">1.3 字符串</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section131" target="_blank" rel="noopener">1.3.1 字符串编码</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section132" target="_blank" rel="noopener">1.3.2 字符串的常用方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section133" target="_blank" rel="noopener">1.3.3 字符串格式化</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section134heredoc" target="_blank" rel="noopener">1.3.4 HereDoc</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section2" target="_blank" rel="noopener">2 函数</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section21" target="_blank" rel="noopener">2.1 函数是一等公民</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section22" target="_blank" rel="noopener">2.2 函数参数</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section221" target="_blank" rel="noopener">2.2.1 函数传参</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section222" target="_blank" rel="noopener">2.2.2 默认参数</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section223" target="_blank" rel="noopener">2.2.3 多参数传递</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section224" target="_blank" rel="noopener">2.2.4 参数分类</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section23" target="_blank" rel="noopener">2.3 函数内省</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section24" target="_blank" rel="noopener">2.4 装饰器</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section241" target="_blank" rel="noopener">2.4.1 设计模式的消亡</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section242" target="_blank" rel="noopener">2.4.2 装饰器的基本原理</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section243" target="_blank" rel="noopener">2.4.3 装饰器进阶</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section244" target="_blank" rel="noopener">2.4.4 装饰器工厂</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section3" target="_blank" rel="noopener">3 面向对象</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section31" target="_blank" rel="noopener">3.1 对象内存管理</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section311" target="_blank" rel="noopener">3.1.1 对象不是盒子</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section312" target="_blank" rel="noopener">3.1.2 默认浅复制</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section313" target="_blank" rel="noopener">3.1.3 弱引用</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section32python" target="_blank" rel="noopener">3.2 Python 风格的对象</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section321" target="_blank" rel="noopener">3.2.1 静态函数与类方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section322attribute" target="_blank" rel="noopener">3.2.2 属性 attribute</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section323property" target="_blank" rel="noopener">3.2.3 特性 property</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section324" target="_blank" rel="noopener">3.2.4 特性工厂</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section325" target="_blank" rel="noopener">3.2.5 属性描述符</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section326" target="_blank" rel="noopener">3.2.6 实例属性的查找顺序</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section33" target="_blank" rel="noopener">3.3 多继承</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section331" target="_blank" rel="noopener">3.3.1 多继承的必要性</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section332python" target="_blank" rel="noopener">3.3.2 Python 的多继承</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section333mixin" target="_blank" rel="noopener">3.3.3 Mixin</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section334" target="_blank" rel="noopener">3.3.4 抽象类</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section34" target="_blank" rel="noopener">3.4 元编程</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section341" target="_blank" rel="noopener">3.4.1 类工厂函数</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section342" target="_blank" rel="noopener">3.4.2 元类的概念</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section343" target="_blank" rel="noopener">3.4.3 元类的使用示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section4" target="_blank" rel="noopener">4. 流程控制</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section41else" target="_blank" rel="noopener">4.1 else</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section411forelse" target="_blank" rel="noopener">4.1.1 for else</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section412whileelse" target="_blank" rel="noopener">4.1.2 while else</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section413tryelse" target="_blank" rel="noopener">4.1.3 try else</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section42" target="_blank" rel="noopener">4.2 迭代器</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section421" target="_blank" rel="noopener">4.2.1 迭代器</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section422" target="_blank" rel="noopener">4.2.2 可迭代对象</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section423__iter__" target="_blank" rel="noopener">4.2.3 \__iter__ 方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section424" target="_blank" rel="noopener">4.2.4 标准迭代器</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section425" target="_blank" rel="noopener">4.2.5 初识生成器</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section43" target="_blank" rel="noopener">4.3 生成器</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section431" target="_blank" rel="noopener">4.3.1 生成器的定义</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section432" target="_blank" rel="noopener">4.3.2 生成器表达式</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section433" target="_blank" rel="noopener">4.3.3 协程</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section434" target="_blank" rel="noopener">4.3.4 预激协程</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section435" target="_blank" rel="noopener">4.3.5 标准库中的生成器函数</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section44" target="_blank" rel="noopener">4.4 上下文管理器</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section441with" target="_blank" rel="noopener">4.4.1 with 块</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section442" target="_blank" rel="noopener">4.4.2 自定义上下文</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section443" target="_blank" rel="noopener">4.4.3 标准库中的上下文</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section5python" target="_blank" rel="noopener">5. 其他 Python 特色</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section51gil" target="_blank" rel="noopener">5.1 多线程与GIL</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section511" target="_blank" rel="noopener">5.1.1 多线程</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section512" target="_blank" rel="noopener">5.1.2 线程锁</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section513gil" target="_blank" rel="noopener">5.1.3 GIL</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section514" target="_blank" rel="noopener">5.1.4 多进程</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section52python" target="_blank" rel="noopener">5.2 我眼中的  Python</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section521python" target="_blank" rel="noopener">5.2.1 Python 是动态强类型语言</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section522" target="_blank" rel="noopener">5.2.2 开发效率高</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section523" target="_blank" rel="noopener">5.2.3 对新人不是很友好</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section53python" target="_blank" rel="noopener">5.3 其它 Python 技巧</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section531" target="_blank" rel="noopener">5.3.1 文件读写</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section532json" target="_blank" rel="noopener">5.3.2 JSON 读写</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section533shell" target="_blank" rel="noopener">5.3.3 执行 Shell</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section54python" target="_blank" rel="noopener">5.4 Python 模块化</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section541python" target="_blank" rel="noopener">5.4.1 Python 中的模块</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section542" target="_blank" rel="noopener">5.4.2 模块查找顺序</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section543__init__py" target="_blank" rel="noopener">5.4.3 包与 \__init__.py</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section554" target="_blank" rel="noopener">5.5.4 相对导入和绝对导入</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section545python" target="_blank" rel="noopener">5.4.5 运行 Python 脚本</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section55venv" target="_blank" rel="noopener">5.5 venv</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section551venv" target="_blank" rel="noopener">5.5.1 什么是 venv</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section552venv" target="_blank" rel="noopener">5.5.2 venv 结构初探</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section553" target="_blank" rel="noopener">5.5.3 工作原理</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section6" target="_blank" rel="noopener">6 学习方向</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section7" target="_blank" rel="noopener">7 版本历史</a><ul>
<li><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section100" target="_blank" rel="noopener">1.0.0</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section101" target="_blank" rel="noopener">1.0.1</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section" target="_blank" rel="noopener">参考资料：</a></li>
</ul>
</li>
</ul>
</div>
<p></p>
<h2 id="section0">0. 准备工作</h2>
<p>请不要在学习 Python2 还是 Python3 之间犹豫了，除非你很明确自己只接触 Python2，否则就从 Python3 学起，新版本的语言总是意味着进步的生产力（Swift 和 Xcode 除外）。Python 2 和 3 之间语法不兼容，但这并不影响熟悉 Python3 的开发者迅速写出 Python 2 的代码，反之亦然。所以与其在反复纠结中浪费时间，不如立刻行动起来。</p>
<p>推荐使用 <strong>CodeRunner</strong> 来运行本文中的 demo，它比文本编辑器功能更强大，比如支持自动补全和断点调试，又比 PyCharm 轻量得多。</p>
<h2 id="section1">1. 数据结构</h2>
<h3 id="section11">1.1 数组</h3>
<h4 id="section111">1.1.1 列表推导</h4>
<p>如果要对数组中的所有内容做一些修改，可以用 for 循环或者 map 函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">small = []
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> array: 
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>:
</div></li><li><div class="code_line">        small.append(n * <span class="hljs-number">2</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">print(small)  <span class="hljs-comment"># [2, 4, 6]</span>
</div></li></ul></code></pre>
<p>比较地道的 Python 写法是使用列表推导：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">small = [n * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> array <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>]
</div></li></ul></code></pre>
<p><code>for in</code> 可以写两次，类似于嵌套的 for 循环，会得到一个笛卡尔积：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">signs = [<span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>]
</div></li><li><div class="code_line">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">ascii = [<span class="hljs-string">'{sign}{number}'</span>.format(sign=sign, number=number) 
</div></li><li><div class="code_line">        <span class="hljs-keyword">for</span> sign <span class="hljs-keyword">in</span> signs <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers]
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：['+1', '+2', '-1', '-2']</span>
</div></li></ul></code></pre>
<h4 id="section112">1.1.2 元组</h4>
<p>元组可以简单的理解为不可变的数组，也就是没有 <code>append</code>、<code>del</code> 等方法，一旦创建，就无法新增或删除元素，元素自身的值也不能改变，但元素内部的属性是否可变并不受元组的影响，这一点符合其他语言中的常识。</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, [])
</div></li><li><div class="code_line">t[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment"># 抛出错误 TypeError: 'tuple' object does not support item assignment</span>
</div></li><li><div class="code_line">t[<span class="hljs-number">1</span>].append(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 正常运行，现在的 t 是 (1, [2])</span>
</div></li></ul></code></pre>
<p>除了不可变性以外，有时候元组也会被当做不具名的数据结构，这时候元素的位置就不再是可有可无的了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">coordinate = (<span class="hljs-number">33.9425</span>, <span class="hljs-number">-118.408056</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># coordinate 的第一个位置用来表示经度，第二个位置表示纬度</span>
</div></li></ul></code></pre>
<p>在解析元组数据时，可以一一对应的写上变量名：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line">a, b = t <span class="hljs-comment"># a = 1, b = 2</span>
</div></li></ul></code></pre>
<p>有时候变量名比较长， 但我只关心其中某一个，可以这样写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line">a, _ = t <span class="hljs-comment"># a = 1</span>
</div></li></ul></code></pre>
<p>如果元组中元素特别多，即使挨个写下划线也比较累，可以用 \* 来批量解包：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
</div></li><li><div class="code_line">first, *middle, last = t
</div></li><li><div class="code_line"><span class="hljs-comment"># first = 1</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># middle = [2, 3, 4]</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># last = 5</span>
</div></li></ul></code></pre>
<p>当然，如果元素数量较多，含义较复杂，我还是建议使用具名元组：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> collections
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">People = collections.namedtuple(<span class="hljs-string">'People'</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>])
</div></li><li><div class="code_line">p = People(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'22'</span>)
</div></li><li><div class="code_line">p.name <span class="hljs-comment"># bestswifter</span>
</div></li></ul></code></pre>
<p>具名元组更像是一个不能定义方法的简化版的类，能提供友好的数据展示。</p>
<p>元组的一个小技巧是可以避免用临时变量来交换两个数的值：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = <span class="hljs-number">1</span> 
</div></li><li><div class="code_line">b = <span class="hljs-number">2</span>
</div></li><li><div class="code_line">a, b = b, a
</div></li><li><div class="code_line"><span class="hljs-comment"># a = 2, b = 1</span>
</div></li></ul></code></pre>
<h4 id="section113">1.1.3 数组切片</h4>
<p>切片的基本格式是 <code>array[start🔚step]</code>，表示对 array 在 start 到 end 之前以 step 为间隔取切片。注意这里的区间是 [start, end)，也就是左闭右开。比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]
</div></li><li><div class="code_line"><span class="hljs-comment"># 表示取 s 的第 0、2、4 个字符，结果是 'hlo'</span>
</div></li></ul></code></pre>
<p>再举几个例子</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]  <span class="hljs-comment"># 不写 step 默认就是 1，因此得到 'hello'</span>
</div></li><li><div class="code_line">s[<span class="hljs-number">1</span>:]   <span class="hljs-comment"># 不写 end 默认到结尾，因此还是得到 'ello'</span>
</div></li><li><div class="code_line">s[n:]   <span class="hljs-comment"># 获取 s 的最后 len(s) - n 个元素</span>
</div></li><li><div class="code_line">s[:<span class="hljs-number">2</span>]   <span class="hljs-comment"># 不写 start 默认从 0 开始，因此得到 'he'</span>
</div></li><li><div class="code_line">s[:n]   <span class="hljs-comment"># 获取 s 的前 n 个元素</span>
</div></li><li><div class="code_line">s[:<span class="hljs-number">-1</span>]  <span class="hljs-comment"># 负数表示倒过来数，因此这会刨除最后一个字符，得到 'hell'</span>
</div></li><li><div class="code_line">s[<span class="hljs-number">-2</span>:]  <span class="hljs-comment"># 同上，表示获取最后两个字符，得到 'lo'</span>
</div></li><li><div class="code_line">s[::<span class="hljs-number">-1</span>] <span class="hljs-comment"># 获取字符串的倒序排列，相当于 reverse 函数</span>
</div></li></ul></code></pre>
<p>step 和它前面的冒号要么同时写，要么同时不写，但 start 和 end 之间的冒号不能省，否则就不是切片而是获取元素了。再次强调 <code>array[start:end]</code> 表示的区间是 [a, b)，也许你会觉得这很难记，但同样的，这会得出以下美妙的公式：</p>
<blockquote>
  <p>array[:n] + array[n:] = array (0 &lt;= n &lt;= len(array))</p>
</blockquote>
<p>用代码来表示就是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">s[:<span class="hljs-number">2</span>] + s[<span class="hljs-number">2</span>:] == s  
</div></li><li><div class="code_line"><span class="hljs-comment"># True，因为 s[:2] 是 'he'，s[2:] 是 'llo'</span>
</div></li></ul></code></pre>
<p>切片不仅可以用来获取数组的一部分值，修改切片也可以直接修改数组的对应部分，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]
</div></li><li><div class="code_line"><span class="hljs-comment"># a = [1, 22, 33, 44, 4, 5, 6]</span>
</div></li></ul></code></pre>
<p>并没有人规定切片的新值必须和原来的长度一致：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">3</span>]
</div></li><li><div class="code_line"><span class="hljs-comment"># a = [1, 3, 4, 5, 6]</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] = []
</div></li><li><div class="code_line"><span class="hljs-comment"># a = [1, 6]，相当于删除了中间的三个数字</span>
</div></li></ul></code></pre>
<p>但切片的新值必须也是可迭代的对象，比如这样写是不合法的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># TypeError: can only assign an iterable</span>
</div></li></ul></code></pre>
<h4 id="section114">1.1.4 循环与遍历</h4>
<p>一般来说，在 Python 中我们不会写出 <code>for (int i = 0; i &lt; len(array); ++i)</code> 这种风格的代码，而是使用 <code>for in</code> 这种语法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:
</div></li><li><div class="code_line">    print(i)
</div></li></ul></code></pre>
<p>虽然大家都知道 <code>for in</code> 语法，但它的某些灵活用法或许就不是那么众所周知了。有时候，我们会在 <code>if</code> 语句中对某个变量的值做多次判断，只要满足一个条件即可：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">name = <span class="hljs-string">'bs'</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> name == <span class="hljs-string">'hello'</span> <span class="hljs-keyword">or</span> name == <span class="hljs-string">'hi'</span> <span class="hljs-keyword">or</span> name == <span class="hljs-string">'bs'</span> <span class="hljs-keyword">or</span> name == <span class="hljs-string">'admin'</span>:
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Valid'</span>) 
</div></li></ul></code></pre>
<p>这种情况推荐用 <code>in</code> 来代替：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">name = <span class="hljs-string">'bs'</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> (<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>, <span class="hljs-string">'bs'</span>, <span class="hljs-string">'admin'</span>):
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Valid'</span>)
</div></li></ul></code></pre>
<p>有时候，如果我们想要把某件事重复固定的次数，用 <code>for in</code> 会显得有些啰嗦，这时候可以借助 <code>range</code> 类型：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hi'</span>) <span class="hljs-comment"># 打印五次 'Hi'</span>
</div></li></ul></code></pre>
<p><code>range</code> 的语法和切片类似，比如我们需要访问数组所有奇数下标的元素，可以这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(a), <span class="hljs-number">2</span>):
</div></li><li><div class="code_line">    print(a[i])
</div></li></ul></code></pre>
<p>在这种写法中，我们不仅能获得元素，还能知道元素的下标，这与使用 <code>enumerate(iterable [, start ])</code> 函数类似：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i, n <span class="hljs-keyword">in</span> enumerate(a):
</div></li><li><div class="code_line">    print(i, n)
</div></li></ul></code></pre>
<h4 id="section115">1.1.5 魔术方法</h4>
<p>也许你已经注意到了，数组和字符串都支持切片，而且语法高度统一。这在某些强类型语言（比如我经常接触的 Objective-C 和 Java）中是不可能的，事实上，Python 能够支持这样统一的语法，并非巧合，而是因为所有用中括号进行下标访问的操作，其实都是调用这个类的 <code>__getitem__</code> 方法。</p>
<p>比如我们完全可以让自己的类也支持通过下标访问：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.chapters = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, n)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self.chapters[n]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">b = Book()
</div></li><li><div class="code_line">print(b[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 结果是 2</span>
</div></li></ul></code></pre>
<p>需要注意的是，这段代码几乎不会出问题（除非数组越界），这是因为我们直接把下标传到了内部的 <code>self.chapters</code> 数组上。但如果要自己处理下标，需要牢记它不一定是数字，也可以是切片，因此更完整的逻辑应该是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, n)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> isinstance(n, int): <span class="hljs-comment"># n是索引</span>
</div></li><li><div class="code_line">        <span class="hljs-comment"># 处理索引</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> isinstance(n, slice): <span class="hljs-comment"># n是切片</span>
</div></li><li><div class="code_line">        <span class="hljs-comment"># 通过 n.start，n.stop 和 n.step 来处理切片</span>
</div></li></ul></code></pre>
<p>与静态语言不同的是，任何实现了 <code>__getitem__</code> 都支持通过下标访问，而不用声明为实现了某个协议，这种特性也被称为 “鸭子类型”。鸭子类型并不要求某个类 <strong>是什么</strong>，仅仅要求这个类 <strong>能做什么</strong>。</p>
<p>顺便说一句，实现了 <code>__getitem__</code> 方法的类都是可迭代的，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">b = Book()
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> b:
</div></li><li><div class="code_line">    print(c)
</div></li></ul></code></pre>
<p>后续的章节还会介绍更多 Python 中的魔术方法，这种方法的名称前后都有两个下划线，如果读作 “下划线-下划线-getitem” 会比较拗口，因此可以读作 “dunder-getitem” 或者 “双下-getitem”，类似的，我想每个人都能猜到 <code>__setitem__</code> 的作用和用法。</p>
<h3 id="section12">1.2 字典</h3>
<h4 id="section121">1.2.1 初始化字典</h4>
<p>最简单的创建一个字典的方式就是直接写字面量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">{<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">63</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">64</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">65</span>}
</div></li></ul></code></pre>
<p>字典字面量由大括号包住（注意区别于数组的中括号），键值对之间由逗号分割，每个键值对内部用冒号分割键和值。</p>
<p>如果数组的每个元素都是二元的元组，这个数组可以直接转成字典：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">dict([(<span class="hljs-string">'a'</span>, <span class="hljs-number">61</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-number">62</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-number">63</span>), (<span class="hljs-string">'d'</span>, <span class="hljs-number">64</span>), (<span class="hljs-string">'e'</span>, <span class="hljs-number">65</span>)])
</div></li></ul></code></pre>
<p>就像数组可以推导一样，字典也可以推导：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [(<span class="hljs-string">'a'</span>, <span class="hljs-number">61</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-number">62</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-number">63</span>), (<span class="hljs-string">'d'</span>, <span class="hljs-number">64</span>), (<span class="hljs-string">'e'</span>, <span class="hljs-number">65</span>)]
</div></li><li><div class="code_line">d = {letter: number <span class="hljs-keyword">for</span> letter, number <span class="hljs-keyword">in</span> a} <span class="hljs-comment"># 这里用到了元组拆包</span>
</div></li></ul></code></pre>
<p>只要记得外面还是大括号就行了。</p>
<p>两个独立的数组可以被压缩成一个字典：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">numbers = [<span class="hljs-number">61</span>, <span class="hljs-number">62</span>, <span class="hljs-number">63</span>, <span class="hljs-number">64</span>, <span class="hljs-number">65</span>]
</div></li><li><div class="code_line">letters = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]
</div></li><li><div class="code_line">dict(zip(letters, numbers))
</div></li></ul></code></pre>
<p>正如 zip 的意思所表示的，超出长处的那部分数组会被抛弃。</p>
<h4 id="section122">1.2.2 查询字典</h4>
<p>最简单方法是直接写键名，但如果键名不存在会抛出 <code>KeyError</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>}
</div></li><li><div class="code_line">d[<span class="hljs-string">'a'</span>] <span class="hljs-comment"># 值是 61</span>
</div></li><li><div class="code_line">d[<span class="hljs-string">'b'</span>] <span class="hljs-comment"># KeyError: 'b'</span>
</div></li></ul></code></pre>
<p>可以用 <code>if key in dict</code> 的判断来检查键是否存在，甚至可以先 <code>try</code> 再 <code>catch KeyError</code> ，但更加优雅简洁一些的写法是用 <code>get(k, default)</code> 方法来提供默认值：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>}
</div></li><li><div class="code_line">d.get(<span class="hljs-string">'a'</span>, <span class="hljs-number">62</span>) <span class="hljs-comment"># 得到 61</span>
</div></li><li><div class="code_line">d.get(<span class="hljs-string">'b'</span>, <span class="hljs-number">62</span>) <span class="hljs-comment"># 得到 62</span>
</div></li></ul></code></pre>
<p>不过有时候，我们可能不仅仅要读出默认属性，更希望能把这个默认属性能写入到字典中，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {}
</div></li><li><div class="code_line"><span class="hljs-comment"># 我们想对字典中某个 Value 做操作，如果 Key 不存在，就先写入一个空值</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> <span class="hljs-string">'list'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> d:
</div></li><li><div class="code_line">    d[<span class="hljs-string">'list'</span>] = []
</div></li><li><div class="code_line">d[<span class="hljs-string">'list'</span>].append(<span class="hljs-number">1</span>)
</div></li></ul></code></pre>
<p>这种情况下，<code>setdefault(key, default)</code> 函数或许更合适：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d.setdefault(<span class="hljs-string">'key'</span>, []).append(<span class="hljs-number">1</span>)
</div></li></ul></code></pre>
<p>这个函数虽然名为 <code>set</code>，但作用其实是查找，仅仅在查找不到时才会把默认值写入字典。</p>
<h4 id="section123">1.2.3 遍历字典</h4>
<p>直接遍历字典实际上是遍历了字典的键，因此也可以通过键获取值：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">63</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">64</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">65</span>}
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d:
</div></li><li><div class="code_line">    print(i, d[i])
</div></li><li><div class="code_line"><span class="hljs-comment">#b 62</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#a 61</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#e 65</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#d 64</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#c 63</span>
</div></li></ul></code></pre>
<p>我们也可以用字典的 <code>keys()</code> 或者 <code>values()</code> 方法显式的获取键和值。字典还有一个 <code>items()</code> 方法，它返回一个数组，每个元素都是由键和值组成的二元元组：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">63</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">64</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">65</span>}
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> d.items():
</div></li><li><div class="code_line">    print(k, v)
</div></li><li><div class="code_line"><span class="hljs-comment">#e 65</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#d 64</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#a 61</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#c 63</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#b 62</span>
</div></li></ul></code></pre>
<p>可见 <code>items()</code> 方法和字典的构造方法互为逆操作，因为这个公式总是成立的：</p>
<blockquote>
  <p>dict(d.items()) == d</p>
</blockquote>
<h4 id="section124">1.2.4 字典的魔术方法</h4>
<p>在 1.1.4 节中介绍过，通过下标访问最终都会由 <code>__getitem__</code> 这个魔术方法处理，因此字典的 <code>d[key]</code> 这种写法也不例外， 如果键不存在，则会走到 <code>__missing__</code> 方法，再给一次挽救的机会。比如我们可以实现一个字典， 自动忽略键的大小写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDict</span><span class="hljs-params">(dict)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__missing__</span><span class="hljs-params">(self, key)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> key.islower():
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> KeyError(key)
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> self[key.lower()]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = MyDict({<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>})
</div></li><li><div class="code_line">d[<span class="hljs-string">'A'</span>] <span class="hljs-comment"># 返回 61</span>
</div></li><li><div class="code_line"><span class="hljs-string">'A'</span> <span class="hljs-keyword">in</span> d <span class="hljs-comment"># False</span>
</div></li></ul></code></pre>
<p>这个字典比较简陋，比如 key 可能不是字符串，不过我没有处理太多情况，因为它主要是用来演示 <code>__missing__</code> 的用法，如果想要最后一行的 <code>in</code> 语法正确工作，需要重写 <code>__contains__</code> 这个魔术方法，过程类似，就不赘述了。</p>
<p>虽然通过自定义的函数也能实现相似的效果，不过这个自定义字典对用户更加透明，如果不在文档中说明，调用方很难察觉到字典的内部逻辑被修改了。 Python 有很多强大的功能，可以具备这种内部进行修改，但是对外保持透明的能力。这可能是我们第一次体会到，后续还会不断的经历。</p>
<h4 id="section125">1.2.5 集合</h4>
<p>集合更像是不会有重复元素的数组，但它的本质是以元素的哈希值作为 Key，从而实现去重的逻辑。因此，集合也可以推导，不过得用字典的语法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
</div></li><li><div class="code_line">d = {i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">5</span>}
</div></li><li><div class="code_line"><span class="hljs-comment"># d = {1, 2, 3, 4}，注意这里的大括号</span>
</div></li></ul></code></pre>
<p>回忆一下，二进制逻辑运算一共有三个运算符，按位或 <code>|</code>，按位与 <code>&amp;</code> 和异或 <code>^</code>，这三个运算符也可以用在集合之间，而且含义变化不大。比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a | b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {1, 2, 3, 4, 5}</span>
</div></li></ul></code></pre>
<p>这里的 <code>|</code> 运算表示并集，也就是 c 中的任意元素，要么在 a，要么在 b 集合中。类似的，按位与 <code>&amp;</code> 运算求的就是交集：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a &amp; b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {3}</span>
</div></li></ul></code></pre>
<p>而异或则表示那些只在 a 不在 b 或者只在 b 不在 a 的元素。或者换个说法，表示那些在集合 a 和 b 中出现了且仅出现了一次的元素：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a ^ b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {1, 2, 4, 5}</span>
</div></li></ul></code></pre>
<p>还有一个差集运算 <code>-</code>，表示在集合 a 中但不在集合 b 中的元素：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a - b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {1, 2}</span>
</div></li></ul></code></pre>
<p>回忆一下韦恩图，就会得到以下公式（虽然并没有什么卵用）：</p>
<blockquote>
  <p>A | B = (A ^ B) | (A &amp; B)<br>
  A ^ B = (A - B) | (B - A)</p>
</blockquote>
<h3 id="section13">1.3 字符串</h3>
<h4 id="section131">1.3.1 字符串编码</h4>
<p>用 Python 写过爬虫的人都应该感受过被字符串编码支配的恐惧。简单来说，编码指的是将可读的字符串转换成不太可读的数字，用来存储或者传输。解码则指的是将数字还原成字符串的过程。常见的编码有 ASCII、GBK 等。</p>
<p>ASCII 编码是一个相当小的字符集合，只有一百多个常用的字符，因此只用一个字节（8 位）就能表示，为了存储本国语言，各个国家都开发出了自己的编码，比如中文的 GBK。这就带来了一个问题，如果我想要在一篇文章中同时写中文和日文，就无法实现了，除非能对每个字符指定编码，这个成本高到无法接受。</p>
<p>Unicode 则是一个最全的编码方式，每个 Unicode 字符占据 6 个字节，可以表示出 2 ^ 48 种字符。但随之而来的是 Unicode 编码后的内容不适合存储和发送，因此诞生了基于 Unicode 的再次编码，目的是为了更高效的存储。</p>
<p>更详细的概念分析和配图说明可以参考我的这篇文章：<a href="http://fullstack.blog/2017/09/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E5%85%A5%E9%97%A8%E7%A7%91%E6%99%AE/" target="_blank">字符串编码入门科普</a>，这里我们主要聊聊 Python 对字符串编码的处理。</p>
<p>首先，编码的函数是 <code>encode</code>，它是字符串的方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">s.encode()         <span class="hljs-comment"># 得到 b'hello'</span>
</div></li><li><div class="code_line">s.encode(<span class="hljs-string">'utf16'</span>)  <span class="hljs-comment"># 得到 b'\xff\xfeh\x00e\x00l\x00l\x00o\x00'</span>
</div></li></ul></code></pre>
<p><code>encode</code> 函数有两个参数，第一个参数不写表示使用默认的 <code>utf8</code> 编码，理论上会输出二进制格式的编码结果，但在终端打印时，被自动还原回字符串了。如果用 <code>utf16</code> 进行编码，则会看到编码以后的二进制结果。</p>
<p>前面说过，编码是字符转到二进制的转化过程，有时候在某个编码规范中，并没有指定某个字符是如何编码的，也就是找不到对应的数字，这时候编码就会报错：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">city = <span class="hljs-string">'São Paulo'</span>
</div></li><li><div class="code_line">b_city = city.encode(<span class="hljs-string">'cp437'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># UnicodeEncodeError: 'charmap' codec can't encode character '\xe3' in position 1: character maps to &lt;undefined&gt;</span>
</div></li></ul></code></pre>
<p>此时需要用到 <code>encode</code> 函数的第二个参数，用来指定遇到错误时的行为。它的值可以是 <code>'ignore'</code>，表示忽略这个不能编码的字符，也可以是 <code>'replace'</code>，表示用默认字符代替：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">b_city = city.encode(<span class="hljs-string">'cp437'</span>, errors=<span class="hljs-string">'ignore'</span>) 
</div></li><li><div class="code_line"><span class="hljs-comment"># b'So Paulo'</span>
</div></li><li><div class="code_line">b_city = city.encode(<span class="hljs-string">'cp437'</span>, errors=<span class="hljs-string">'replace'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># b'S?o Paulo'</span>
</div></li></ul></code></pre>
<p><code>decode</code> 完全是 <code>encode</code> 的逆操作，只有二进制类型才有这个函数。它的两个参数含义和 <code>encode</code> 函数完全一致，就不再介绍了。</p>
<p>从理论上来说，仅从编码后的内容上来看，是无法确定编码方式的，也无法解码出原来的字符。但不同的编码有各自的特点，虽然无法完全倒推，但可以从概率上来猜测，如果发现某个二进制内容，有 99% 的可能性是 <code>utf8</code> 编码生成的，我们就可以用 <code>utf8</code> 进行解码。Python 提供了一个强大的工具包 <code>Chardet</code>  来完成这一任务：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">octets = <span class="hljs-string">b'Montr\xe9al'</span>
</div></li><li><div class="code_line">chardet.detect(octets)
</div></li><li><div class="code_line"><span class="hljs-comment"># {'encoding': 'ISO-8859-1', 'confidence': 0.73, 'language': ''}</span>
</div></li><li><div class="code_line">octets.decode(<span class="hljs-string">'ISO-8859-1'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># Montréal</span>
</div></li></ul></code></pre>
<p>返回结果中包含了猜测的编码方式，以及可信度。可信度越高，说明是这种编码方式的可能性越大。</p>
<p>有时候，我们拿到的是二进制的字符串字面量，比如 <code>68 65 6c 6c 6f</code>，前文说过只有二进制类型才有 <code>decode</code> 函数，所以需要通过二进制的字面量生成二进制变量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'68 65 6c 6c 6f'</span>
</div></li><li><div class="code_line">b = bytearray.fromhex(s)
</div></li><li><div class="code_line">b.decode()  <span class="hljs-comment"># hello</span>
</div></li></ul></code></pre>
<h4 id="section132">1.3.2 字符串的常用方法</h4>
<p>字符串的 <code>split(sep, maxsplit)</code> 方法可以以指定的分隔符进行分割，有点类似于 Shell 中的 <code>awk -F ' '</code>'，第一个 <code>sep</code> 参数表示分隔符，不填则为空格：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'a b c d e'</span>
</div></li><li><div class="code_line">a = s.split()
</div></li><li><div class="code_line"><span class="hljs-comment"># a = ['a', 'b', 'c', 'd', 'e']</span>
</div></li></ul></code></pre>
<p>第二个参数 <code>maxsplit</code> 表示最多分割多少次，因此返回数组的长度是 <code>maxsplit + 1</code>。举个例子说明下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'a;b;c;d;e'</span>
</div></li><li><div class="code_line">a = s.split(<span class="hljs-string">';'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># a = ['a', 'b', 'c', 'd', 'e']</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">b = s.split(<span class="hljs-string">';'</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># b = ['a', 'b', 'c;d;e']</span>
</div></li></ul></code></pre>
<p>如果想批量替换，则可以用 <code>replace(old, new[, count])</code> 方法，由中括号括起来的参数表示选填。</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">old = <span class="hljs-string">'a;b;c;d;e'</span>
</div></li><li><div class="code_line">new = old.replace(<span class="hljs-string">';'</span>, <span class="hljs-string">' '</span>, <span class="hljs-number">3</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># new = 'a b c d;e'</span>
</div></li></ul></code></pre>
<p><code>strip[chars]</code> 用于移除指定的字符们：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">old = <span class="hljs-string">"*****!!!Hello!!!*****"</span>
</div></li><li><div class="code_line">new = old.strip(<span class="hljs-string">'*'</span>)  <span class="hljs-comment"># 得到 '!!!Hello!!!'</span>
</div></li><li><div class="code_line">new = old.strip(<span class="hljs-string">'*！'</span>)  <span class="hljs-comment"># 得到 'Hello'</span>
</div></li></ul></code></pre>
<p>如果不传参数，则默认移除空格。其实 <code>strip</code> 等价于分别执行 <code>lstrip()</code> 和 <code>rstrip()</code>，即分别从左侧和右侧进行移除。比如 <code>lstrip()</code> 表示从左侧第一个字符开始，移除空格，直到第一个非空格字符为止，所以字符串中间的空格，无论是 <code>lstrip</code> 还是 <code>strip()</code> 都是无法移除的。</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">old = <span class="hljs-string">'  Hello world  '</span>
</div></li><li><div class="code_line">new = old.strip()   <span class="hljs-comment"># 得到 'Hello wrold'</span>
</div></li><li><div class="code_line">new = old.lstrip()  <span class="hljs-comment"># 得到 'Hello world  '</span>
</div></li></ul></code></pre>
<p>最后一个常用方法是 <code>join</code>，其实这个可以理解为字符串的构造方法，它可以把数组转换成字符串：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = <span class="hljs-string">'a b c d e'</span>.split() <span class="hljs-comment"># 之前说过，结果是 ['a', 'b', 'c', 'd', 'e']</span>
</div></li><li><div class="code_line">s = <span class="hljs-string">';'</span>.join(array) <span class="hljs-comment"># 以分号为连接符，把数组中的元素连接起来</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># s = 'a;b;c;d;e'</span>
</div></li></ul></code></pre>
<p>所以 <code>join</code> 可以理解为 <code>split</code> 的逆操作，这个公式始终是成立的：</p>
<blockquote>
  <p>c.join(string.split(c)) = string</p>
</blockquote>
<p>上面这些字符串处理的函数，大多返回的还是字符串，因此可以链式调用，避免使用临时变量和多行代码，但也要避免过长（超过 3 个）的链式调用，以免影响可读性。</p>
<h4 id="section133">1.3.3 字符串格式化</h4>
<p>最初级的字符串格式化方法是使用 <code>+</code> 来拼接：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">        self.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">        self.sex = <span class="hljs-string">'m'</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">print(<span class="hljs-string">'Name: '</span> + p.name + <span class="hljs-string">', Age: '</span> + str(p.age) + <span class="hljs-string">', Sex: '</span> + p.sex)
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span>
</div></li></ul></code></pre>
<p>这里必须要把 <code>int</code> 类型的年龄转成字符串以后才能进行拼接，这是因为 Python 是强类型语言，不支持类型的隐式转换。</p>
<p>这种做法的缺点在于如果输出结构比较复杂，极容易出现引号匹配错误的问题，可读性非常低。</p>
<p>Python 2 中的做法是使用占位符，类似于 C 语言中 <code>printf</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">content = <span class="hljs-string">'Name: %s, Age: %i, Sex: %c'</span> % (p.name, p.age, p.sex)
</div></li><li><div class="code_line">print(content)
</div></li></ul></code></pre>
<p>从结构上看，要比上一种写法清楚得多， 但每个变量都需要指定类型，这和 Python 的简洁不符。实际上每个对象都可以通过 <code>str()</code> 函数转换成字符串，这个函数的背后是 <code>__str__</code> 魔术方法。</p>
<p>Python 3 中的写法是使用 <code>format</code> 函数，比如我们来实现一下 <code>__str__</code> 方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">        self.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">        self.sex = <span class="hljs-string">'m'</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Name: {user.name}, Age: {user.age}, Sex: {user.sex}'</span>.format(user=self)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">print(p)
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span>
</div></li></ul></code></pre>
<p>除了把对象传给 <code>format</code> 函数并在字符串中展开以外， 也可以传入多个参数，并且通过下标访问他们：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">print(<span class="hljs-string">'{0}, {1}, {0}'</span>.format(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出：1, 2, 1，这里的 {1} 表示第二个参数</span>
</div></li></ul></code></pre>
<h4 id="section134heredoc">1.3.4 HereDoc</h4>
<p>Heredoc 不是 Python 特有的概念， 命令行和各种脚本中都会见到，它表示一种所见即所得的文本。</p>
<p>假设我们在写一个 HTML 的模板，绝大多数字符串都是常量，只有有限的几个地方会用变量去替换，那这个字符串该如何表示呢？一种写法是直接用单引号去定义：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;\nFriends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;\n&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;\n&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;\n&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back\nONCLICK=\'window.history.back()\'&gt;&lt;/FORM&gt;\n&lt;/BODY&gt;&lt;/HTML&gt;'</span>
</div></li></ul></code></pre>
<p>这段代码是自动生成的还好，如果是手动维护的，那么可读性就非常差，因为换行符和转义后的引号增加了理解的难度。如果用 heredoc 来写，就非常简单了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back
</span></div></li><li><div class="code_line"><span class="hljs-string">ONCLICK='window.history.back()'&gt;&lt;/FORM&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;/BODY&gt;&lt;/HTML&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">'''</span>
</div></li></ul></code></pre>
<p>Heredoc 主要是用来书写大段的字符串常量，比如 HTML 模板，SQL语句等等。</p>
<h2 id="section2">2 函数</h2>
<h3 id="section21">2.1 函数是一等公民</h3>
<p>一等公民指的是 Python 的函数能够动态创建，能赋值给别的变量，能作为参传给函数，也能作为函数的返回值。总而言之，函数和普通变量并没有什么区别。</p>
<p>函数是一等公民，这是函数式编程的基础，然而 Python 中基本上不会使用 lambda 表达式，因为在 lambda 表达式的中仅能使用单纯的表达式，不能赋值，不能使用 while、try 等语句，因此 lambda 表达式要么难以阅读，要么根本无法写出。这极大的限制了 lambda 表达式的使用场景。</p>
<p>上文说过，函数和普通变量没什么区别，但普通变量并不是函数，因为这些变量无法调用。但如果某个类实现了 <code>__call__</code> 这个魔术方法，这个类的实例就都可以像函数一样被调用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">        self.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">        self.sex = <span class="hljs-string">'m'</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        print(self)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Name: {user.name}, Age: {user.age}, Sex: {user.sex}'</span>.format(user=self)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">p() <span class="hljs-comment"># 等价于 print(p)</span>
</div></li></ul></code></pre>
<h3 id="section22">2.2 函数参数</h3>
<h4 id="section221">2.2.1 函数传参</h4>
<p>对于熟悉 C 系列语言的人来说，函数传参的方式一目了然。默认是拷贝传值，如果传指针是引用传值。我们先来看一段简单的 Python 代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(arg)</span>:</span>
</div></li><li><div class="code_line">    arg = <span class="hljs-number">5</span>
</div></li><li><div class="code_line">    print(arg)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">a = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">foo(a)
</div></li><li><div class="code_line">print(a)
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出 5 和 1</span>
</div></li></ul></code></pre>
<p>这段代码的结果符合我们的预期，从这段代码来看，Python 也属于拷贝传值。但如果再看这段代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(arg)</span>:</span>
</div></li><li><div class="code_line">    arg.append(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">    print(arg)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">a = [<span class="hljs-number">1</span>]
</div></li><li><div class="code_line">foo(a)
</div></li><li><div class="code_line">print(a) <span class="hljs-comment"># 输出两个 [1, 1]</span>
</div></li></ul></code></pre>
<p>你会发现参数数组在函数内部被改变了。就像是 C 语言中传递了变量的指针一样。所以 Python 到底是拷贝传值还是引用传值呢？答案<strong>都是否定的</strong>！</p>
<p>Python 的传值方式可以被理解为混合传值。对于那些不可变的对象（比如 1.1.2 节中介绍过的元组，还有数字、字符串类型），传值方式是拷贝传值；对于那些可变对象（比如数组和字典）则是引用传值。</p>
<h4 id="section222">2.2.2 默认参数</h4>
<p>Python 的函数可以有默认值，这个功能很好用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(a, l=[])</span>:</span>
</div></li><li><div class="code_line">    l.append(a)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> l
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">foo(<span class="hljs-number">2</span>,[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 给数组 [1] 添加一个元素 2，得到 [1,2]</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">2</span>)      <span class="hljs-comment"># 没有传入数组，使用默认的空数组，得到 [2]</span>
</div></li></ul></code></pre>
<p>然而如果这样调用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 利用默认参数，得到 [2]</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 竟然得到了 [2, 3]</span>
</div></li></ul></code></pre>
<p>函数调用了两次以后，默认参数被改变了，也就是说函数调用产生了副作用。这是因为默认参数的存储并不像函数里的临时变量一样存储在栈上、随着函数调用结束而释放，而是存储在函数这个对象的内部：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo.__defaults__  <span class="hljs-comment"># 一开始确实是空数组</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 利用默认参数，得到 [2]</span>
</div></li><li><div class="code_line">foo.__defaults__  <span class="hljs-comment"># 如果打印出来看，已经变成 [2] 了</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 再添加一个元素就得到了 [2, 3]</span>
</div></li></ul></code></pre>
<p>因为函数 <code>foo</code> 作为一个对象，不会被释放，因此这个对象内部的属性也不会随着多次调用而自动重置，会一直保持上次发生的变化。基于这个前提，我们得出一个结论：<strong>函数的默认参数不允许是可变对象</strong>，比如这里的 <code>foo</code> 函数需要这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(a, l=None)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
</div></li><li><div class="code_line">        l = []
</div></li><li><div class="code_line">    l.append(a)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> l
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">print(foo(<span class="hljs-number">2</span>)) <span class="hljs-comment"># 得到 [2]</span>
</div></li><li><div class="code_line">print(foo(<span class="hljs-number">3</span>)) <span class="hljs-comment"># 得到 [3]</span>
</div></li></ul></code></pre>
<p>现在，给参数添加默认值的行为在函数体中完成，不会随着函数的多次调用而累积。</p>
<p>对于 Python 的默认参数来说：</p>
<blockquote>
  <p>如果默认值是不可变的，可以直接设置默认值，否则要设置为 None 并在函数体中设置默认值。</p>
</blockquote>
<h4 id="section223">2.2.3 多参数传递</h4>
<p>当参数个数不确定时，可以在参数名前加一个 <code>*</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args)</span>:</span>
</div></li><li><div class="code_line">    print(args)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 输出 [1, 2, 3]</span>
</div></li></ul></code></pre>
<p>如果直接把数组作为参数传入，它其实是单个参数，如果要把数组中所有元素都作为单独的参数传入，则在数组前面加上 <code>*</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]    
</div></li><li><div class="code_line">foo(a)  <span class="hljs-comment"># 会输出 ([1,2,3], )   因为只传了一个数组作为参数</span>
</div></li><li><div class="code_line">foo(*a) <span class="hljs-comment"># 输出 [1, 2, 3]</span>
</div></li></ul></code></pre>
<p>这里的单个 <code>*</code> 只能接收非关键字参数，也就是仅有参数值的哪些参数。如果想接受关键字参数，需要用 <code>**</code> 来表示：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args, **kwargs)</span>:</span>
</div></li><li><div class="code_line">    print(args)
</div></li><li><div class="code_line">    print(kwargs)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">foo(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>, a=<span class="hljs-number">61</span>, b=<span class="hljs-number">62</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># 第一行输出：(1, 2, 3)</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 第二行输出：{'a': 61, 'b': 62}</span>
</div></li></ul></code></pre>
<p>类似的，字典变量传入函数只能作为单个参数，如果要想展开并被 <code>**kwargs</code> 识别，需要在字典前面加上两个星号 <code>**</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>}
</div></li><li><div class="code_line">foo(*a, **d)
</div></li></ul></code></pre>
<h4 id="section224">2.2.4 参数分类</h4>
<p>Python 中函数的参数可以分为两大类：</p>
<ol>
<li>定位参数（Positional）：表示参数的位置是固定的。比如对于函数 <code>foo(a, b)</code> 来说，<code>foo(1, 2)</code> 和 <code>foo(2, 1)</code> 就是截然不同的，a 和 b 的位置是固定的，不可随意调换。</li>
<li>关键词参数（Keyword）：表示参数的位置不重要，但是参数名称很重要。比如 <code>foo(a = 1, b = 2)</code> 和 <code>foo(b = 2, a = 1)</code> 的含义相同。</li>
</ol>
<p>有一种参数叫做仅限关键字（Keyword-Only）参数，比如考虑这个函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args, n=<span class="hljs-number">1</span>, **kwargs)</span>:</span>
</div></li><li><div class="code_line">    print(n)
</div></li></ul></code></pre>
<p>这个函数在调用时，如果参数 n 不指定名字，就会被前面的 <code>*args</code> 处理掉，如果指定的名字不是 n，又会被后面的 <code>**kwargs</code> 处理掉，所以参数 n 必须精确的以 <code>(n = xxx)</code> 的形式出现，也就是 Keyworld-Only。</p>
<h3 id="section23">2.3 函数内省</h3>
<p>在 2.2.2 节中，我们查看了函数变量的 <code>__defaults__</code> 属性，其实这就是一种内省，也就是在运行时动态的查看变量的信息。</p>
<p>前文说过，函数也是对象，因此函数的变量个数，变量类型都应该有办法获取到，如果你需要开发一个框架，也许会对函数有各种奇葩的检查和校验。 </p>
<p>以下面这个函数为例：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">g = <span class="hljs-number">1</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(m, *args, n, **kwargs)</span>:</span>
</div></li><li><div class="code_line">    a = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    b = <span class="hljs-number">2</span>
</div></li></ul></code></pre>
<p>首先可以获取函数名，函数所在模块的全局变量等：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo.__globals__   <span class="hljs-comment"># 全局变量，包含了 g = 1</span>
</div></li><li><div class="code_line">foo.__name__      <span class="hljs-comment"># foo</span>
</div></li></ul></code></pre>
<p>我们还可以看到函数的参数，函数内部的局部变量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo.__code__.co_varnames  <span class="hljs-comment"># ('m', 'n', 'args', 'kwargs', 'a', 'b')</span>
</div></li><li><div class="code_line">foo.__code__.co_argcount  <span class="hljs-comment"># 只计算参数个数，不考虑可变参数和仅限关键字参数，所以得到 1</span>
</div></li></ul></code></pre>
<p>或者用 <code>inspect</code> 模块来查看更详细的信息：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> inspect
</div></li><li><div class="code_line">sig = inspect.signature(foo)  <span class="hljs-comment"># 获取函数签名</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'m'</span>].kind      <span class="hljs-comment"># POSITIONAL_OR_KEYWORD 表示可以是定位参数或关键字参数</span>
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'args'</span>].kind   <span class="hljs-comment"># VAR_POSITIONAL 定位参数构成的数组</span>
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'n'</span>].kind      <span class="hljs-comment"># KEYWORD_ONLY 仅限关键字参数</span>
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'kwargs'</span>].kind <span class="hljs-comment"># VAR_KEYWORD 关键字参数构成的字典</span>
</div></li><li><div class="code_line">inspect.getfullargspec(foo)       
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：ArgSpec(args=['m', 'n'], varargs='args', keywords='kwargs', defaults=None)</span>
</div></li></ul></code></pre>
<p>本节的新 API 比较多，但并不要求记住这些 API 的用法。再次强调，本文的写作目的是为了建立读者对 Python 的总体认知，了解 Python <strong>能做什么</strong>，至于怎么做，那是文档该做的事。</p>
<h3 id="section24">2.4 装饰器</h3>
<h4 id="section241">2.4.1 设计模式的消亡</h4>
<p>经典的设计模式有 23 个，虽然设计模式都是常用代码的总结，理论上来说与语法无关。但不得不承认的是，标准的设计模式在不同的语言中，有的因为语法的限制根本无法轻易实现（比如在 C 语言中实现组合模式），有的则因为语言的特定功能，变得冗余啰嗦。</p>
<p>以策略模式为例，有一个抽象的策略类，定义了策略的接口，然后使用者选择一个具体的策略类，构造他们的实例并且调用策略方法。具体代码可以参考：<a href="https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/646307?fr=aladdin" target="_blank">策略模式在百度百科的定义</a>。</p>
<p>然而这些对象本身并没有作用，它们仅仅是可以调用相同的方法而已，只不过在 Java 中，所有的任务都需要由对象来完成。即使策略本身就是一个函数，但也必须把它包裹在一个策略对象中。所以在 Python 中更优雅写法是直接把策略函数作为变量使用。不过这就引入一个问题，如何判断某个函数是个策略呢，毕竟在面向对象的写法中，只要检查它的父类是否是抽象的策略类即可。</p>
<p>也许你已经见过类似的写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@strategy</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strategyA</span><span class="hljs-params">(n)</span>:</span>
</div></li><li><div class="code_line">    print(n * <span class="hljs-number">2</span>)
</div></li></ul></code></pre>
<p>下面就开始介绍装饰器。</p>
<h4 id="section242">2.4.2 装饰器的基本原理</h4>
<p>首先，装饰器是个函数，它的参数是被装饰的函数，返回值也是一个函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(origin_func)</span>:</span>  <span class="hljs-comment"># 这个参数是被装饰的函数</span>
</div></li><li><div class="code_line">    print(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 先输出点东西</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> origin_func  <span class="hljs-comment"># 把原函数直接返回</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-meta">@decorate    # 注意这里不是函数调用，所以不用加括号，也不用加被修饰的函数名</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sayHello()  <span class="hljs-comment"># 如果没有装饰器，只会打印 'Hello'，实际结果是打印 1 再打印 'Hello'</span>
</div></li></ul></code></pre>
<p>因此，使用装饰器的这种写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@decorate</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li></ul></code></pre>
<p>和下面这种写法是完全等价的， 初学者可以把装饰器在心中默默的转换成下一种写法，以方便理解：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">foo = decorate(foo)
</div></li></ul></code></pre>
<p>需要注意的是，装饰器函数 <code>decorate</code> 在模块被导入时就会执行，而被装饰的函数只在被调用时才会执行，也就是说即使不调用 <code>sayHello</code> 函数也会输出 1，但这样就不会输出 Hello 了。</p>
<p>有了装饰器，配合前面介绍的函数对象，函数内省，我们可以做很多有意思的事，至少判断上一节中某个函数是否是策略是非常容易的。在装饰器中，我们还可以把策略函数都保存到数组中， 然后提供一个“推荐最佳策略”的功能， 其实就是遍历执行所有的策略，然后选择最好的结果。</p>
<h4 id="section243">2.4.3 装饰器进阶</h4>
<p>上一节中的装饰器主要是为了介绍工作原理，它的功能非常简单，并不会改变被装饰函数的运行结果，仅仅是在导入时装饰函数，然后输出一些内容。换句话说，即使不执行函数，也要执行装饰器中的 <code>print</code> 语句，而且因为直接返回函数的缘故，其实没有真正的起到装饰的效果。</p>
<p>如何做到装饰时不输出任何内容，仅在函数执行最初输出一些东西呢？这是常见的 AOP（面向切片编程） 的需求。这就要求我们不能再直接返回被装饰的函数，而是应该返回一个新的函数，所以新的装饰器需要这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(origin_func)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_func</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">        origin_func()
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> new_func
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">decorate
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sayHello() <span class="hljs-comment"># 运行结果不变，但是仅在调用函数 sayHello 时才会输出 1</span>
</div></li></ul></code></pre>
<p>这个例子的工作原理是，<code>sayHello</code> 函数作为参数 <code>origin_func</code> 被传到装饰器中，经过装饰以后，它实际上变成了 <code>new_func</code>，会先输出 1 再执行原来的函数，也就是 <code>sayHello</code>。</p>
<p>这个例子很简陋，因为我们知道了 <code>sayHello</code> 函数没有参数，所以才能定义一个同样没有参数的替代者：<code>nwe_func</code>。如果我们在开发一个框架，要求装饰器能对任意函数生效，就需要用到 2.2.3 中介绍的 <code>*</code> 和 <code>**</code> 这种不定参数语法了。</p>
<p>如果查看 <code>sayHello</code> 函数的名字，得到的结果将是 <code>new_func</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">sayHello.__name__  <span class="hljs-comment"># new_func</span>
</div></li></ul></code></pre>
<p>这是很自然的，因为本质上其实执行的是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">new_func = decorate(sayHello)
</div></li></ul></code></pre>
<p>而装饰器的返回结果是另一个函数 <code>new_func</code>，两者仅仅是运行结果类似，但两个对象并没有什么关联。</p>
<p>所以为了处理不定参数，并且不改变被装饰函数的外观（比如函数名），我们需要做一些细微的修补工作。这些工作都是模板代码，所以 Python 早就提供了封装：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> functools
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(origin_func)</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @functools.wraps(origin_func)  # 这是 Python 内置的装饰器</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_func</span><span class="hljs-params">(*args, **kwargs)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">        origin_func(*args, **kwargs)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> new_func
</div></li></ul></code></pre>
<h4 id="section244">2.4.4 装饰器工厂</h4>
<p>在 2.4.2 节的代码注释中我解释过，装饰器后面不要加括号，被装饰的函数自动作为参数，传递到装饰器函数中。如果加了括号和参数，就变成手动调用装饰器函数了，大多数时候这与预期不符（因为装饰器的参数一般都是被装饰的函数）。</p>
<p>不过装饰器可以接受自定义的参数，然后返回另一个装饰器，这样外面的装饰器实际上就是一个装饰器工厂，可以根据用户的参数，生成不同的装饰器。还是以上面的装饰器为例，我希望输出的内容不是固定的 1，而是用户可以指定的，代码就应该这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> functools
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(content)</span>:</span>                        <span class="hljs-comment"># 这其实是一个装饰器工厂</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">real_decorator</span><span class="hljs-params">(origin_func)</span>:</span>          <span class="hljs-comment"># 这才是刚刚的装饰器</span>
</div></li><li><div class="code_line"><span class="hljs-meta">        @functools.wraps(origin_func)</span>
</div></li><li><div class="code_line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_func</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">            print(<span class="hljs-string">'You said '</span> + str(content)) <span class="hljs-comment"># 现在输出内容可以由用户指定</span>
</div></li><li><div class="code_line">            origin_func()
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> new_func                       <span class="hljs-comment"># 在装饰器里，返回的是新的函数</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> real_decorator                     <span class="hljs-comment"># 装饰器工厂返回的是装饰器</span>
</div></li></ul></code></pre>
<p>装饰器工厂和装饰器的区别在于它可以接受参数，返回一个装饰器：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@decorate(2017)</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sayHello()
</div></li></ul></code></pre>
<p>其实等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">real_decorator = decorate(<span class="hljs-number">2017</span>)      <span class="hljs-comment"># 通过装饰器工厂生成装饰器</span>
</div></li><li><div class="code_line">new_func = real_decorator(sayHello)  <span class="hljs-comment"># 正常的装饰器工作逻辑</span>
</div></li><li><div class="code_line">new_func()                           <span class="hljs-comment"># 调用的是装饰过的函数</span>
</div></li></ul></code></pre>
<h2 id="section3">3 面向对象</h2>
<h3 id="section31">3.1 对象内存管理</h3>
<h4 id="section311">3.1.1 对象不是盒子</h4>
<p>C 语言中我们定义变量用到的语法是：</p>
<pre><code class="c language-c hljs cpp"><ul><li><div class="code_line"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;
</div></li></ul></code></pre>
<p>这背后的含义是定义了一个 <code>int</code> 类型的变量 <code>a</code>，相当于申请了一个名为 <code>a</code> 的盒子（存储空间），里面装了数字 1。<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/d488dd71e0be57efe82f076c550e6a22.png" alt=""></p>
<p>然后我们改变 <code>a</code> 的值：<code>a = 2;</code>，可以打印 <code>a</code> 的地址来证明它并没有发生变化。所以只是盒子里装的内容（指针指向的位置）发生了改变：<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/63785ebe7adfb514dcc88d4b96a34cad.png" alt=""></p>
<p>但是在 Python 中，变量不是盒子。比如同样的定义变量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = <span class="hljs-number">1</span>
</div></li></ul></code></pre>
<p>这里就不能把 <code>a</code> 理解为 <code>int</code> 类型的变量了。因为在 Python 中，变量没有类型，值才有，或者说只有对象才有类型。因为即使是数字 1，也是 <code>int</code> 类的实例，而变量 <code>a</code> 更像是给这个对象贴的一个标签。</p>
<p><img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/6d30c0da2d2108ccc071c8751c4e7c1a.png" alt=""><br>
如果执行赋值语句 <code>a = 2</code>，相当于把标签 a 贴在另一个对象上：<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/05a4f3b25b942f0656f1759eb5b6dbc6.png" alt=""></p>
<p>基于这个认知，我们现在应该更容易理解 2.2.1 节中所说的函数传参规则了。如果传入的是不可变类型，比如 <code>int</code>，改变它的值实际上就是把标签挂在新的对象上，自然不会改变原来的参数。如果是可变类型，并且做了修改，那么函数中的变量和外面的变量都是指向同一个对象的标签，所以会共享变化。</p>
<h4 id="section312">3.1.2 默认浅复制</h4>
<p>根据上一节的描述，直接把变量赋值给另一个变量， 还算不上复制：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">b = a
</div></li><li><div class="code_line">b == a   <span class="hljs-comment"># True，等同性校验，会调用 __eq__ 函数，这里只判断内容是否相等</span>
</div></li><li><div class="code_line">b <span class="hljs-keyword">is</span> a   <span class="hljs-comment"># True，一致性校验，会检查是否是同一个对象，调用 hash() 函数，可以理解为比较指针</span>
</div></li></ul></code></pre>
<p>可见不仅仅数组相同，就连变量也是相同的，可以把 b 理解为 a 的别名。</p>
<p>如果用切片，或者数组的构造函数来创建新的数组，得到的是原数组的浅拷贝：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">b = list(a)
</div></li><li><div class="code_line">b == a   <span class="hljs-comment"># True，因为数组内容相同</span>
</div></li><li><div class="code_line">b <span class="hljs-keyword">is</span> a   <span class="hljs-comment"># False，现在 a 和 b 是两个变量，恰好指向同一个数组对象</span>
</div></li></ul></code></pre>
<p>但如果数组中的元素是可变的，可以看到这些元素并没有被完全拷贝：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [[<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>]]
</div></li><li><div class="code_line">b = list(a)
</div></li><li><div class="code_line">b[<span class="hljs-number">0</span>].append(<span class="hljs-number">2</span>)
</div></li><li><div class="code_line">a <span class="hljs-comment"># 得到 [[1, 2], [2], [3]]，因为 a[0] 和 b[0] 其实还是挂在相同对象上的不同标签</span>
</div></li></ul></code></pre>
<p>如果想要深拷贝，需要使用 <code>copy</code> 模块的 <code>deepcopy</code> 函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> copy 
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">b = copy.deepcopy(a)
</div></li><li><div class="code_line">b[<span class="hljs-number">0</span>].append(<span class="hljs-number">2</span>)
</div></li><li><div class="code_line">b  <span class="hljs-comment"># 变成了 [[1, 2], [2], [3]]</span>
</div></li><li><div class="code_line">a  <span class="hljs-comment"># 还是 [[1], [2], [3]]</span>
</div></li></ul></code></pre>
<p>此时，不仅仅是每个元素的引用被拷贝，就连每个元素自己也被拷贝。所以现在的 <code>a[0]</code> 和 <code>b[0]</code> 是指向两个不同对象的两个不同变量（标签），自然就互不干扰了。</p>
<p>如果要实现自定义对象的深复制，只要实现 <code>__deepcopy__</code> 函数即可。这个概念在几乎所有面向对象的语言中都会存在，就不详细介绍了。</p>
<h4 id="section313">3.1.3 弱引用</h4>
<p>Python 内存管理使用垃圾回收的方式，当没有指向对象的引用时，对象就会被回收。然而对象一直被持有也并非什么好事，比如我们要实现一个缓存，预期目标是缓存中的内容随着真正对象的存在而存在，随着真正对象的消失而消失。如果因为缓存的存在，导致被缓存的对象无法释放，就会导致内存泄漏。</p>
<p>Python 提供了语言级别的支持，我们可以使用 <code>weakref</code> 模块，它提供了 <code>weakref.WeakValueDictionary</code> 这个弱引用字典来确保字典中的值不会被引用。如果想要获取某个对象的弱引用，可以使用 <code>weakref.ref(obj)</code>  函数。</p>
<h3 id="section32python">3.2 Python 风格的对象</h3>
<h4 id="section321">3.2.1 静态函数与类方法</h4>
<p>静态函数其实和类的方法没什么关系，它只是恰好定义在类的内部而已，所以这里我用函数（function) 来形容它。它可以没有参数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @staticmethod   # 用 staticmethod 这个修饰器来表明函数是静态的</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">Person.sayHello() <span class="hljs-comment"># 输出 'Hello`</span>
</div></li></ul></code></pre>
<p>静态函数的调用方式是类名加上函数名。类方法的调用方式也是这样，唯一的不同是需要用 <code>@staticmethod</code> 修饰器，而且方法的第一个参数必须是类：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @classmethod    # 用 classmethod 这个修饰器来表明这是一个类方法</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span><span class="hljs-params">(cls)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'Hi: '</span> + cls.__name__)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">Person.sayHi() <span class="hljs-comment"># 输出 'Hi: Person`</span>
</div></li></ul></code></pre>
<p>类方法和静态函数的调用方法一致，在定义时除了修饰器不一样，唯一的区别就是类方法需要多声明一个参数。这样看起来比较麻烦，但静态函数无法引用到类对象，自然就无法访问类的任何属性。</p>
<p>于是问题来了，静态函数有何意义呢？有的人说类名可以提供命名空间的概念，但在我看来这种解释并不成立，因为每个 Python 文件都可以作为模块被别的模块引用，把静态函数从类里抽取出来，定义成全局函数，也是有命名空间的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-comment"># 在 module1.py 文件中：</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">global</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span> 
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Util</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @staticmethod</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 在 module2.py 文件中：</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> module1
</div></li><li><div class="code_line">module1.<span class="hljs-keyword">global</span>()        <span class="hljs-comment"># 调用全局函数</span>
</div></li><li><div class="code_line">module1.Util.helper()   <span class="hljs-comment"># 调用静态函数</span>
</div></li></ul></code></pre>
<p>从这个角度看，定义在类中的静态函数不仅不具备命名空间的优点，甚至调用语法还更加啰嗦。对此，我的理解是：<strong>静态函数可以被继承、重写，但全局函数不行</strong>，由于 Python 中的函数是一等公民，因此很多时候用函数替代类都会使代码更加简洁，但缺点就是无法继承，后面还会有更多这样的例子。</p>
<h4 id="section322attribute">3.2.2 属性 attribute</h4>
<p>Python （等多数动态语言）中的类并不像 C/OC/Java 这些静态语言一样，需要预先定义属性。我们可以直接在初始化函数中创建属性：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.name  <span class="hljs-comment"># 值是 'bestswifter'</span>
</div></li></ul></code></pre>
<p>由于 <code>__init__</code> 函数是运行时调用的，所以我们可以直接给对象添加属性：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">bs.age  <span class="hljs-comment"># 因为刚刚赋值了，所以现在取到的值是 22</span>
</div></li></ul></code></pre>
<p>如果访问一个不存在的属性，将会抛出异常。从以上特性来看，对象其实和字典非常相似，但这种过于灵活的特性其实蕴含了潜在的风险。比如某个封装好的父类中定义了许多属性， 但是子类的使用者并不一定清楚这一点，他们很可能会不小心就重写了父类的属性。一种隐藏并保护属性的方式是在属性前面加上两个下划线：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.__name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs.__name          <span class="hljs-comment"># 这样是无法获取属性的</span>
</div></li><li><div class="code_line">bs._Person__name   <span class="hljs-comment"># 这样还是可以读取属性</span>
</div></li></ul></code></pre>
<p>这是因为 Python 会自动处理以双下划线开头的属性，把他们重名为 <code>_Classname__attrname</code> 的格式。由于 Python 对象的所有属性都保存在实例的 <code>__dict__</code>  属性中，我们可以验证一下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs = Person()
</div></li><li><div class="code_line">bs.__dict__ 
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到 {'_Person__name': 'bestswifter'}</span>
</div></li></ul></code></pre>
<p>但很多人并不认可通过名称改写（name mangling) 的方式来存储私有属性，原因很简单，只要知道改写规则，依然<strong>很容易的</strong>就能读写私有属性。与其自欺欺人，不如采用更简单，更通用的方法，比如给私有属性前面加上单个下划线 <code>_</code>。</p>
<p>注意，以单个下划线开头的属性不会触发任何操作，完全靠自觉与共识。<strong>任何稍有追求的 Python 程序员，都不应该读写这些属性。</strong></p>
<h4 id="section323property">3.2.3 特性 property</h4>
<p>使用过别的面向对象语言的读者应该都清楚属性的 <code>getter</code> 和 <code>setter</code> 函数的重要性。它们封装了属性的读写操作，可以添加一些额外的逻辑，比如校验新值，返回属性前做一些修饰等等。最简陋的 <code>getter</code> 和 <code>setter</code> 就是两个普通函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self.name.upper()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span><span class="hljs-params">(self, new_name)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> isinstance(new_name, str):
</div></li><li><div class="code_line">            self.name = new_name.lower()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.get_name()   <span class="hljs-comment"># 得到大写的名字： 'BESTSWIFTER'</span>
</div></li><li><div class="code_line">bs.set_name(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 由于新的名字不是字符串，所以无法赋值</span>
</div></li><li><div class="code_line">bs.get_name()   <span class="hljs-comment"># 还是老的名字： 'BESTSWIFTER'</span>
</div></li></ul></code></pre>
<p>工作虽然完成了，但方法并不高明。在 1.2.3 节中我们就见识到了 Python 的一个特点：“内部高度封装，完全对外透明”。这里手动调用 <code>getter</code> 和 <code>setter</code> 方法显得有些愚蠢、啰嗦，比如对比下面的两种写法，在变量名和函数名很长的情况下，差距会更大：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs.name += <span class="hljs-string">'1995'</span>
</div></li><li><div class="code_line">bs.set_name(bs.get_name() + <span class="hljs-string">'1995'</span>)
</div></li></ul></code></pre>
<p>Python 提供了 <code>@property</code> 关键字来装饰 <code>getter</code> 和 <code>setter</code> 方法，这样的好处是可以直接使用点语法，了解 Objective-C 的读者对这一特性一定倍感亲切：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @property                        # 定义 getter</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>                  <span class="hljs-comment"># 函数名就是点语法访问的属性名</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self._name.upper()    <span class="hljs-comment"># 现在真正的属性是 _name 了</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-meta">    @name.setter                     # 定义 setter</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self, new_name)</span>:</span>        <span class="hljs-comment"># 函数名不变</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> isinstance(new_name, str):
</div></li><li><div class="code_line">            self._name = new_name.lower()  <span class="hljs-comment"># 把值存到私有属性 _name 里</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.name      <span class="hljs-comment"># 其实调用了 name 函数，得到大写的名字： 'BESTSWIFTER'</span>
</div></li><li><div class="code_line">bs.name = <span class="hljs-number">1</span>  <span class="hljs-comment"># 其实调用了 name 函数，因为类型不符，无法赋值</span>
</div></li><li><div class="code_line">bs.name      <span class="hljs-comment"># 还是老的名字： 'BESTSWIFTER'</span>
</div></li></ul></code></pre>
<p>我们已经在 2.4 节详细学习了装饰器，应该能意识到这里的 <code>@property</code> 和 <code>@xxx.setter</code> 都是装饰器。因此上述写法实际上等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self._name.upper()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span><span class="hljs-params">(self, new_name)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> isinstance(new_name, str):
</div></li><li><div class="code_line">            self._name = new_name.lower()
</div></li><li><div class="code_line">    <span class="hljs-comment"># 以上是老旧的 getter 和 setter 定义</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 如果不用 @property，可以定义一个 property 类的实例</span>
</div></li><li><div class="code_line">    name = property(get_name, set_name)
</div></li></ul></code></pre>
<p>可见，特性的本质是给类创建了一个类属性，它是 <code>property</code> 类的实例，构造方法中需要把 <code>getter</code>、<code>setter</code> 等函数传入，我们可以打印一下类的 <code>name</code> 属性来证明：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">Person.name  <span class="hljs-comment"># &lt;property object at 0x107c99868&gt;</span>
</div></li></ul></code></pre>
<p>理解特性的工作原理至关重要。以这里的 <code>name</code> 特性为例，我们访问了对象的 <code>name</code> 属性，但是它并不存在，所以会尝试访问类的 <code>name</code> 属性，这个属性是 <code>property</code> 类的实例，会对读写操作做特殊处理。这也意味着，如果我们重写了类的 <code>name</code> 属性，那么对象的读写方法就不会生效了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs = Person()
</div></li><li><div class="code_line">Person.name = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">bs.name  <span class="hljs-comment"># 实例并没有 name 属性，因此会访问到类的属性 name，现在的值是 'hello` 了</span>
</div></li></ul></code></pre>
<p>如果访问不存在的属性，默认会抛出异常，但如果实现了 <code>__getattr__</code> 函数，还有一次挽救的机会：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, attr)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.name    <span class="hljs-comment"># 直接访问属性</span>
</div></li><li><div class="code_line">bs.age     <span class="hljs-comment"># 得到 0，这是 __getattr__ 方法提供的默认值</span>
</div></li><li><div class="code_line">bs.age = <span class="hljs-number">1</span> <span class="hljs-comment"># 动态给属性赋值</span>
</div></li><li><div class="code_line">bs.age     <span class="hljs-comment"># 得到 1，注意！！！这时候就不会再调用 __getattr__ 方法了</span>
</div></li></ul></code></pre>
<p>由于 <code>__getattr__</code> 只是兜底策略，处理一些异常情况，并非每次都能被调用，所以不能把重要的业务逻辑写在这个方法中。</p>
<h4 id="section324">3.2.4 特性工厂</h4>
<p>在上一节中，我们利用特性来封装 <code>getter</code> 和 <code>setter</code>，对外暴露统一的读写接口。但有些 <code>getter</code> 和 <code>setter</code> 的逻辑其实是可以复用的，比如商品的价格和剩余数量在赋值时，都必须是大于 0 的数字。这时候如果每次都要写一遍 <code>setter</code>，代码就显得很冗余，所以我们需要一个能批量生产特性的函数。由于我们已经知道了特性是 <code>property</code> 类的实例，而且是类的属性，所以代码可以这样写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quantity</span><span class="hljs-params">(storage_name)</span>:</span>  <span class="hljs-comment"># 定义 getter 和 setter</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_getter</span><span class="hljs-params">(instance)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[storage_name]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_setter</span><span class="hljs-params">(instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            <span class="hljs-comment"># 把值保存在实例的 __dict__ 字典中</span>
</div></li><li><div class="code_line">            instance.__dict__[storage_name] = value 
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> property(qty_getter, qty_setter) <span class="hljs-comment"># 返回 property 的实例</span>
</div></li></ul></code></pre>
<p>有了这个特性工厂，我们可以这样来定义特性：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>:</span>
</div></li><li><div class="code_line">    price = quantity(<span class="hljs-string">'price'</span>)
</div></li><li><div class="code_line">    number = quantity(<span class="hljs-string">'number'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = Item()
</div></li><li><div class="code_line">i.price = <span class="hljs-number">-1</span> 
</div></li><li><div class="code_line"><span class="hljs-comment"># Traceback (most recent call last):</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ValueError: value must be &gt; 0</span>
</div></li></ul></code></pre>
<p>作为追求简洁的程序员，我们不禁会问，在 <code>price = quantity('price')</code> 这行代码中，属性名重复了两次，能不能在 <code>quantity</code> 函数中自动读取左边的属性名呢，这样代码就可以简化成 <code>price = quantity()</code> 了。</p>
<p>答案显然是否定的，因为右边的函数先被调用，然后才能把结果赋值给左边的变量。不过我们可以采用迂回策略，变相的实现上面的需求：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quantity</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">try</span>:
</div></li><li><div class="code_line">        quantity.count += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">except</span> AttributeError:
</div></li><li><div class="code_line">        quantity.count = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    storage_name = <span class="hljs-string">'_{}:{}'</span>.format(<span class="hljs-string">'quantity'</span>, quantity.count)  
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_getter</span><span class="hljs-params">(instance)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[storage_name]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_setter</span><span class="hljs-params">(instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            instance.__dict__[storage_name] = value
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> property(qty_getter, qty_setter)
</div></li></ul></code></pre>
<p>这段代码中我们利用了两个技巧。首先函数是一等公民， 所以函数也是对象，自然就有属性。所以我们利用 <code>try ... except</code> 很容易的就给函数工厂添加了一个计数器对象 <code>count</code>，它每次调用都会增加，然后再拼接成存储时用的键 <code>storage_name</code> ，并且可以保证不同 <code>property</code> 实例的存储键名各不相同。</p>
<p>其次，<code>storage_name</code> 在 <code>getter</code> 和 <code>setter</code> 函数中都被引用到，而这两个函数又被 <code>property</code> 的实例引用，所以 <code>storage_name</code> 会因为被持有而延长生命周期。这也正是闭包的一大特性：能够捕获自由变量并延长它的生命周期和作用域。</p>
<p>我们来验证一下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>:</span>
</div></li><li><div class="code_line">    price = quantity()
</div></li><li><div class="code_line">    number = quantity()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = Item()
</div></li><li><div class="code_line">i.price = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">i.number = <span class="hljs-number">2</span>
</div></li><li><div class="code_line">i.price     <span class="hljs-comment"># 得到 1，可以正常访问</span>
</div></li><li><div class="code_line">i.number    <span class="hljs-comment"># 得到 2，可以正常访问</span>
</div></li><li><div class="code_line">i.__dict__  <span class="hljs-comment"># {'_quantity:0': 1, '_quantity:1': 2}</span>
</div></li></ul></code></pre>
<p>可见现在存储的键名可以被正确地自动生成。</p>
<h4 id="section325">3.2.5 属性描述符</h4>
<p>文件描述符的作用和特性工厂一样，都是为了批量的应用特性。它的写法也和特性工厂非常类似：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quantity</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, storage_name)</span>:</span>
</div></li><li><div class="code_line">        self.storage = storage_name
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[self.storage]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            instance.__dict__[self.storage] = value
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li></ul></code></pre>
<p>主要有以下几个改动：</p>
<ol>
<li>不用返回 <code>property</code> 类的实例了，因此 <code>getter</code> 和 <code>setter</code> 方法的名字是固定的，这样才能满足协议。</li>
<li><code>__get__</code> 方法的第一个参数是描述符类 <code>Quantity</code> 的实例，第二个参数 <code>self</code> 是要读取属性的实例，比如上面的 <code>i</code>，也被称作托管实例。第三个参数是托管类，也就是 <code>Item</code>。</li>
<li><code>__set__</code> 方法的前两个参数含义类似，第三个则是要读取的属性名，比如 <code>price</code>。</li>
</ol>
<p>和特性工厂类似，属性描述符也可以实现 <code>storage_name</code> 的自动生成，这里就不重复代码了。看起来属性描述符和特性工厂几乎一样，但由于属性描述符是类，它就可以继承。比如这里的 <code>Quantity</code> 描述符有两个功能：自动存储和值的校验。自动存储是一个非常通用的逻辑，而值的校验是可变的业务逻辑，所以我们可以先定义一个 <code>AutoStorage</code> 描述符来实现自动存储功能，然后留下一个空的 <code>validate</code> 函数交给子类去重写。</p>
<p>而特性工厂作为函数，自然就没有上述功能，这两者的区别类似于 3.2.1 节中介绍的静态函数与全局函数的区别。</p>
<h4 id="section326">3.2.6 实例属性的查找顺序</h4>
<p>我们知道类的属性都会存储在 <code>__dict__</code> 字典中，即使没有显式的给属性赋值，但只要字典里面有这个字段，也是可以读取到的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">p.__dict__[<span class="hljs-string">'name'</span>] = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">p.name  <span class="hljs-comment"># 不会报错，而是返回字典中的值，'bestswifter'</span>
</div></li></ul></code></pre>
<p>但我们在特性工厂和属性描述符的实现中，都是直接把属性的值存储在 <code>__dict__</code> 中，而且键就是属性名。之前我们还介绍过，特性的工作原理是没有直接访问实例的属性，而是读取了 <code>property</code> 的实例。那直接把值存在 <code>__dict__</code> 中，会不会导致特性失效，直接访问到原始内容呢？从之前的实践结果来看，答案是否定的，要解释这个问题，我们需要搞明白访问实例属性的查找顺序。</p>
<p>假设有这么一段代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">o = cls()   <span class="hljs-comment"># 假设 o 是 cls 类的实例</span>
</div></li><li><div class="code_line">o.attr      <span class="hljs-comment"># 试图访问 o 的属性 attr</span>
</div></li></ul></code></pre>
<p>再对上一节中的属性描述符做一个简单的分类：</p>
<ol>
<li>覆盖型描述符：定义了 <code>__set__</code> 方法的描述符</li>
<li>非覆盖型描述符：没有定义 <code>__set__</code> 方法的描述符</li>
</ol>
<p>在执行 <code>o.attr</code> 时，查找顺序如下：</p>
<ol>
<li>如果 <code>attr</code> 出现在 <code>cls</code> 或父类的 <code>__dict__</code> 中，且 <code>attr</code> 是覆盖型描述符，那么调用 <code>__get__</code> 方法。</li>
<li>否则，如果 <code>attr</code> 出现在 <code>o</code> 的<code>__dict__</code> 中，返回 <code>o.__dict__[attr]</code></li>
<li>否则，如果<code>attr</code> 出现在 <code>cls</code> 或父类的 <code>__dict__</code> 中，如果 <code>attr</code> 是非覆盖型描述符，那么调用 <code>__get__</code> 方法。</li>
<li>否则，如果没有非覆盖型描述符，直接返回 <code>cls.__dict__[attr]</code></li>
<li>否则，如果 <code>cls</code> 实现了 <code>__getattr__</code> 方法，调用这个方法</li>
<li>抛出 <code>AttributeError</code></li>
</ol>
<p>所以，在访问类的属性时，覆盖型描述符的优先级是高于直接存储在 <code>__dict__</code> 中的值的。</p>
<h3 id="section33">3.3 多继承</h3>
<p>本节内容部分摘自我的这篇文章：<a href="http://www.jianshu.com/p/fc105512bf40" target="_blank">从 Swift 的面向协议编程说开去</a>，本节聊的是多继承在 Python 中的知识，如果想阅读关于多继承的讨论，请参考原文。</p>
<h4 id="section331">3.3.1 多继承的必要性</h4>
<p>很多语言类的书籍都会介绍，多继承是个危险的行为。诚然，狭义上的多继承在绝大多数情况下都是不合理的。这里所谓的 <strong>“狭义”</strong>，指的是一个类拥有多个父类。我们要明确一个概念：继承的目的不是代码复用，而是声明一种 <code>is a</code> 的关系，代码复用只是 <code>is a</code> 关系的一种外在表现。</p>
<p>因此，如果你需要狭义上的多继承，还是应该先问问自己，真的存在这么多 <code>is a</code> 的关系么？你是需要声明这种关系，还是为了代码复用。如果是后者，有很多更优雅的解决方案，因为多继承的一个直接问题就是菱形问题（Diamond Problem）。</p>
<p>但是广义上的多继承是必须的，不能因为害怕多继承的问题就忽略多继承的优点。<strong>广义多继承</strong> 指的是通过定义接口（Interface）以及接口方法的默认实现，形成“一个父类，多个接口”的模式，最终实现代码的复用。当然，不是每个语言都有接口的概念，比如 Python 里面叫 Mixin，会在 3.3.3 节中介绍。</p>
<p>广义上的多继承非常常见，有一些教科书式的例子，比如动物可以按照哺乳动物，爬行动物等分类，也可以按照有没有翅膀来分类。某一个具体的动物可能满足上述好几类。在实际的开发中也到处都是广义多继承的使用场景，比如 iOS 或者安卓开发中，系统控件的父类都是固定的，如果想让他们复用别的父类的代码，就会比较麻烦。</p>
<h4 id="section332python">3.3.2 Python 的多继承</h4>
<p>Python 语法直接支持多继承：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'A'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-params">(A)</span>:</span>     <span class="hljs-comment"># 继承自 A，重写 foo 方法</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'B'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span><span class="hljs-params">(A)</span>:</span>     <span class="hljs-comment"># 继承自 A，重写 foo 方法</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'C'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span><span class="hljs-params">(B, C)</span>:</span>  <span class="hljs-comment"># 多继承的语法，父类之间用逗号间隔</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = D()
</div></li><li><div class="code_line">d.foo()         <span class="hljs-comment"># 输出：'B'</span>
</div></li></ul></code></pre>
<p>这就是著名的菱形问题，D 继承自 B 和 C，而 B 和 C 都继承自 A，他们的继承关系构成一个菱形。调用 D 类实例的 <code>foo</code> 方法会让人产生疑惑，它的父类们都实现了 <code>foo</code> 方法，到底以谁为准？</p>
<p>Python 有一套算法来计算遍历顺序，这个顺序叫做<strong>方法解析顺序（Method Resolution Oder，MRO）</strong>。这个算法叫做 C3 算法，可以参考这篇官方文档：<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank">The Python 2.3 Method Resolution Order</a></p>
<p>不过在绝大多数情况下，除非你的代码极度依赖多继承，否则都不需要了解这个算法的具体工作原理。一方面，我们可以调用某个特定父类的方法。我们也许已经注意到两个事实，首先类中定义的方法其实都是类的属性，但调用者都是类的实例。其次，类方法的第一个参数都是 <code>self</code>，表示方法的调用者，但我们调用时并不需要传入实例。这是因为其实实例方法的正规调用方式是这样的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">C.foo(C())
</div></li><li><div class="code_line"><span class="hljs-comment"># 或者是</span>
</div></li><li><div class="code_line">C.foo(d)
</div></li></ul></code></pre>
<p>这种调用方式符合定义，而且能够解释上述的两个疑问。然而这种调用方式不仅写起来麻烦，还很不合理，因为我们不仅要实例对象，还需这个实例所属的类才能调用。因此，Python 的做法是将类中定义的方法绑定到每一个实例上：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">D.foo  <span class="hljs-comment"># &lt;function B.foo at 0x10696c158&gt; 这个是真正的方法对象</span>
</div></li><li><div class="code_line">d      <span class="hljs-comment"># &lt;__main__.D object at 0x1075fa400&gt;  这个是 D 的一个实例</span>
</div></li><li><div class="code_line">d.foo  <span class="hljs-comment"># &lt;bound method B.foo of &lt;__main__.D object at 0x106967400&gt;&gt; 注意看地址和 d 是一致的</span>
</div></li><li><div class="code_line">d.foo.__self__ <span class="hljs-comment"># &lt;__main__.D object at 0x1075fa400&gt;，通过 __self__ 引用绑定的实例</span>
</div></li></ul></code></pre>
<p>可以清楚的从 <code>d.foo</code> 的输出结果看出来，它是绑定到 <code>d</code> 对象上的函数，第一个参数 <code>self</code> 就是 <code>d</code>。</p>
<p>另一方面，我们不仅可以调用任意父类的方法，还可以通过类的 <code>__mro__</code> 属性查看父类的继承顺序：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">D.__mro__
</div></li><li><div class="code_line"><span class="hljs-comment"># (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span>
</div></li></ul></code></pre>
<p>所以，多继承的方法调用顺序一般情况下不会对开发代码造成太大的困扰。</p>
<h4 id="section333mixin">3.3.3 Mixin</h4>
<p>Mixin 不是 <strong>迷信</strong> 的拼音，它表示<strong>混入</strong>，可以方便的实现代码复用。在 Python 中，Mixin 是以多继承的形式实现的，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSONable</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_json</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">         <span class="hljs-keyword">return</span> str(self.__dict__)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugMixin</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">         <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller</span><span class="hljs-params">(BaseController, JSONable, DebugMixin)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li></ul></code></pre>
<p>Mixin 和多继承最大的区别在于它一般不产生菱形问题，但 Python 并没有语法层面的约束来保证这一点，所以对于 Mixin，我们一般需要遵守以下几个约定：</p>
<ol>
<li>一般命名以 Mixin、able、ible 结尾，明确表示混入，或者提供某种能力。</li>
<li>一般不要有复杂的继承关系，尤其不要和被混入的类（比如上面的 <code>Controller</code> 类）有共同的父类，避免菱形问题。</li>
<li>一般提供简单的功能，如果有多个功能，就写成多个 Mixin。</li>
<li>功能完备、独立，不要依赖被混入的类。</li>
<li>看到上述命名风格的类，不要实例化他们，仅用在多继承中。</li>
</ol>
<p>在 5.3.2 节中会有实际的 Mixin 的使用场景。</p>
<h4 id="section334">3.3.4 抽象类</h4>
<p>有时候我们需要在父类定义一个方法，然后交给子类去实现。这种方法叫做抽象方法， 定义了抽象方法的类叫做抽象类。抽象类不应该被实例化，在 Java 中，<code>Interface</code> 就是抽象类，它不能被实例化，只有实现了协议的类才能创建实例。</p>
<p>在 Python 中，抽象类需要把自己的 <code>metaclass</code> 设置为 <code>abc.ABCMeta</code>，并且用装饰器去标记抽象函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> abc
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseItem</span><span class="hljs-params">(Base, metaclass=abc.ABCMeta)</span>:</span>   <span class="hljs-comment"># 需要标记 metaclass</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @abc.abstractmethod                        # 抽象函数</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_price</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">         <span class="hljs-string">"""Method that should do something."""</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">item = BaseItem()
</div></li><li><div class="code_line"><span class="hljs-comment"># Traceback (most recent call last):</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># TypeError: Can't instantiate abstract class BaseItem with abstract methods get_price</span>
</div></li></ul></code></pre>
<p>如果设置了 <code>metaclass</code> 并且标记了抽象函数，那么任何没有实现抽象函数的子类（包括抽象类自己）都无法实例化。</p>
<h3 id="section34">3.4 元编程</h3>
<h4 id="section341">3.4.1 类工厂函数</h4>
<p>有些类的功能很单一，仅仅用来存储数据。但如果先声明一个长长的 <code>__init__</code> 函数，再挨个写 <code>self.xxx = xxx</code> 这种模板代码，就显得很啰嗦。其实也可以自己实现一个 1.1.2 节中的具名元组。具名元zu组是一个函数，它返回一个类：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">People = collections.namedtuple(<span class="hljs-string">'People'</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>])
</div></li><li><div class="code_line">p = People(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'22'</span>)
</div></li></ul></code></pre>
<p><code>namedtuple</code> 这种函数可以称为<strong>类工厂函数</strong>，因为它可以根据传入的参数，动态的生成类，我们来实现一个简化版的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_tuple</span><span class="hljs-params">(cls, names)</span>:</span>
</div></li><li><div class="code_line">    names = names.split(<span class="hljs-string">' '</span>)   <span class="hljs-comment"># 这里会得到属性的数组</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, *args)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">for</span> (name, value) <span class="hljs-keyword">in</span> zip(self.__slots__, args):
</div></li><li><div class="code_line">            <span class="hljs-comment"># slots 是属性名，args 是初始化的参数，一一对应起来用 setattr 给实例的属性赋值</span>
</div></li><li><div class="code_line">            setattr(self, name, value)  
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    cls_attrs = dict(__slots__ = names, __init__ = __init__)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> type(cls, (object, ), cls_attrs)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">People = my_tuple(<span class="hljs-string">'People'</span>, <span class="hljs-string">'name age'</span>)
</div></li><li><div class="code_line">p = People(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'22'</span>)
</div></li><li><div class="code_line">p.name   <span class="hljs-comment"># 'bestswifter'</span>
</div></li><li><div class="code_line">p.age    <span class="hljs-comment"># 22</span>
</div></li></ul></code></pre>
<p>这个类工厂非常简陋，比如不支持关键字参数，但用来演示类工厂的原理是已经足够了。类工厂的核心原理在于 <code>type</code> 函数，它不仅可以传入一个实例，返回实例的类型，也可以像这里的使用一样，传入三个参数，构造一个类。第一个参数表示类名，第二个参数是继承关系，最后一个则是类的属性。</p>
<h4 id="section342">3.4.2 元类的概念</h4>
<p>元类和类工厂函数的区别就像属性描述符和特性工厂函数的区别一样，<strong>前者是类，可以继承</strong>，后者不行。就像我们上一节中用 <code>type</code> 来生成类一样，Python 中的类都是 <code>type</code> 类的实例：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-string">'bestswifter'</span>.__class__  <span class="hljs-comment"># &lt;class 'str'&gt;，字符串都是 str 类的实例</span>
</div></li><li><div class="code_line">str.__class__            <span class="hljs-comment"># &lt;class 'type'&gt; str 类是 type 类的实例</span>
</div></li><li><div class="code_line">int.__class__            <span class="hljs-comment"># &lt;class 'type'&gt; int 也是 type 类的实例</span>
</div></li><li><div class="code_line">type.__class__           <span class="hljs-comment"># &lt;class 'type'&gt; type 类是自己的实例，防止死循环</span>
</div></li></ul></code></pre>
<p>需要说明的是，<code>__class__</code> 表示的是元类，而不是父类，父类可以通过 3.3.2 节中介绍的 <code>__mro__</code> 属性来查看：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">int.__mro__  <span class="hljs-comment"># (&lt;class 'int'&gt;, &lt;class 'object'&gt;)</span>
</div></li><li><div class="code_line">str.__mro__  <span class="hljs-comment"># (&lt;class 'str'&gt;, &lt;class 'object'&gt;)</span>
</div></li></ul></code></pre>
<p>可见 <code>int</code> 和 <code>str</code> 这些内置类的父类都是 <code>objcet</code>，我们可以认为 <code>object</code> 是所有类的父类，而 <code>type</code> 是所有类的元类，这个规则在这两个类之间也适用，可以验证一下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">object.__class__   <span class="hljs-comment"># &lt;class 'type'&gt;</span>
</div></li><li><div class="code_line">type.__mro__       <span class="hljs-comment"># (&lt;class 'type'&gt;, &lt;class 'object'&gt;)</span>
</div></li></ul></code></pre>
<p>可见 <code>object</code> 是 <code>type</code> 类构建出来的实例，<code>type</code> 是 <code>object</code> 类的元类，而 <code>object</code> 则是 <code>type</code> 类的父类。如下图所示：<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/7cfd0dcc1843eac2a7e4e84afd794533.png" alt="" style="cursor: zoom-in;"></p>
<p>这里介绍元类和父类并非是为了烧脑，除了描述最基本的概念以外，我们应该意识到，类是由元类的 <code>__init__</code> 方法构造出来的实例，如果我们继承元类并且重写 <code>__init__</code> 方法，就可以控制类的初始化方法。</p>
<h4 id="section343">3.4.3 元类的使用示例</h4>
<p>在介绍属性描述符时，我们用计数器来实现 <code>storage_name</code> 的自动生成，从而避免冗余的代码，但代码的可读性会下降，因为属性的名称无法获得，只能用递增的数字来区别。利用元类，我们可以在不影响可读性的前提下，实现存储名称的自动生成：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quantity</span>:</span>
</div></li><li><div class="code_line">    __counter = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        cls = self.__class__
</div></li><li><div class="code_line">        self.storage = <span class="hljs-string">'_{}#{}'</span>.format(cls.__name__, cls.__counter)
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[self.storage]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            instance.__dict__[self.storage] = value
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># Quantity 类是可以自动生成 storage 名称的描述符类，和之前的逻辑基本类似，可以不用关注</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 继承自 type 类，是一个自定义的元类    </span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuantityMeta</span><span class="hljs-params">(type)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, bases, attr_dict)</span>:</span> 
</div></li><li><div class="code_line">        <span class="hljs-comment"># name 表示类名，bases 是继承关系，attr_dict 则是属性列表，和 type 方法的参数含义一致</span>
</div></li><li><div class="code_line">        super().__init__(name, bases, attr_dict)
</div></li><li><div class="code_line">        <span class="hljs-keyword">for</span> key, attr <span class="hljs-keyword">in</span> attr_dict.items():
</div></li><li><div class="code_line">            <span class="hljs-comment"># 注意，类有很多属性，但只有描述符类型的属性才需要修改</span>
</div></li><li><div class="code_line">            <span class="hljs-keyword">if</span> isinstance(attr, Quantity):
</div></li><li><div class="code_line">                type_name = type(attr).__name__
</div></li><li><div class="code_line">                <span class="hljs-comment"># 这里的 key 就是原来的属性名，比如 price、number</span>
</div></li><li><div class="code_line">                attr.storage = <span class="hljs-string">'_{}#{}'</span>.format(type_name, key)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 为了避免让用户知道太多元类的细节，我们创建一个基类 Entity，并把它的元类设置为 QuantityMeta</span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entity</span><span class="hljs-params">(metaclass=QuantityMeta)</span>:</span> <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 现在用户的类只要继承自 Entity 就可以了</span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span><span class="hljs-params">(Entity)</span>:</span>
</div></li><li><div class="code_line">    price = Quantity()
</div></li><li><div class="code_line">    number = Quantity()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = Item()
</div></li><li><div class="code_line">i.price = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">print(i.__dict__)  <span class="hljs-comment"># 得到 {'_Quantity#price': 1}，可读性良好</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#i.price = -1      # 抛出异常</span>
</div></li></ul></code></pre>
<p>虽然代码比较长，但其实核心很简单，在元类的 <code>__init__</code> 方法中，我们可以获取将要生成的类的名称、父类和属性，就像在类工厂函数中传给 <code>type</code> 类的那些参数一样。有了这些信息，我们可以把当初用计数器生成的临时存储名称给改正为可读性更高的名称。</p>
<h2 id="section4">4. 流程控制</h2>
<h3 id="section41else">4.1 else</h3>
<p>除了最常见的 <code>if ... else ...</code> 语句外，还有很多地方都会用到 <code>else</code>，它的用法各不相同，但如果灵活使用，会使代码更简洁， 更具可读性。</p>
<h4 id="section411forelse">4.1.1 for else</h4>
<p>for 语句的末尾可以加上 else，仅当 for 循环没有因为 break 而终止，顺利运行完以后才运行。这个用法看起来怪怪的，毕竟其他 for 循环后面的代码，也会正常执行。所以这个规则应该反过来理解：<strong>如果 for 循环因为 break 而终止，else 代码块就不会执行</strong>。</p>
<p>有过一些编程经验的读者应该经常会写出这样的代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">found = <span class="hljs-keyword">False</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> some_judge(i):  <span class="hljs-comment"># 只要找到一个满足条件的，就把 found 置为 True</span>
</div></li><li><div class="code_line">        found = <span class="hljs-keyword">True</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">break</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found:          <span class="hljs-comment"># 如果全都不符合条件，执行某个逻辑</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Nothing found'</span>)
</div></li></ul></code></pre>
<p>如果用 <code>else</code> 语句，代码就会简化：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> some_judge(i):
</div></li><li><div class="code_line">        <span class="hljs-keyword">break</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Nothing found'</span>)
</div></li></ul></code></pre>
<p>如果 <code>if</code> 判断成立了，就会进入 <code>break</code>，于是 <code>else</code> 的代码就不会执行，否则就会输出 Nothing found。和上面的例子相比，使用 <code>else</code> 的代码更简洁，而且不需要再用一个变量来标记了。</p>
<h4 id="section412whileelse">4.1.2 while else</h4>
<p>仅当 <code>while</code> 循环因为判断条件不成立而退出，而不是因为 <code>break</code> 才退出时，才会执行 <code>else</code> 代码块，用法和 <code>for ... else ...</code> 基本一致。</p>
<h4 id="section413tryelse">4.1.3 try else</h4>
<p>仅当 <code>try</code> 代码块中没有抛出异常时才会执行 <code>else</code>。为了理解 <code>try ... else</code> 的使用场景，我们先看一个常见的场景。</p>
<p>一个很常见的错误是为了处理异常，把一大段代码都放在 <code>try</code> 语句中：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">try</span>:
</div></li><li><div class="code_line">    <span class="hljs-comment"># 写了几十行毫无问题的代码</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    some_dangarous_operation()
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 下面跟了几十行毫无问题的代码</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
</div></li><li><div class="code_line">    <span class="hljs-comment"># 处理异常</span>
</div></li></ul></code></pre>
<p>这种写法非常不负责任，<code>try</code> 不是防止崩溃的银弹，而是应该用在真正可能导致异常的函数上，所以要保证 <code>try</code> 的代码块尽可能简单，突出要尝试执行的代码。以这段代码为例，<code>some_dangarous_operation</code> 函数之前的代码可以放在 <code>try</code> 代码块上面写，但如果 <code>some_dangarous_operation</code> 函数之后的代码依赖于这个函数的正确执行，就不太好独立出来了。这时候就该 <code>try ... else</code> 发挥作用了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-comment"># some_dangarous_operation 之前的安全代码写在这里</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">try</span>:
</div></li><li><div class="code_line">    some_dangarous_operation()
</div></li><li><div class="code_line"><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
</div></li><li><div class="code_line">    <span class="hljs-comment"># 处理异常</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 依赖于 some_dangarous_operation 的安全代码</span>
</div></li></ul></code></pre>
<h3 id="section42">4.2 迭代器</h3>
<h4 id="section421">4.2.1 迭代器</h4>
<p>迭代器接口定义了两个方法，<code>__next__</code>  方法没有参数，用于返回序列的下一个元素，如果没有元素就抛出 <code>StopIteration</code> 异常，<code>__iter__</code>方法返回自己。</p>
<p>根据鸭子类型的定义，一个类不用声明为迭代器，只要它实现了迭代器接口中定义的两个方法，就可以迭代：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterator</span>:</span>
</div></li><li><div class="code_line">    index = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> self.index &gt; <span class="hljs-number">2</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span>  StopIteration
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            self.index += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> self.index
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = MyIterator()
</div></li><li><div class="code_line">next(i) <span class="hljs-comment"># 得到 1，i 的 index 为 1</span>
</div></li><li><div class="code_line">next(i) <span class="hljs-comment"># 得到 1，i 的 index 为 2</span>
</div></li><li><div class="code_line">next(i) <span class="hljs-comment"># 得到 1，i 的 index 为 3</span>
</div></li><li><div class="code_line">next(i) <span class="hljs-comment"># 根据 if 判断的条件，抛出 StopIteration 异常，迭代结束</span>
</div></li></ul></code></pre>
<p><code>next</code> 函数的参数是迭代器，用于获取迭代器中的下一个元素。</p>
<h4 id="section422">4.2.2 可迭代对象</h4>
<p>用 <code>next</code> 函数去迭代一个迭代器对象，不仅语法繁琐，每次还要用 <code>try catch</code> 来处理随时都有可能发生的 <code>StopIteration</code> 异常，这种写法实在是太啰嗦了。所以我们平时都用 <code>for in</code> 语法来遍历字符串、数组等可迭代对象：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">'bestswifter'</span>:
</div></li><li><div class="code_line">    print(c)
</div></li></ul></code></pre>
<p>这种写法其实是对迭代器的封装：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">it = iter(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line"><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">    <span class="hljs-keyword">try</span>:
</div></li><li><div class="code_line">        print(next(it))
</div></li><li><div class="code_line">    <span class="hljs-keyword">except</span> StopIteration:
</div></li><li><div class="code_line">        <span class="hljs-keyword">del</span> it
</div></li><li><div class="code_line">        <span class="hljs-keyword">break</span>
</div></li></ul></code></pre>
<p>可见 <code>for in</code> 语法省略了大量的模板代码。可以看到这里的字符串是可迭代对象，在用 <code>for in</code> 遍历时，其实是通过 <code>iter</code> 函数获取了可迭代对象的迭代器，然后用 <code>next</code> 函数去遍历这个迭代器，这揭示了迭代器和可迭代对象之间重要的关系：<strong>Python 用 iter 函数从可迭代对象中获取迭代器</strong>。</p>
<h4 id="section423__iter__">4.2.3 \__iter__ 方法</h4>
<p>能够用 <code>for in</code> 语法遍历的对象必须是可迭代的，除了内置的数组、元组等类型外，自定义的类型也有办法变成可迭代的，因为 <code>iter</code> 函数最终会调用对象的  <code>__iter</code> 方法。我们只要能实现这个方法，返回适当的迭代器，就可以让对象变成可迭代的，并支持 <code>for in</code> 语法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> iter([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> Foo():
</div></li><li><div class="code_line">    print(i) <span class="hljs-comment"># 共三行输出，分别是 1、2 和 3</span>
</div></li></ul></code></pre>
<p>没实现 <code>__iter__</code> 方法，但是实现了 <code>__getitem__</code> 方法的对象也是可迭代的，这个函数在 1.1.5 节中已经介绍过，用来处理下标访问。Python 会创建一个迭代器，并且用从 0 开始的整数调用 <code>__getitem__</code> 方法作为迭代器的 <code>next</code> 值。如果实现了 <code>__len__</code> 是最好，Python 解释器只会调用指定次数的 <code>__getitem__</code>，否则会在越界时自动停止。</p>
<p>再次总结下，可迭代对象和迭代器是两个概念，写在 <code>for in</code> 中的是可迭代对象，它需要实现 <code>__iter__</code> 方法为 <code>iter</code> 方法提供一个迭代器。迭代器需要满足迭代器接口， 也就是两个函数。无参数的 <code>__next__</code> 方法提供下一个元素或者抛出异常，<code>__iter__</code> 函数返回自己。从这个角度看，迭代器都是可迭代对象。</p>
<h4 id="section424">4.2.4 标准迭代器</h4>
<p>有了上述知识作为铺垫，我们来尝试实现一个定义的可迭代对象。它只需要实现一个 <code>__iter__</code> 方法，返回迭代器即可，一个常见的写法如下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span>:</span>
</div></li><li><div class="code_line">    count = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    _private_data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> self.count &lt; len(self._private_data):
</div></li><li><div class="code_line">            temp = self._private_data[self.count]
</div></li><li><div class="code_line">            self.count += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> temp
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> StopIteration
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">c = MyCollection()
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c:
</div></li><li><div class="code_line">    print(i) <span class="hljs-comment"># 输出三行，分别是 1，2 和 3</span>
</div></li></ul></code></pre>
<p>这段代码中，<code>__iter__</code> 函数返回了自己，并且自己实现了迭代器的接口，一切运行正常。</p>
<p>并且这段代码向我们展示了迭代器的第一个特点：<strong>屏蔽内部的存取细节， 对外提供统一的访问逻辑。</strong></p>
<p>很可惜的是，这段代码是<strong>标标准准的错误写法</strong>，因为可迭代对象的迭代器一定不能是自己，或者说可迭代对象一定不能实现 <code>__next__</code> 方法，理由很简单，看一眼 4.2.1 节中的迭代器，它是一次性的，遍历完以后就回不去了。这里也是同理，如果我们再执行一次 <code>for in</code>，就得不到输出了。换个角度思考，上一节的结论告诉我们，同时实现了 <code>__iter__</code> 和 <code>__iter__</code> 方法的是迭代器，而迭代器是不能用于 <code>for in</code> 语句的。</p>
<p>正确的写法如下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span>:</span>
</div></li><li><div class="code_line">    _private_data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> MyCollectionIterator(self._private_data)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollectionIterator</span>:</span>
</div></li><li><div class="code_line">    count = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, data)</span>:</span>
</div></li><li><div class="code_line">        self.data = data
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> self.count &lt; len(self.data):
</div></li><li><div class="code_line">            temp = self.data[self.count]
</div></li><li><div class="code_line">            self.count += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> temp
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> StopIteration
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> MyCollection():
</div></li><li><div class="code_line">    print(i)
</div></li></ul></code></pre>
<p>代码很长，但思路很简单，就是遵守迭代器和可迭代对象的定义，把一次性的迭代工作交给可以重复创建实例的  <code>MyCollectionIterator</code> 类完成。</p>
<p>这也正是迭代器模式的另一个特点，<strong>对象能够正确保存多次迭代的进度，支持多次迭代。</strong></p>
<h4 id="section425">4.2.5 初识生成器</h4>
<p>稍有追求的程序员都难以容忍这么多模板代码（两个 <code>__iter__</code>， 一个 <code>__next__</code>），好在 Python 的生成器可以简化上述代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span>:</span>
</div></li><li><div class="code_line">    _private_data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self._private_data:
</div></li><li><div class="code_line">            <span class="hljs-keyword">yield</span> i
</div></li></ul></code></pre>
<p>从直观上看，这里用 <code>yield</code> 关键字替换了 <code>return</code>，打破了 “可迭代对象不能实现 <code>__next__</code> ” 的规定，但却能够支持多次遍历，这段代码的工作原理会在介绍完生成器以后解释。</p>
<h3 id="section43">4.3 生成器</h3>
<h4 id="section431">4.3.1 生成器的定义</h4>
<p>先给出生成器的定义：</p>
<ol>
<li>只要函数体重有 <code>yield</code> 关键字，这个函数就是生成器函数</li>
<li>调用生成器函数，会得到<strong>生成器</strong>，生成器函数可以理解为生成器的工厂</li>
<li>调用 <code>next</code> 函数会激发生成器的下一个值</li>
</ol>
<p>举个例子:</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Start'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Continue'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">g = gen()       <span class="hljs-comment"># 注意，这里没有输出！！！</span>
</div></li><li><div class="code_line">print(next(g))  <span class="hljs-comment"># 输出两行，start 和 1</span>
</div></li><li><div class="code_line">print(next(g))  <span class="hljs-comment"># 输出两行，Continue 和 2</span>
</div></li><li><div class="code_line">print(next(g))  <span class="hljs-comment"># 输出 2</span>
</div></li><li><div class="code_line">print(next(g))  <span class="hljs-comment"># 抛出异常 StopIteration</span>
</div></li></ul></code></pre>
<p>从输出内容中可以看出，调用生成器函数会返回一个生成器对象，但生成器函数中的代码不会执行。在调用 <code>next(g)</code> 函数时才会执行生成器函数的代码，阻塞在 <code>yield x</code> 这一行，并且<code>next(g)</code> 函数的返回值就是 <code>x</code>。第几次调用 <code>next</code> 函数，就会阻塞在第几个 <code>yield</code> 处。如果是第一次接触生成器，这个逻辑需要反复体会几次。</p>
<p>生成器的使用方式和迭代器一致，我们可以认为生成器都是迭代器，都实现了迭代器接口。因此 4.2.5 节中的代码就很容易解释了。当外部调用 <code>iter()</code> 函数时，实际上 <code>__iter__</code> 方法中的代码并没有被立刻执行，而是返回了一个生成器。</p>
<h4 id="section432">4.3.2 生成器表达式</h4>
<p>我们在文章开头的 1.1.1 节中介绍了数组推导，生成器表达式可以理解为惰性版的数组推导：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">[x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> array] <span class="hljs-comment"># 数组推导</span>
</div></li><li><div class="code_line">(x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> array) <span class="hljs-comment"># 生成器表达式</span>
</div></li></ul></code></pre>
<p>两者的写法非常类似，只是把数组的大括号换成了圆括号，区别在于前者生成了一个新的数组，如果原来的数组占用 M 兆内存，现在两个数组就会占用 2 * M 兆内存。而生成器是懒计算的，并不增加内存占用。</p>
<p>生成器表达式对于大容量的数组，或者无尽数组特别适用，比如可以写一个斐波那契数组：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    a = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    b = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">        <span class="hljs-keyword">yield</span> b
</div></li><li><div class="code_line">        a, b = b, a + b
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># fib() 可以被当成无尽队列，我们只取前 10 个元素        </span>
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i, n <span class="hljs-keyword">in</span> enumerate(fib()):
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span>:
</div></li><li><div class="code_line">        print(n)
</div></li></ul></code></pre>
<h4 id="section433">4.3.3 协程</h4>
<p>上一节中介绍的生成器有两个小缺点：</p>
<ol>
<li>这段代码无法正常退出，因为 <code>fib</code> 函数是个死循环，最终会停在第 11 个 yield 上，等待外部的 <code>next</code> 函数。</li>
<li>现在的数据传递都是单向的，只有生成器给调用方传值，调用方无法给生成器传值。</li>
</ol>
<p>实际上，生成器函数都是协程，我们可以利用协程的特性解决这两个问题：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">fibs = fib()
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i, n <span class="hljs-keyword">in</span> enumerate(fibs):
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span>:
</div></li><li><div class="code_line">        print(n)
</div></li><li><div class="code_line">    <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">        fibs.close()
</div></li></ul></code></pre>
<p>只要在遍历完以后调用生成器的 <code>close</code> 方法，就可以结束生成器并正确的退出了。如果需要向生成器中传值，需要调用生成器对象的 <code>send</code> 方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    a = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    b = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    i = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">        i = <span class="hljs-keyword">yield</span> <span class="hljs-string">'第{0}个数是: {1}'</span>.format(i, b)
</div></li><li><div class="code_line">        a, b = b, a + b
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">fibs = fib()
</div></li><li><div class="code_line">next(fibs)
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
</div></li><li><div class="code_line">    print(fibs.send(i))
</div></li></ul></code></pre>
<p>此时，<code>yield</code> 表达式左边的值就是 <code>send</code> 函数中的参数，而 <code>send</code> 函数的返回值则是 <code>yield</code> 关键字右边的结果。</p>
<p>协程的用法并不复杂，但它是异步编程的基础，比如 ES 7 中的 <code>async/await</code> 语法，能将异步回调变成同步的写法，它就是依靠协程实现的。感兴趣的读者可以参考我的这篇文章：<a href="http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/" target="_blank">异步与回调的设计哲学</a>。</p>
<h4 id="section434">4.3.4 预激协程</h4>
<p>在创建生成器时，并不会执行生成器函数中的代码，第一次调用 <code>next(g)</code> 函数时会执行到第一个 <code>yield</code> 处。而协程的 <code>send</code> 函数用来给 <code>yield</code> 左侧的变量赋值。所以在调用 <code>send</code> 函数之前一定要确保已经调用过 <code>next()</code> 函数，这样协程才会停留在 <code>yield</code> 处而不是停留在刚创建的状态。这一步操作叫做协程的预激，上一节的代码中已经演示了这一点。</p>
<p>在使用协程时，一般都需要预激，也就是说 <code>next(g)</code> 其实是一个模板代码，可以被优化掉。要想改变一个函数的运行逻辑，最好的方法是使用装饰器：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> functools
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coroutine</span><span class="hljs-params">(original_coroutine)</span>:</span>       
</div></li><li><div class="code_line"><span class="hljs-meta">    @functools.wraps(original_coroutine)</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activate</span><span class="hljs-params">(*args, **kwargs)</span>:</span>  <span class="hljs-comment"># 用 active 函数替换被装饰的 fib 函数</span>
</div></li><li><div class="code_line">        gen = original_coroutine(*args, **kwargs)  <span class="hljs-comment"># 调用 fib 函数</span>
</div></li><li><div class="code_line">        next(gen)  <span class="hljs-comment"># 预激协程</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> gen   <span class="hljs-comment"># 像 fib 函数一样，返回预激过的协程</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> activate  <span class="hljs-comment"># 被装饰的函数 fib 现在替换为了 active 函数，会自动预激</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-meta">@coroutine</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    a = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    b = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    i = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">        i = <span class="hljs-keyword">yield</span> <span class="hljs-string">'第{0}个数是: {1}'</span>.format(i, b)
</div></li><li><div class="code_line">        a, b = b, a + b
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">fibs = fib()
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
</div></li><li><div class="code_line">    print(fibs.send(i))
</div></li></ul></code></pre>
<p>温故一下装饰器的定义，被 <code>coroutine</code> 装饰的 <code>fib</code> 函数等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">new_fib = coroutine(fib)
</div></li><li><div class="code_line"><span class="hljs-comment"># 根据 coroutine 函数的定义，coroutine(fib) 实际上会返回下面这个函数</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activate</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    gen = fib()
</div></li><li><div class="code_line">    next(gen)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> gen
</div></li></ul></code></pre>
<h4 id="section435">4.3.5 标准库中的生成器函数</h4>
<p><code>itertools</code> 模块提供了很多生成器函数，这些函数处理可迭代的对象，并且返回生成器（节省内存，可迭代）。想要了解生成器函数，唯一可能的知识来源就是这篇<a href="https://docs.python.org/3/library/itertools.html#module-itertools" target="_blank">官方文档</a>，本节会做简单的翻译和解释。它把生成器函数分为三大类。</p>
<p>第一类函数返回的是无限生成器：</p>
<table>
<thead>
<tr>
<th style="text-align:left;">函数名</th>
<th style="text-align:left;">参数</th>
<th style="text-align:left;">返回结果</th>
<th style="text-align:left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.count" target="_blank">count()</a></td>
<td style="text-align:left;">start, [step]</td>
<td style="text-align:left;">start, start+step, start+2*step, …</td>
<td style="text-align:left;"><code>count(10) --&gt; 10 11 12 13 14 ...</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://xiaozhuanlan.com/topic/1053427869" target="_blank">copy()</a></td>
<td style="text-align:left;">p（数组）</td>
<td style="text-align:left;">p0, p1, ...， pn, p0, p1, ...</td>
<td style="text-align:left;"><code>cycle('ABCD') --&gt; A B C D A B C D ...</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" target="_blank">repeat()</a></td>
<td style="text-align:left;">elem [,n]</td>
<td style="text-align:left;">elem, elem, elem, … 无尽队列或最多 n 次</td>
<td style="text-align:left;"><code>repeat(10, 3) --&gt; 10 10 10</code></td>
</tr>
</tbody>
</table>
<p>这三个函数的注释都说明得清楚了，配合示例应该非常容易理解。</p>
<p>第二类函数返回的是有限生成器，长度和传入的可迭代对象有关，我选择几个比较常用的列出来 ：</p>
<table>
<thead>
<tr>
<th style="text-align:left;">函数名</th>
<th style="text-align:left;">参数</th>
<th style="text-align:left;">返回结果</th>
<th style="text-align:left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" target="_blank">accumulate()</a></td>
<td style="text-align:left;">p [,func]</td>
<td style="text-align:left;">p0, func(p0, p1), func(p1, p2), func(p2, p3) ...</td>
<td style="text-align:left;"><code>accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.chain" target="_blank">chain()</a></td>
<td style="text-align:left;">p, q, …</td>
<td style="text-align:left;">p0, p1, … plast, q0, q1, …</td>
<td style="text-align:left;"><code>chain('ABC', 'DEF') --&gt; A B C D E F</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.compress" target="_blank">compress()</a></td>
<td style="text-align:left;">data, selectors</td>
<td style="text-align:left;">(d[0] if s[0]), (d[1] if s[1]), …</td>
<td style="text-align:left;"><code>compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" target="_blank">dropwhile()</a></td>
<td style="text-align:left;">pred, seq</td>
<td style="text-align:left;">假设 pred 在第 n 个元素开始不成立：seq[n], seq[n+1]</td>
<td style="text-align:left;"><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.tee" target="_blank">tee()</a></td>
<td style="text-align:left;">it, n</td>
<td style="text-align:left;">产出 n 各元素的数组，每个元素可以看做 it 的备份，相当于把 it 复制了 n 份</td>
<td style="text-align:left;"><code>tee('ABC', 2) --&gt; g1, g2(迭代 g1 和 g2 都会得到 A、B、C)</code></td>
</tr>
</tbody>
</table>
<p>最后一类是可以实现排列组合操作的生成器函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left;">函数名</th>
<th style="text-align:left;">参数</th>
<th style="text-align:left;">返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.product" target="_blank">product()</a></td>
<td style="text-align:left;">p, q, … [repeat=1]</td>
<td style="text-align:left;">生成各个可迭代对象的笛卡尔积，n 表示每个可迭代对象对象重复几次</td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" target="_blank">permutations()</a></td>
<td style="text-align:left;">p[, r]</td>
<td style="text-align:left;">序列 p 所有长度为 r 的无重复元素排列</td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" target="_blank">combinations()</a></td>
<td style="text-align:left;">p, [r]</td>
<td style="text-align:left;">序列 p 所有长度为 r 的无重复元素有序排列</td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" target="_blank">combinations_with_replacement()</a></td>
<td style="text-align:left;">p, [r]</td>
<td style="text-align:left;">序列 p 所有长度为 r 的有重复元素有序排列</td>
</tr>
</tbody>
</table>
<p>举例说明：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> *
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># ABC 和 12 的笛卡尔积，所以共有 6 个元素</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：A1、A2、B1、B2、C1、C2</span>
</div></li><li><div class="code_line">l1 = list(product(<span class="hljs-string">'ABC'</span>, <span class="hljs-string">'12'</span>))
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 相当于 product('AB', 'AB')</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：AA、AB、BA、BB</span>
</div></li><li><div class="code_line">l2 = list(product(<span class="hljs-string">'AB'</span>, repeat=<span class="hljs-number">2</span>))
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># ABCD 所有所有长度为 2 的无重复、无序子排列</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 每个元素可以和除了自己的另外三个元素组合，因此有 4 * 3 个</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：AB、AC、AD、BA、BC、BD、CA、CB、CD、DA、DB、DC</span>
</div></li><li><div class="code_line">l3 = list(permutations(<span class="hljs-string">'ABCD'</span>, <span class="hljs-number">2</span>))
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># ABCD 所有所有长度为 2 的无重复、有序子排列</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># AB 和 BA 会被认为是相同的，所以只有 12 / 2 = 6 个</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># AB、AC、AD、BC、BD、CD</span>
</div></li><li><div class="code_line">l4 = list(combinations(<span class="hljs-string">'ABCD'</span>, <span class="hljs-number">2</span>))
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># ABCD 所有所有长度为 2 的有重复、有序子排列</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># AA、BB 这样的也合法，所以有 6 + 4 = 10 个</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：AA、AB、AC、AD、BB、BC、BD、CC、CD、DD</span>
</div></li><li><div class="code_line">l5 = list(combinations_with_replacement(<span class="hljs-string">'ABCD'</span>, <span class="hljs-number">2</span>))
</div></li></ul></code></pre>
<p>本节仅列出了一部分常用的生成器函数，他们是系统库提供的轮子。因此在自己实现关于序列的操作以前，应该思考下这是否是常见操作，系统是否已经提供了轮子。在<a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" target="_blank">官方文档的最后一节</a> 还有一些基于上述生成器函数的拓展，通过简单的封装了 <code>itertools</code> 模块中的生成器函数，提供了更多常见的函数，比如 <code>take</code>、<code>tail</code>、<code>consume</code>、<code>nth</code>、<code>flatten</code> 等等，<strong>强烈建议阅读一遍并且形成基本印象!</strong></p>
<h3 id="section44">4.4 上下文管理器</h3>
<h4 id="section441with">4.4.1 with 块</h4>
<p><code>with</code> 代码块的一个常见用法是用于打开文件，有经验的 Python 程序员不会建议你写出这样的代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">f = open(file_path)
</div></li><li><div class="code_line">data = f.readlines()
</div></li><li><div class="code_line"><span class="hljs-comment"># 处理 data</span>
</div></li><li><div class="code_line">f.close()
</div></li></ul></code></pre>
<p>用 <code>with</code> 块的写法则是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">with</span> open(file_path) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    data = f.readlines()
</div></li><li><div class="code_line">    <span class="hljs-comment"># 处理 data</span>
</div></li></ul></code></pre>
<p>这样写的好处不仅仅是不用在最后关闭文件。试想一下，如果在处理文件的过程中有多个地方有可能会抛出异常，那么在所有 <code>try catch</code> 语法的最后都要写上 <code>finally</code> 以便关闭文件。如果放到 <code>with</code> 块中写，则不需要在这么多代码。</p>
<h4 id="section442">4.4.2 自定义上下文</h4>
<p><code>with</code> 块的本质是为了简化 <code>try finally</code> 语句，以上一节的代码为例，跟在 <code>with</code> 后面的<code>open()</code> 函数会返回一个对象，它是 <code>TextIOWrapper</code> 类的实例，我们把它称为上下文管理器，上下文管理器需要实现 <code>__enter__</code> 和 <code>__exit__</code> 方法。</p>
<p><code>__enter__</code> 方法的返回值可以用 <code>as</code> 来引用，这里上下文管理器的 <code>__enter__</code> 方法的返回值是 self，所以以下两种写法中的文件句柄 <code>fp</code> 是等价的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">fp = open(file_path)
</div></li><li><div class="code_line"><span class="hljs-keyword">with</span> open(file_path) <span class="hljs-keyword">as</span> fp
</div></li></ul></code></pre>
<p>第一行中的 <code>fp</code> 可以理解为第二行中的上下文管理器，也就是 <code>with</code> 后面表达式的返回值。而 <code>as</code> 后面的 <code>fp</code> 则是上下文管理器的 <code>__enter__</code> 方法的返回值，由于这里返回的是 <code>self</code>，所以两者恰好相同。</p>
<p>无论以哪种方式退出 <code>with</code> 块（正常结束或者因为抛出异常而退出），都会调用上下文管理器的 <code>__exit__</code> 方法。注意，这里不是 <code>__enter__</code> 方法返回值的 <code>__exit__</code> 方法。这一点很好理解，因为前者一定实现了 <code>__enter__</code> 方法，但后者不一定。</p>
<p>了解了上下文的概念后，我们可以自定义一个上下文，其实也就是定义一个实现了 <code>__enter__</code> 和 <code>__exit__</code> 方法的类：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> sys
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reverse</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_write</span><span class="hljs-params">(self, content)</span>:</span>
</div></li><li><div class="code_line">        self.original_write(content[::<span class="hljs-number">-1</span>])
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.original_write = sys.stdout.write
</div></li><li><div class="code_line">        sys.stdout.write = self.reverse_write
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Enter context'</span>[::<span class="hljs-number">-1</span>]  <span class="hljs-comment"># 这个字符串会被倒序打印，所以先倒序一次</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, exc_value, traceback)</span>:</span>
</div></li><li><div class="code_line">        sys.stdout.write = self.original_write
</div></li><li><div class="code_line">        print(exc_type, exc_value, traceback)
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">with</span> Reverse() <span class="hljs-keyword">as</span> r:
</div></li><li><div class="code_line">    print(r)  <span class="hljs-comment"># 因为字符串已经被倒序过，所以这里输出 'Enter context'</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'bestswifter'</span>) <span class="hljs-comment"># 输出 'retfiwstseb'</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">raise</span> AttributeError <span class="hljs-comment"># 输出 &lt;class 'AttributeError'&gt;  &lt;traceback object at 0x10bcb45c8&gt;</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'will not be print'</span>)  <span class="hljs-comment"># 因为发生了异常，所以不会执行这一行</span>
</div></li></ul></code></pre>
<p>在进入上下文的时候，我们用自定义的方法替换了系统的标准输出，所以上下文中所有的输出都是倒序的。直到上下文结束时才换回来。</p>
<p><code>__exit__</code> 方法有三个参数，分别表示异常的类型，异常的实例，以及发生异常处的调用栈。如果在 <code>with</code> 块中发生了异常，异常处后面的代码都不会执行。<code>__exit__</code> 方法如果返回 True，表示异常已经被正确处理，否则异常会向上冒泡到 <code>with</code> 代码块外面。</p>
<h4 id="section443">4.4.3 标准库中的上下文</h4>
<p>使用标准库中的装饰器可以节省一些模板代码，<code>__enter__</code> 和 <code>__exit__</code> 方法可以写在一起，以 <code>yield</code> 为分界线：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@contextlib.contextmanager</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Reverse</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_write</span><span class="hljs-params">(content)</span>:</span>
</div></li><li><div class="code_line">        original_write(content[::<span class="hljs-number">-1</span>])
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    original_write = sys.stdout.write
</div></li><li><div class="code_line">    sys.stdout.write = reverse_write
</div></li><li><div class="code_line">    <span class="hljs-keyword">yield</span> <span class="hljs-string">'Enter context'</span>[::<span class="hljs-number">-1</span>] <span class="hljs-comment"># 下一行开始，是 __exit__ 的逻辑</span>
</div></li><li><div class="code_line">    sys.stdout.write = original_write
</div></li></ul></code></pre>
<p><code>@contextlib.contextmanager</code> 的缺点是无法通过 <code>return True/False</code> 来控制是否需要冒泡异常，必须把 <code>yield</code> 代码放到 <code>try catch</code> 中。</p>
<h2 id="section5python">5. 其他 Python 特色</h2>
<h3 id="section51gil">5.1 多线程与GIL</h3>
<h4 id="section511">5.1.1 多线程</h4>
<p>多线程操作一般通过 <code>threading</code> 模块来完成，启动一个线程其实就是把线程要执行的函数传递到 <code>Thread</code> 类的初始化方法中，然后调用 <code>Thread</code> 实例的 <code>start</code> 方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> threading
</div></li><li><div class="code_line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">think</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'start thinking in thread: '</span> + threading.current_thread().name)
</div></li><li><div class="code_line">    sleep(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">    print(<span class="hljs-string">'end thinking'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):
</div></li><li><div class="code_line">    t = threading.Thread(target = think)
</div></li><li><div class="code_line">    t.start()
</div></li><li><div class="code_line">print(<span class="hljs-string">'Exit'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-1</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-2</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-3</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># Exit</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li></ul></code></pre>
<p>从输出结果来看，Python 的线程都是异步执行，如果要同步执行某个线程，需要调用线程的 <code>join</code> 方法，表示阻塞当前线程，直到整个线程退出为止：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):
</div></li><li><div class="code_line">    t = threading.Thread(target = think)
</div></li><li><div class="code_line">    t.start()
</div></li><li><div class="code_line">    t.join()
</div></li><li><div class="code_line">print(<span class="hljs-string">'Exit'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-1</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-2</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-3</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># Exit</span>
</div></li></ul></code></pre>
<h4 id="section512">5.1.2 线程锁</h4>
<p>像 <code>a += 1</code> 这样的语句，是线程不安全的，因为它不是原子性操作。如果想保证某段代码最多同时被一个线程执行，可以给它加锁：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">i = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">lock = threading.Lock()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">think</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">global</span> i
</div></li><li><div class="code_line">    lock.acquire()
</div></li><li><div class="code_line">    i += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    lock.release()
</div></li></ul></code></pre>
<p>注意到这里的加锁和释放锁又是上下对应的模板代码，这类代码都可以用 <code>with</code> 块配合上下文解决。Python 提供了现成的写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">lock = threading.Lock()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">think</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">global</span> i
</div></li><li><div class="code_line">    <span class="hljs-keyword">with</span> lock:
</div></li><li><div class="code_line">        i += <span class="hljs-number">1</span>
</div></li></ul></code></pre>
<p>在 <code>threading.Lock</code> 类的 <code>__exit__</code> 方法中会自动释放锁。</p>
<h4 id="section513gil">5.1.3 GIL</h4>
<p>我们知道 Python 这种动态语言是由解释器在运行时动态解释并执行的，如果有多个线程同时执行，就意味着有多个解释器也在运行。为了保证解释器自己的线程安全性，有些  Python 解释器（比如最常见的 CPython）采用了一种很暴力的解决方式：<strong>全局锁</strong>，也就是 Global Interpreter Lock， GIL。再次声明，GIL 不是 Python 的特性，仅仅是特定解释器的特性，比如另一个解释器 JPython 就没有 GIL，不过 CPython 是绝大多数场景下默认的 Python 的解释器，所以有人可能会把 GIL 与 Python 混为一谈。</p>
<p>GIL 最直接的副作用就是严重影响多线程的性能，因为同一时刻只有一个线程能获得锁。GIL 可以用如下伪代码表示：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">    acquire GIL
</div></li><li><div class="code_line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):
</div></li><li><div class="code_line">        do_something()
</div></li><li><div class="code_line">    release GIL
</div></li></ul></code></pre>
<p>当某个线程因为睡眠、IO 或超时释放 GIL 后，从代码中可以看到，它距离再次获得 GIL 仅有一条指令。所以在实际运行时，有很大可能是一个线程不断的释放、获取 GIL，而别的线程一直在等待。由于线程上下文切换存在一定的开销，多个 CPU 密集型的线程同时运行，性能反而比在同一个线程内运行要低。</p>
<p>如果是多个 IO 密集型的线程同时运行，GIL 不会影响性能，因为线程在执行 IO 操作时会主动释放 GIL 锁，因此会出现没有线程获取 GIL 锁（因为大家都在 IO），谁结束了 IO 谁就使用线程的情况。不过需要注意的是，多个 IO 密集型的线程和一个 CPU 密集型线程同时执行时，性能也会受到影响。因为之前解释过，CPU 密集型的线程倾向于一直占有 GIL，导致 IO 密集型线程在 IO 结束后无法立刻获取 GIL，空等一段时间。</p>
<p>具体的测试结果可以参考：<a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank">Python的GIL是什么鬼，多线程性能究竟如何</a>。</p>
<p>如果想要避免 GIL 对性能的影响，有以下几种思路：</p>
<ol>
<li>多个 IO 密集型线程不受影响，但不要混入 CPU 密集型线程</li>
<li>使用 JPython 这样的解释器代替 CPython，但这样做就无法再使用社区已有的 C 语言模块</li>
<li>使用多进程，多个进程有多个 GIL，自然就互不干扰</li>
</ol>
<h4 id="section514">5.1.4 多进程</h4>
<p>Python 中实现多进程非常简单，因为接口与多线程基本一致：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> multiprocessing
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> os
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_proc</span><span class="hljs-params">(i)</span>:</span>
</div></li><li><div class="code_line">    print(i)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
</div></li><li><div class="code_line">    p = multiprocessing.Process(target=run_proc, args=(i,))
</div></li><li><div class="code_line">    p.start()
</div></li><li><div class="code_line">print(<span class="hljs-string">'End'</span>)
</div></li></ul></code></pre>
<p>多进程中没有锁的概念，因为不同的线程可以共享进程的堆，而不同的进程就没有应用层面可以共享的内容了，只能依赖于操作系统提供的 API，比如共享内存、socket、管道、消息队列等。</p>
<p>以消息队列为例，简单展示下进程间共享数据：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> os
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_proc</span><span class="hljs-params">(q)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
</div></li><li><div class="code_line">        i = q.get()
</div></li><li><div class="code_line">        i += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">        q.put(i)
</div></li><li><div class="code_line">        print(i)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">q = Queue()
</div></li><li><div class="code_line">q.put(<span class="hljs-number">0</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p1 = Process(target=run_proc, args=(q,))
</div></li><li><div class="code_line">p1.start()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p2 = Process(target=run_proc, args=(q,))
</div></li><li><div class="code_line">p2.start()
</div></li></ul></code></pre>
<p>每个进程都会从消息队列中读取变量，加一后放回队列，所以输出结果是 1 到 20。如果不用消息队列来共享，每个进程的变量 <code>i</code> 都是独立的，会输出两次 1 到 10。</p>
<h3 id="section52python">5.2 我眼中的  Python</h3>
<h4 id="section521python">5.2.1 Python 是动态强类型语言</h4>
<p>这句话其实说了两个概念： <strong>Python 是动态类型语言</strong>，以及 <strong>Python 是强类型语言</strong>，很多人会把这两组概念混淆。</p>
<p>首先，动/静态类型语言的区别在于类型被确认的时机。以 C 这类语言来说，编译器会检查变量的类型，比如 <code>int a = "hello";</code> 就无法通过编译，这就说明 C 语言是静态类型语言。而对于 Python 来说，<code>a = "hello"</code> 直到运行时，才会确定 a 引用的对象的类型是 <code>str</code>。</p>
<p>动态类型语言并非看上去没有类型标记那么简单，一方面，Swift 这样的语言支持类型推导，所以支持 <code>var s = "hello"</code> 这种写法，但这并不意味着 Swift 就是动态类型语言了，因为它的类型判断还是在编译期完成的，只不过编译器更加智能，可以推导出来而已。</p>
<p>另一方面，不在编译期检查类型并不意味着动态类型语言对类型的校验就是宽松的，这是另一个维度的衡量指标。如果语言对类型的校验很宽松，支持隐式转换，我们就称这种语言是 <strong>“弱类型语言”</strong>，否则就是<strong>强类型语言</strong>。强类型语言更严格，一定程度上语法会更啰嗦，弱类型语言代码更简单，更脚本化。以输出 <strong>"My age is 22"</strong> 为例：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">number = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">string = <span class="hljs-string">'My age is '</span>
</div></li><li><div class="code_line">print(string + str(number))
</div></li></ul></code></pre>
<p>这里必须把数字先转为字符串，才能和别的字符串拼接，这是因为 <code>str</code> 类的 <code>__add__</code> 函数只支持 <code>str</code> 类型的参数。可以看到，虽然数字（或者其他实现了 <code>__str__</code> 方法的自定义类）可以转为字符串，但这种转换必须是显式写明的，Python 并不支持隐式转换。</p>
<p>但用别的语言，比如 JavaScript 来实现类似的逻辑就非常简单了：</p>
<pre><code class="javascript language-javascript hljs"><ul><li><div class="code_line">number = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">string = <span class="hljs-string">'My age is '</span>
</div></li><li><div class="code_line"><span class="hljs-built_in">console</span>.log(string + number);
</div></li></ul></code></pre>
<p>可见，JavaScript 支持从数字到字符串的隐式转换。但这种隐式的转换也不一定是好事，比如再举一个例子：</p>
<pre><code class="javascript language-javascript hljs"><ul><li><div class="code_line">number = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">string = <span class="hljs-string">'2'</span>
</div></li><li><div class="code_line"><span class="hljs-built_in">console</span>.log(string + number)
</div></li></ul></code></pre>
<p>它的输出结果是 '222'，可见是把数字隐式的转成了字符串，然而如果我的本意是要把字符串转数字呢，比如这段代码在 PHP 中的输出就是 24：</p>
<pre><code class="PHP language-PHP hljs"><ul><li><div class="code_line"><span class="hljs-meta">&lt;?php</span>
</div></li><li><div class="code_line">    $n = <span class="hljs-number">22</span>;
</div></li><li><div class="code_line">    $s = <span class="hljs-string">"2"</span>;
</div></li><li><div class="code_line">    <span class="hljs-keyword">print</span> $s + $n
</div></li><li><div class="code_line"><span class="hljs-meta">?&gt;</span>
</div></li></ul></code></pre>
<p>因此，关于语言的强/弱类型，我想可以总结两点：</p>
<ol>
<li>类型的强弱是一个相对的概念，不像动态/静态类型那样有明确的判断标准。因为隐式转换可以发生在很多地方，有的语言支持的隐式转换场景很多，有的支持的场景很少，所以一般来说我们只能说某个语言的类型比较强（弱）或者说某个语言的类型比另一个语言更强（弱）。</li>
<li>强弱类型没有优劣之分，强类型语言更严谨，不容易出现 Bug，但是代码复杂，书写成本高。弱类型语言更脚本化，写起来很简单，但很多规则并不那么显然，增加了学习成本。</li>
</ol>
<h4 id="section522">5.2.2 开发效率高</h4>
<p>Python 中到处都是<strong>鸭子类型</strong>的实践：不关注一个类的类型本身，而是关注这个类具有什么能力。比如我们会发现，数组和字符串的下标访问高度类似，这在很多静态类型语言中是几乎不可能发生的。很多自定义类因为使用了多继承、迭代器、双下方法，使用起来与内置的数据类型基本上没有区别。</p>
<p>此外，脚本语言的一个主要特色就是 handy，理论上来说 Python 能做的事，没什么是 C 做不到的。然而我们希望用简单的 API，用文本编辑器花上一两分钟就写出来一个脚本，而不是查阅手册，打开 IDE，编译以后再执行。所以 Python 提供了很多语言层面的支持，比如推导、else 块、切片和功能强大的内置函数等。</p>
<p>另外，Python 具备强大的元编程能力，装饰器、高阶函数、函数内省、元类具有非常强的内省和动态能力。内省帮助我们在运行时获取足够多的信息，动态性帮助我们实现很多很有意思的能力。因此我们看到 Python 中很少有模板代码，虽然内部实现有时候相对晦涩难懂，但对外的接口则是高度统一。</p>
<h4 id="section523">5.2.3 对新人不是很友好</h4>
<p>开发效率高的背后也有隐患，简洁高效的语法可能意味着过度封装，因此 Python 的性能经常遭到抨击（但是脚本语言并不应该考虑这一点）。</p>
<p>鸭子类型容易带来太多的魔术方法。在 Java 中，一切都有迹可循，某个类能调用方法，一定是因为它自己实现了方法，或者从接口、父类那里继承来了。而 Python 不一样，方法的调用和方法的真正实现之间也许没有语言层面的直接关联，而是依靠文档规范、魔术方法或者约定。这给新手阅读 Python 代码带来了极大的困难，通常无从下手，连搜索什么关键字都不知道，这也是本文写作的目的之一。</p>
<p>元编程能力允许用户直接享受到大牛们封装好的库和能力，但也容易被滥用。元编程学习门槛高，而且通常实现一个需求有不止一种方法。如果大家各自造轮子，很可能质量参差不齐，互相理解起来也比较困难。</p>
<h3 id="section53python">5.3 其它 Python 技巧</h3>
<p>很多时候我们从网上摘抄下来的代码仅仅刚好能工作，但对它的细节却不是很了解。本节主要列出一些常用的 Python 代码或者技巧并用实际的例子解释各处细节，持续更新中。</p>
<h4 id="section531">5.3.1 文件读写</h4>
<p>读取文件时，一般会这样写代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'path_to_file'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
</div></li><li><div class="code_line">        print(line)
</div></li><li><div class="code_line"><span class="hljs-comment"># first line</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># second line</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># third line</span>
</div></li></ul></code></pre>
<p><code>open</code> 函数的第二个参数表示打开模式，<code>r</code> 表示读取，<code>w</code> 表示写入，会删除原来的所有内容，<code>a</code> 表示在文件后面追加写入。</p>
<p>一般来说不要用 <code>readlines</code> 读取文件，因为如果文件特别大， 读出来的数组可能会非常占用内存。我们会看到输出结果一般都有多个空行，这是因为每行的结尾都有 '\n' 换行符，而且 <code>print</code> 函数自己就会换行。如果想要更美观的输出，可以用 <code>replace</code> 或者 <code>rstrip</code> 函数干掉换行符。</p>
<p>如果我们用 <code>open('path_to_file'. 'rb')</code> 来打开文件，就可以读取到原来的二进制：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'file_to_path'</span>, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
</div></li><li><div class="code_line">        print(line)
</div></li><li><div class="code_line"><span class="hljs-comment"># b'first line\n'</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># b'second line\n'</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># b'third line\n'</span>
</div></li></ul></code></pre>
<p>这里我们本来应该看到的是各个字母的 UTF-8 编码后的二进制，不过在打印的时候被系统自动转成字母了。在文件不是UTF-8 编码时，一定要用二进制格式去打开文件并且自行解码，否则 Python 会尝试用 UTF-8 去解码，极有可能会因为无法解码而导致报错。</p>
<p>我们可以试着把二进制写入到文件中：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello world'</span>
</div></li><li><div class="code_line">b = [x.encode(<span class="hljs-string">'utf16'</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'path_to_file'</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    f.writelines(b)
</div></li></ul></code></pre>
<p><code>writelines</code> 函数的参数是数组，相当于对数组中的每个元素调用了 <code>write()</code> 方法。</p>
<p>感兴趣的读者可以试着分别用 <code>r</code> 和 <code>rb</code> 去打开文件，感受其中的区别。</p>
<h4 id="section532json">5.3.2 JSON 读写</h4>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = {<span class="hljs-string">'name'</span>: <span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">22</span>}
</div></li><li><div class="code_line">json.dumps(d)  <span class="hljs-comment"># 返回字符串：{"name": "bestswifter", "age": 22}</span>
</div></li></ul></code></pre>
<p>最简单的对象转 JSON 通过 <code>json</code> 模块的 <code>dumps</code> 函数来完成，最后一个字母 s 表示生成字符串，也可以用 <code>dump(data, fp)</code> 来把内容写入文件：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = {<span class="hljs-string">'name'</span>: <span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">22</span>}
</div></li><li><div class="code_line"><span class="hljs-keyword">with</span> opne(<span class="hljs-string">'path_to_file'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    json.dump(d, f)
</div></li></ul></code></pre>
<p>调用 <code>dumps</code> 参数时，有几个命令可能会派上作用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = {<span class="hljs-string">'name'</span>: <span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">22</span>}
</div></li><li><div class="code_line">json.dumps(d, skipkeys=<span class="hljs-keyword">True</span>, sort_keys=<span class="hljs-keyword">True</span>, indent=<span class="hljs-number">4</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment">#{</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "age": 22,</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "name": "bestswifter"</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#}</span>
</div></li></ul></code></pre>
<p>其中，<code>sort_keys</code> 表示对字典的键排序，这样输出结果一定是固定的，<code>indent</code> 用于控制多少个空格缩进，可以增加可读性。<code>skipkeys</code> 表示如果字典的键不是字符串，就忽略这一条记录。</p>
<p>JSON 支持的类型很有限，只有 <code>None</code> ， <code>bool</code> ， <code>int</code> ， <code>float</code> 和 <code>str</code> 这五种基本类型和包含这些类型的字典或者数组。自定义的对象如果转成 JSON 默认会报错，我们可以实现一个通用函数，读取任意对象的 <code>__dict__</code>，这样就可以用于 JSON 化了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize_instance</span><span class="hljs-params">(obj)</span>:</span>
</div></li><li><div class="code_line">    d = { <span class="hljs-string">'class'</span> : type(obj).__name__ }
</div></li><li><div class="code_line">    d.update(vars(obj))
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> d
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">        self.age = age
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-number">22</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 直接 dumps(bs) 会得到这个报错：</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># TypeError: Object of type 'Person' is not JSON serializable</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">json.dumps(serialize_instance(bs), skipkeys=<span class="hljs-keyword">True</span>, sort_keys=<span class="hljs-keyword">True</span>, indent=<span class="hljs-number">4</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment">#{</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "age": 22,</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "class": "Person",</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "name": "bestswifter"</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#}</span>
</div></li></ul></code></pre>
<p>或者更优雅的做法是使用 3.3.3 节中介绍的 Mixin：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 注意 Mixin 的原则，功能要单一，实现上不能依赖子类</span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serializable</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        d = { <span class="hljs-string">'class'</span> : type(self).__name__ }
</div></li><li><div class="code_line">        d.update(vars(self))
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> d
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 混入 Serializable 立刻就有了转字典的能力，或者也可以重写</span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(Serializable)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">        self.age = age
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-number">22</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">json.dumps(bs.serialize())
</div></li></ul></code></pre>
<p>解析 JSON 字符串的方法也是类似的，调用 <code>json.loads()</code> 函数即可：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">s = <span class="hljs-string">'{"name": "bestswifter", "age": 22}'</span>
</div></li><li><div class="code_line">d = json.loads(s)
</div></li><li><div class="code_line">print(d)
</div></li></ul></code></pre>
<p>这里的 <code>loads</code> 表示从字符串中读取 JSON，也可以用 <code>load</code> 函数从文件中读取。不过有时候我们更希望把读取出来的字典直接转成对象。这需要调用者提供一个函数，把字典转换成对象，一般需要用到元编程。下面是一个简单的示例：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deserializable</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @classmethod</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(cls, d)</span>:</span>
</div></li><li><div class="code_line">        clsname = d.pop(<span class="hljs-string">'classname'</span>, <span class="hljs-keyword">None</span>)
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> clsname:
</div></li><li><div class="code_line">            obj = cls.__new__(cls)
</div></li><li><div class="code_line">            <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():
</div></li><li><div class="code_line">                setattr(obj, key, value)
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> obj
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> d
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(Deserializable)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">        self.age = age
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">s = <span class="hljs-string">'{"age": 22, "name": "bestswifter"}'</span>
</div></li><li><div class="code_line">bs = json.loads(s, object_hook = Person.deserialize)
</div></li><li><div class="code_line">print(bs)
</div></li></ul></code></pre>
<p><code>Person</code> 类通过混入 <code>Deserializable</code> 具备了反序列化的能力，只要把这个函数传入 <code>loads</code> 方法中即可，<code>deserialize</code> 函数的第一个参数是调用类，第二个参数是解析出来的字典。这段代码其实等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = json.loads(s)
</div></li><li><div class="code_line">bs = Person.deserialize(d)
</div></li></ul></code></pre>
<h4 id="section533shell">5.3.3 执行 Shell</h4>
<p>Python 中调用 <code>Shell</code> 命令的方法有很多种，我最常用的是 <code>os.popen</code> 函数，它的返回结果是文件句柄，因此可以调用 <code>readlines</code> 函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> os
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">r = os.popen(<span class="hljs-string">'pwd'</span>)
</div></li><li><div class="code_line">print(r.readlines())
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出 ['/Users/zxy/Desktop\n']</span>
</div></li></ul></code></pre>
<p>这个结果表示 Shell 命令的输出只有一行，且内容是 <code>/Users/zxy/Desktop</code>。</p>
<h3 id="section54python">5.4 Python 模块化</h3>
<h4 id="section541python">5.4.1 Python 中的模块</h4>
<p>Python 不仅可以用来编写短小精悍的脚本文件，也能用来开发大型项目，这就需要把代码合理的写在各个模块中，确保<strong>高内聚、低耦合</strong>。</p>
<p>每一个 Python 文件都是一个模块，我们知道 <code>import</code> 关键字可以导入系统模块，也可以用 <code>import module_name</code> 的写法导入别的模块。</p>
<p>假设文件路径如下：</p>
<pre><code class="hljs ruby"><ul><li><div class="code_line">package
</div></li><li><div class="code_line"><span class="hljs-params">|-- main.py
</span></div></li><li><div class="code_line"><span class="hljs-params">|</span>-- <span class="hljs-class"><span class="hljs-keyword">module</span>.<span class="hljs-title">py</span></span>
</div></li></ul></code></pre>
<p>那么可以这样引用别的模块 </p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-comment"># In module.py</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> a + b
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># In main.py</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> module
</div></li><li><div class="code_line">modul1.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 返回 3</span>
</div></li></ul></code></pre>
<h4 id="section542">5.4.2 模块查找顺序</h4>
<p>对于被 <code>import</code> 的模块，Python 首先会检查它是不是内置的模块，比如我们把刚刚的 <code>module.py</code> 文件重命名为 <code>time.py</code>，再引用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> time
</div></li><li><div class="code_line">time.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># 报错：AttributeError: module 'time' has no attribute 'add'</span>
</div></li></ul></code></pre>
<p>这是因为 Python 最先查找内置的模块，我们打印 time 模块就可以看到 <code>&lt;module 'time' (built-in)&gt;</code> ，说明这是一个内置模块。PS：<code>string</code> 模块不是内置模块，坑了我一晚上。</p>
<p>如果导入的不是内置模块，Python 会依次在 <code>sys.path</code> 这个数组中的每个路径中寻找。按照查找优先级，它由三个部分组成：</p>
<ol>
<li>Python 执行的入口文件（比如这里的 <code>main.py</code>）所在的路径</li>
<li>系统的环境变量 <code>$PYTHONPATH</code> 所表示的目录</li>
<li><code>site</code> 路径，也就是 <code>/usr/local/lib/python3.5/site-packages</code> 这种。</li>
</ol>
<p>如果我们把 <code>time.py</code> 改名为 <code>string.py</code> 就会得到正常结果，这是因为它属于第一部分，而 Python 默认的 <code>string</code> 模块位于第三部分，优先级比较低。</p>
<p>一般来说，Python 工程中的文件都能在第一部分被找到，而 <code>pip</code> 安装的第三方库位于第三部分。环境变量 <code>PYTHONPATH</code> 一般都是空，但不排除某些 IDE，比如 PyCharm 会修改它。这种行为很危险，因为能在 PyCharm 中编译通过很可能是借助环境变量才找到了模块，一旦迁移到别的环境就无法编译，我似乎遇到过这个坑，将本地可以运行的代码上传到 VPS 以后就找不到模块了。</p>
<h4 id="section543__init__py">5.4.3 包与 \__init__.py</h4>
<p>当代码量进一步膨胀时，可能多个模块也无法合理的拆分逻辑了，我们可以把实现某个特定功能的若干个模块组合起来，形成一个包。包在逻辑上可以理解为若干个模块的组合， 在物理上讲，包都是文件夹，模块都是文件。</p>
<p>注意，<strong>文件夹不都是包，只有存在 \__init__.py 文件的文件夹才是模块！</strong></p>
<p>在导入时，我们可以导入类，也可以导入类里面的全局变量或者全局函数，还可以导入包：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> package
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> module
</div></li></ul></code></pre>
<p>如果类名和变量名太长，可以用 as 关键字重命名：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> module.var <span class="hljs-keyword">as</span> v
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> module.func <span class="hljs-keyword">as</span> f
</div></li></ul></code></pre>
<p>一般来说导入包并没有太大的作用，后续还是需要导入包中的模块。如果确实需要直接用到包中的函数或者变量，可以把它定义在 <code>__init__.py</code> 文件中。</p>
<p><code>__init__.py</code> 用于把一个目录标记为包，如果没有这个文件，目录又和 Python 模块重名，就会调用到 Python 的模块，假设文件层级如下：</p>
<pre><code class="hljs sql"><ul><li><div class="code_line">dir
</div></li><li><div class="code_line">|<span class="hljs-comment">-- main.py</span>
</div></li><li><div class="code_line">|<span class="hljs-comment">-- string</span>
</div></li><li><div class="code_line">  |<span class="hljs-comment">-- module1.py</span>
</div></li></ul></code></pre>
<p>我们尝试在 <code>main.py</code> 中导入包：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> string
</div></li><li><div class="code_line">print(string)
</div></li><li><div class="code_line"><span class="hljs-comment"># &lt;module 'string' from '/usr/local/Cellar/python3/3.5.2_3/Frameworks/Python.framework/Versions/3.5/lib/python3.5/string.py'&gt;</span>
</div></li></ul></code></pre>
<p>会发现导入的其实是模块。虽然这里 <code>string</code> 目录如果是一个文件，它的查找优先级会高于 Python 中的非内置模块，但如果当做包来导入，Python 就无法识别了。解决方案也很简单，给 <code>string</code> 目录添加一个 <code>__init__.py</code> 文件，把 <code>string</code> 目录标记为包即可。</p>
<p>除了标记目录为包以外，<code>__init__.py</code> 文件还可以定义一个 <code>__all__</code> 变量，用于批量导入，假设目录层级如下：</p>
<pre><code class="hljs sql"><ul><li><div class="code_line">dir
</div></li><li><div class="code_line">|<span class="hljs-comment">-- main.py</span>
</div></li><li><div class="code_line">|<span class="hljs-comment">-- string</span>
</div></li><li><div class="code_line">  |<span class="hljs-comment">-- module1.py</span>
</div></li><li><div class="code_line">  |<span class="hljs-comment">-- module2.py</span>
</div></li><li><div class="code_line">  |<span class="hljs-comment">-- module3.py</span>
</div></li></ul></code></pre>
<p>先在 <code>__init__</code> 文件中定义要批量导入的模块：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-comment"># In __init__.py</span>
</div></li><li><div class="code_line">__all__ = [<span class="hljs-string">'module1'</span>, <span class="hljs-string">'module2'</span>]
</div></li></ul></code></pre>
<p>然后在 <code>main.py</code> 文件中用星号 <code>*</code> 批量导入：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> string <span class="hljs-keyword">import</span> *
</div></li><li><div class="code_line">print(module1) <span class="hljs-comment"># &lt;module 'string.module1' from '/Users/zxy/Desktop/string/module1.py'&gt;</span>
</div></li><li><div class="code_line">print(module2) <span class="hljs-comment"># &lt;module 'string.module1' from '/Users/zxy/Desktop/string/module1.py'&gt;</span>
</div></li><li><div class="code_line">print(module3) <span class="hljs-comment"># NameError: name 'module3' is not defined</span>
</div></li></ul></code></pre>
<p>在打印 <code>module3</code> 的时候会报错，这是因为 <code>__all__</code> 变量没有暴露它，需要我们手动导入。</p>
<h4 id="section554">5.5.4 相对导入和绝对导入</h4>
<p>接上面的例子，假设我们在 <code>module2</code> 中要引用 <code>module1</code>，代码如下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> string.module1
</div></li></ul></code></pre>
<p>这样写没有问题，因为有 <code>__init__.py</code> 文件把目录标记为包，所以可以正确识别。然而如果我们的入口不是 <code>main.py</code>，而是直接执行 <code>python3 module2.py</code>，就无法识别到父目录里面的 <code>__init__.py</code> 文件了。此时可以采用相对导入：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> module1
</div></li></ul></code></pre>
<p>一个点表示当前的包，两个点就表示上一个包，以此类推……；相对导入只能使用 <code>from import</code> 的语法，而绝对路径导入则不受限制，两种写法皆可。</p>
<p>相对路径的缺点在于容易丢失命名空间，比较这两种写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> foo <span class="hljs-keyword">import</span> bar
</div></li><li><div class="code_line">bar()     <span class="hljs-comment"># bar 在哪里定义？</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> foo.bar
</div></li><li><div class="code_line">foo.bar() <span class="hljs-comment"># 在 foo 模块中定义</span>
</div></li></ul></code></pre>
<p>前者丢失了 <code>bar</code> 的来源，而后一种写法不会。</p>
<h4 id="section545python">5.4.5 运行 Python 脚本</h4>
<p>每个 Python 脚本既可以直接用 <code>python xxx.py</code> 命令执行，也可以被别的 Python 文件当做模块引入。对于一个项目来说，入口文件只有一个（就像 C 语言的 <code>main.c</code> 文件一样），其他的文件都作为模块对外提供功能。</p>
<p>我们也可以用 <code>python</code> 命令执行一个文件夹，此时会自动运行文件夹中的 <code>__main__.py</code> 文件。 </p>
<p>假设我们写了一个函数，可以爬取给定 URL 的标题：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTitle</span><span class="hljs-params">(url)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># return html.title</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">getTitle(<span class="hljs-string">'https://baidu.com'</span>)
</div></li></ul></code></pre>
<p>直接执行或者在别的模块中导入这个文件都会调用 <code>getTitle</code> 函数，然而我们希望的效果是只有直接执行这个文件时才执行函数，被导入时只要提供方法即可。或者可以通过判断全局变量 <code>__name__</code> 来完成：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTitle</span><span class="hljs-params">(url)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># return html.title</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
</div></li><li><div class="code_line">    print(getTitle(<span class="hljs-string">'https://baidu.com'</span>))
</div></li></ul></code></pre>
<p>只有当直接运行文件时，全局变量 <code>__name__</code> 的值才是 <code>__main__</code>，因此当这个模块被导入时，<code>if</code> 语句中的代码就不会被调用。</p>
<p><code>python</code> 作为一个 Shell 命令，可以和其他系统命令通过管道联系在一起，比如实现一个 <code>show_file.py</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> sys
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> sys.stdin:
</div></li><li><div class="code_line">    print(file)
</div></li></ul></code></pre>
<p>然后执行命令行脚本：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line">ls | python3 show_file.py
</div></li></ul></code></pre>
<p>将会打印出当前目录中所有文件的名字。每个 Shell 脚本都有返回值， 用于表示脚本是否成功，通过命令 <code>echo $?</code> 可以查看上一条命令的返回结果，比如：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line">./create_file.sh
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> [ $? = 0 ] ; <span class="hljs-keyword">then</span>  <span class="hljs-comment"># 只有成功创建文件，才会写入内容</span>
</div></li><li><div class="code_line">    ./write_to_file.sh
</div></li><li><div class="code_line"><span class="hljs-keyword">else</span>
</div></li><li><div class="code_line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">"error"</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">fi</span>
</div></li></ul></code></pre>
<p>由于脚本命令的返回值具有重要的参考价值，因此我们的 Python 脚本也要遵循这一规范，这样别的命令可以很容易的知道 Python 脚本的执行情况。因此，标准的入口文件总是应该套用这个模板：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> sys
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 执行某些逻辑</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 如果发生错误</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># sys.exit(1)</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
</div></li><li><div class="code_line">    sys.exit(main())
</div></li></ul></code></pre>
<h3 id="section55venv">5.5 venv</h3>
<h4 id="section551venv">5.5.1 什么是 venv</h4>
<p>假设我们开发程序 A 是用到了 <code>pip install module1==1.0</code>，也就是安装了 <code>module1</code> 这个第三方库的 1.0 版本，同时开发程序 B 用到了这个第三方库的 2.0 版本，但是在 <code>/usr/local/lib/python3.5/site-packages</code> 这个目录下只能留一份，那么 A 和 B 就无法分别使用两个版本的第三方库了。</p>
<p>于是诞生了虚拟环境（virtualenv，简称 venv）的概念，它会为每个应用单独提供一份 Python 的运行环境，从而起到隔离的效果。</p>
<p>执行以下命令：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line">pip3 install virtualenv
</div></li><li><div class="code_line">virtualenv <span class="hljs-built_in">test</span>
</div></li></ul></code></pre>
<p>这首先会安装 <code>virtualenv</code> 这个工具模块，然后在当前目录下新建一个虚拟环境 <code>test</code>，其实也就是一个目录。</p>
<h4 id="section552venv">5.5.2 venv 结构初探</h4>
<p>观察目录的组成可以发现，主要是有三个文件夹：<code>bin</code>、<code>include</code> 和 <code>lib</code>。</p>
<p><code>bin</code> 目录下主要是一些可执行文件，比如虚拟环境的激活与退出，以及 Python 和 pip 的可执行文件。比如：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line"><span class="hljs-built_in">source</span> bin/active
</div></li><li><div class="code_line"><span class="hljs-comment"># 现在开始，虚拟环境已经生效，安装的模块都在这个文件夹内部</span>
</div></li><li><div class="code_line">pip instal module1
</div></li><li><div class="code_line">pip instal module2
</div></li><li><div class="code_line"><span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">deactive
</div></li></ul></code></pre>
<p><code>inlcude</code> 目录下的会通过软连接，导入一些 C 语言的头文件，暂时不清楚作用。</p>
<p><code>lib</code> 目录下引用了 Python 自带的一些模块，以及第三方包 <code>site-packages</code> 文件夹的拷贝。如果执行的是 <code>virtualenv --no-site-packages test</code> 将会得到一个不含第三方包，纯净的虚拟环境。</p>
<h4 id="section553">5.5.3 工作原理</h4>
<p>其实 venv 的工作原理非常简单，完全集中在 <code>bin/active</code> 这个简单的脚本中，它的核心部分如下：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-title">deactive</span></span> () {
</div></li><li><div class="code_line">    <span class="hljs-comment"># 恢复环境</span>
</div></li><li><div class="code_line">}
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">VIRTUAL_ENV=<span class="hljs-string">"/Users/zxy/Desktop/testvenv"</span>
</div></li><li><div class="code_line"><span class="hljs-built_in">export</span> VIRTUAL_ENV
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">_OLD_VIRTUAL_PATH=<span class="hljs-string">"<span class="hljs-variable">$PATH</span>"</span>
</div></li><li><div class="code_line">PATH=<span class="hljs-string">"<span class="hljs-variable">$VIRTUAL_ENV</span>/bin:<span class="hljs-variable">$PATH</span>"</span>
</div></li><li><div class="code_line"><span class="hljs-built_in">export</span> PATH
</div></li></ul></code></pre>
<p>可见它把当前目录标记为 <code>VIRTUAL_ENV</code>，然后添加到系统的 <code>PATH</code> 最前面，这样我们执行 <code>pip</code> 命令时，第三方的包就会被安装虚拟环境内的 <code>site-packages</code> 文件夹中，不会与系统的干扰。</p>
<h2 id="section6">6 学习方向</h2>
<p>由于作者水平和文章篇幅有限，不可能所有知识点都面面俱到，如果本文激起了你对 Python 的兴趣，我有几个建议或许能帮助你进一步的提高自己的 Python 水平，按照重要级的降序排列：</p>
<ol>
<li>先确保本文中的所有 Demo 都自己实现过一遍，看代码和写代码是两种截然不同的体验</li>
<li>了解 Python 标准库中提供的函数，避免重复造轮子，更高效的完成需求</li>
<li>尝试用 Tornado、Flask、Django、MITM 等著名的 Python 框架完成一些自己的需求，把 Python 知识与实践结合起来，有机会的话可以阅读这些框架的源码</li>
<li>针对自己还不够了解的知识点，查找 Google 上的优秀博客</li>
</ol>
<h2 id="section7">7 版本历史</h2>
<h4 id="section100">1.0.0</h4>
<p>首次发布</p>
<h4 id="section101">1.0.1</h4>
<ol>
<li>改正了 1.1.2 节中的错别字，<code>精度</code> -&gt; <code>经度</code>，<code>维度</code> -&gt; <code>纬度</code></li>
<li>改正了 1.1.2 节中 <code>p.name</code> 错误的写成了 22 的问题</li>
<li>改正了 1.2.2 节中单词拼写错误， <code>seddefault</code> -&gt; <code>setdefault</code></li>
<li>改正了 2.3 节中 <code>co_argcount</code> 值错误的问题，经过查阅<a href="https://docs.python.org/3/library/inspect.html#types-and-members" target="_blank">官方文档</a>，这个值不会统计 <code>*</code>、<code>**</code> 和仅限关键字参数</li>
<li>改正了 2.2.3 节中的输出结果，<code>[1, 2, 3]</code> -&gt; <code>(1, 2, 3)</code></li>
<li>改正了 3.4.1 节中的错别字，<code>元祖</code> -&gt; <code>元组</code></li>
<li>改正了 3.1.2 节中的代码错误，<code>a</code> -&gt; <code>b</code></li>
<li>改正了 1.2.5 节中的错误，<code>交集</code> -&gt; <code>并集</code></li>
<li>改正了 2.4.2 节中的语法错误 <code>decorate</code> -&gt; <code>@decorate</code></li>
<li>改正了 5.3.1 节中的代码错误 <code>r</code> -&gt; <code>rb</code></li>
</ol>
<h2 id="section">参考资料：</h2>
<ol>
<li><a href="http://www.cnblogs.com/xybaby/p/6270551.html" target="_blank">python属性查找 深入理解（attribute lookup）</a></li>
<li><a href="https://www.python.org/download/releases/2.3/mro/" target="_blank">The Python 2.3 Method Resolution Order</a></li>
<li><a href="http://www.bjhee.com/python-mixin.html" target="_blank">关于Python的Mixin模式</a></li>
<li><a href="https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods" target="_blank">The definitive guide on how to use static, class or abstract methods in Python</a></li>
<li><a href="http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/" target="_blank">异步与回调的设计哲学</a></li>
<li><a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank">Python的GIL是什么鬼，多线程性能究竟如何</a></li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p02_read-write_json_data.html" target="_blank">6.2 读写JSON数据</a></li>
<li><a href="https://loggerhead.me/posts/python-de-import-ji-zhi.html#_1" target="_blank">Python 的 import 机制</a></li>
</ol></div>
                    <div class="xzl-topic-body-content hidden_topic_body hidden" id="xzl-topic-body-content"><p>Python 是一门非常容易上手的语言，通过查阅资料和教程，也许一晚上就能写出一个简单的爬虫。但 Python 也是一门很难精通的语言，因为简洁的语法背后隐藏了许多黑科技。本文主要针对的读者是：</p>
<ol>
<li>毫无 Python 经验的小白</li>
<li>有一些简单 Python 经验，但只会复制粘贴代码，不知其所以然的读者</li>
<li>觉得单独一篇文章太琐碎，质量没保证，却没空读完一本书，但又想对 Python 有全面了解的读者</li>
</ol>
<p>当然， 用一篇文章来讲完某个语言是不可能的事情，我希望读完本文的读者可以：</p>
<ol>
<li>对 Python 的整体知识结构形成初步的概念</li>
<li>了解 Python 特有的知识点，比如装饰器、上下文、生成器等等，不仅会写 Demo，还对背后的原理有一定了解</li>
<li>避免 C++/Java 等风格的 Python 代码，能够写出地道的 Python 代码</li>
<li>能够熟练的使用 Python 编写脚本实现日常的简单需求，能够维护小型 Python 项目，能够阅读较复杂的 Python 源码</li>
</ol>
<p>如果以上介绍符合你对自己的定位，在开始阅读前，还需要明确几点：</p>
<ol>
<li>本文不会只介绍用法，那样太肤浅</li>
<li>本文不会深入介绍某个知识点，比如分析源码等，那样太啰嗦，我希望做一名引路人，描述各个知识点的概貌并略作引申，为读者指出下一步的研究方向</li>
<li>代码注释非常重要，一定要看，几乎所有的代码段都可以执行，<strong>强烈建议</strong>手敲一遍！</li>
</ol>
<p></p><div class="toc">
<ul>
<li><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section0" target="_blank" rel="noopener">0. 准备工作</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section1" target="_blank" rel="noopener">1. 数据结构</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section11" target="_blank" rel="noopener">1.1 数组</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section111" target="_blank" rel="noopener">1.1.1 列表推导</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section112" target="_blank" rel="noopener">1.1.2 元组</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section113" target="_blank" rel="noopener">1.1.3 数组切片</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section114" target="_blank" rel="noopener">1.1.4 循环与遍历</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section115" target="_blank" rel="noopener">1.1.5 魔术方法</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section12" target="_blank" rel="noopener">1.2 字典</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section121" target="_blank" rel="noopener">1.2.1 初始化字典</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section122" target="_blank" rel="noopener">1.2.2 查询字典</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section123" target="_blank" rel="noopener">1.2.3 遍历字典</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section124" target="_blank" rel="noopener">1.2.4 字典的魔术方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section125" target="_blank" rel="noopener">1.2.5 集合</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section13" target="_blank" rel="noopener">1.3 字符串</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section131" target="_blank" rel="noopener">1.3.1 字符串编码</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section132" target="_blank" rel="noopener">1.3.2 字符串的常用方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section133" target="_blank" rel="noopener">1.3.3 字符串格式化</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section134heredoc" target="_blank" rel="noopener">1.3.4 HereDoc</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section2" target="_blank" rel="noopener">2 函数</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section21" target="_blank" rel="noopener">2.1 函数是一等公民</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section22" target="_blank" rel="noopener">2.2 函数参数</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section221" target="_blank" rel="noopener">2.2.1 函数传参</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section222" target="_blank" rel="noopener">2.2.2 默认参数</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section223" target="_blank" rel="noopener">2.2.3 多参数传递</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section224" target="_blank" rel="noopener">2.2.4 参数分类</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section23" target="_blank" rel="noopener">2.3 函数内省</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section24" target="_blank" rel="noopener">2.4 装饰器</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section241" target="_blank" rel="noopener">2.4.1 设计模式的消亡</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section242" target="_blank" rel="noopener">2.4.2 装饰器的基本原理</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section243" target="_blank" rel="noopener">2.4.3 装饰器进阶</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section244" target="_blank" rel="noopener">2.4.4 装饰器工厂</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section3" target="_blank" rel="noopener">3 面向对象</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section31" target="_blank" rel="noopener">3.1 对象内存管理</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section311" target="_blank" rel="noopener">3.1.1 对象不是盒子</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section312" target="_blank" rel="noopener">3.1.2 默认浅复制</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section313" target="_blank" rel="noopener">3.1.3 弱引用</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section32python" target="_blank" rel="noopener">3.2 Python 风格的对象</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section321" target="_blank" rel="noopener">3.2.1 静态函数与类方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section322attribute" target="_blank" rel="noopener">3.2.2 属性 attribute</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section323property" target="_blank" rel="noopener">3.2.3 特性 property</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section324" target="_blank" rel="noopener">3.2.4 特性工厂</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section325" target="_blank" rel="noopener">3.2.5 属性描述符</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section326" target="_blank" rel="noopener">3.2.6 实例属性的查找顺序</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section33" target="_blank" rel="noopener">3.3 多继承</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section331" target="_blank" rel="noopener">3.3.1 多继承的必要性</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section332python" target="_blank" rel="noopener">3.3.2 Python 的多继承</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section333mixin" target="_blank" rel="noopener">3.3.3 Mixin</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section334" target="_blank" rel="noopener">3.3.4 抽象类</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section34" target="_blank" rel="noopener">3.4 元编程</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section341" target="_blank" rel="noopener">3.4.1 类工厂函数</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section342" target="_blank" rel="noopener">3.4.2 元类的概念</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section343" target="_blank" rel="noopener">3.4.3 元类的使用示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section4" target="_blank" rel="noopener">4. 流程控制</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section41else" target="_blank" rel="noopener">4.1 else</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section411forelse" target="_blank" rel="noopener">4.1.1 for else</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section412whileelse" target="_blank" rel="noopener">4.1.2 while else</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section413tryelse" target="_blank" rel="noopener">4.1.3 try else</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section42" target="_blank" rel="noopener">4.2 迭代器</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section421" target="_blank" rel="noopener">4.2.1 迭代器</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section422" target="_blank" rel="noopener">4.2.2 可迭代对象</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section423__iter__" target="_blank" rel="noopener">4.2.3 \__iter__ 方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section424" target="_blank" rel="noopener">4.2.4 标准迭代器</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section425" target="_blank" rel="noopener">4.2.5 初识生成器</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section43" target="_blank" rel="noopener">4.3 生成器</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section431" target="_blank" rel="noopener">4.3.1 生成器的定义</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section432" target="_blank" rel="noopener">4.3.2 生成器表达式</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section433" target="_blank" rel="noopener">4.3.3 协程</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section434" target="_blank" rel="noopener">4.3.4 预激协程</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section435" target="_blank" rel="noopener">4.3.5 标准库中的生成器函数</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section44" target="_blank" rel="noopener">4.4 上下文管理器</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section441with" target="_blank" rel="noopener">4.4.1 with 块</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section442" target="_blank" rel="noopener">4.4.2 自定义上下文</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section443" target="_blank" rel="noopener">4.4.3 标准库中的上下文</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section5python" target="_blank" rel="noopener">5. 其他 Python 特色</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section51gil" target="_blank" rel="noopener">5.1 多线程与GIL</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section511" target="_blank" rel="noopener">5.1.1 多线程</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section512" target="_blank" rel="noopener">5.1.2 线程锁</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section513gil" target="_blank" rel="noopener">5.1.3 GIL</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section514" target="_blank" rel="noopener">5.1.4 多进程</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section52python" target="_blank" rel="noopener">5.2 我眼中的  Python</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section521python" target="_blank" rel="noopener">5.2.1 Python 是动态强类型语言</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section522" target="_blank" rel="noopener">5.2.2 开发效率高</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section523" target="_blank" rel="noopener">5.2.3 对新人不是很友好</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section53python" target="_blank" rel="noopener">5.3 其它 Python 技巧</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section531" target="_blank" rel="noopener">5.3.1 文件读写</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section532json" target="_blank" rel="noopener">5.3.2 JSON 读写</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section533shell" target="_blank" rel="noopener">5.3.3 执行 Shell</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section54python" target="_blank" rel="noopener">5.4 Python 模块化</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section541python" target="_blank" rel="noopener">5.4.1 Python 中的模块</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section542" target="_blank" rel="noopener">5.4.2 模块查找顺序</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section543__init__py" target="_blank" rel="noopener">5.4.3 包与 \__init__.py</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section554" target="_blank" rel="noopener">5.5.4 相对导入和绝对导入</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section545python" target="_blank" rel="noopener">5.4.5 运行 Python 脚本</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section55venv" target="_blank" rel="noopener">5.5 venv</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section551venv" target="_blank" rel="noopener">5.5.1 什么是 venv</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section552venv" target="_blank" rel="noopener">5.5.2 venv 结构初探</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section553" target="_blank" rel="noopener">5.5.3 工作原理</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section6" target="_blank" rel="noopener">6 学习方向</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section7" target="_blank" rel="noopener">7 版本历史</a><ul>
<li><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section100" target="_blank" rel="noopener">1.0.0</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section101" target="_blank" rel="noopener">1.0.1</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section" target="_blank" rel="noopener">参考资料：</a></li>
</ul>
</li>
</ul>
</div>
<p></p>
<h2 id="section0">0. 准备工作</h2>
<p>请不要在学习 Python2 还是 Python3 之间犹豫了，除非你很明确自己只接触 Python2，否则就从 Python3 学起，新版本的语言总是意味着进步的生产力（Swift 和 Xcode 除外）。Python 2 和 3 之间语法不兼容，但这并不影响熟悉 Python3 的开发者迅速写出 Python 2 的代码，反之亦然。所以与其在反复纠结中浪费时间，不如立刻行动起来。</p>
<p>推荐使用 <strong>CodeRunner</strong> 来运行本文中的 demo，它比文本编辑器功能更强大，比如支持自动补全和断点调试，又比 PyCharm 轻量得多。</p>
<h2 id="section1">1. 数据结构</h2>
<h3 id="section11">1.1 数组</h3>
<h4 id="section111">1.1.1 列表推导</h4>
<p>如果要对数组中的所有内容做一些修改，可以用 for 循环或者 map 函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">small = []
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> array: 
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>:
</div></li><li><div class="code_line">        small.append(n * <span class="hljs-number">2</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">print(small)  <span class="hljs-comment"># [2, 4, 6]</span>
</div></li></ul></code></pre>
<p>比较地道的 Python 写法是使用列表推导：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">small = [n * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> array <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>]
</div></li></ul></code></pre>
<p><code>for in</code> 可以写两次，类似于嵌套的 for 循环，会得到一个笛卡尔积：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">signs = [<span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>]
</div></li><li><div class="code_line">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">ascii = [<span class="hljs-string">'{sign}{number}'</span>.format(sign=sign, number=number) 
</div></li><li><div class="code_line">        <span class="hljs-keyword">for</span> sign <span class="hljs-keyword">in</span> signs <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers]
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：['+1', '+2', '-1', '-2']</span>
</div></li></ul></code></pre>
<h4 id="section112">1.1.2 元组</h4>
<p>元组可以简单的理解为不可变的数组，也就是没有 <code>append</code>、<code>del</code> 等方法，一旦创建，就无法新增或删除元素，元素自身的值也不能改变，但元素内部的属性是否可变并不受元组的影响，这一点符合其他语言中的常识。</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, [])
</div></li><li><div class="code_line">t[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment"># 抛出错误 TypeError: 'tuple' object does not support item assignment</span>
</div></li><li><div class="code_line">t[<span class="hljs-number">1</span>].append(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 正常运行，现在的 t 是 (1, [2])</span>
</div></li></ul></code></pre>
<p>除了不可变性以外，有时候元组也会被当做不具名的数据结构，这时候元素的位置就不再是可有可无的了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">coordinate = (<span class="hljs-number">33.9425</span>, <span class="hljs-number">-118.408056</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># coordinate 的第一个位置用来表示经度，第二个位置表示纬度</span>
</div></li></ul></code></pre>
<p>在解析元组数据时，可以一一对应的写上变量名：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line">a, b = t <span class="hljs-comment"># a = 1, b = 2</span>
</div></li></ul></code></pre>
<p>有时候变量名比较长， 但我只关心其中某一个，可以这样写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line">a, _ = t <span class="hljs-comment"># a = 1</span>
</div></li></ul></code></pre>
<p>如果元组中元素特别多，即使挨个写下划线也比较累，可以用 \* 来批量解包：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
</div></li><li><div class="code_line">first, *middle, last = t
</div></li><li><div class="code_line"><span class="hljs-comment"># first = 1</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># middle = [2, 3, 4]</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># last = 5</span>
</div></li></ul></code></pre>
<p>当然，如果元素数量较多，含义较复杂，我还是建议使用具名元组：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> collections
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">People = collections.namedtuple(<span class="hljs-string">'People'</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>])
</div></li><li><div class="code_line">p = People(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'22'</span>)
</div></li><li><div class="code_line">p.name <span class="hljs-comment"># bestswifter</span>
</div></li></ul></code></pre>
<p>具名元组更像是一个不能定义方法的简化版的类，能提供友好的数据展示。</p>
<p>元组的一个小技巧是可以避免用临时变量来交换两个数的值：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = <span class="hljs-number">1</span> 
</div></li><li><div class="code_line">b = <span class="hljs-number">2</span>
</div></li><li><div class="code_line">a, b = b, a
</div></li><li><div class="code_line"><span class="hljs-comment"># a = 2, b = 1</span>
</div></li></ul></code></pre>
<h4 id="section113">1.1.3 数组切片</h4>
<p>切片的基本格式是 <code>array[start🔚step]</code>，表示对 array 在 start 到 end 之前以 step 为间隔取切片。注意这里的区间是 [start, end)，也就是左闭右开。比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]
</div></li><li><div class="code_line"><span class="hljs-comment"># 表示取 s 的第 0、2、4 个字符，结果是 'hlo'</span>
</div></li></ul></code></pre>
<p>再举几个例子</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]  <span class="hljs-comment"># 不写 step 默认就是 1，因此得到 'hello'</span>
</div></li><li><div class="code_line">s[<span class="hljs-number">1</span>:]   <span class="hljs-comment"># 不写 end 默认到结尾，因此还是得到 'ello'</span>
</div></li><li><div class="code_line">s[n:]   <span class="hljs-comment"># 获取 s 的最后 len(s) - n 个元素</span>
</div></li><li><div class="code_line">s[:<span class="hljs-number">2</span>]   <span class="hljs-comment"># 不写 start 默认从 0 开始，因此得到 'he'</span>
</div></li><li><div class="code_line">s[:n]   <span class="hljs-comment"># 获取 s 的前 n 个元素</span>
</div></li><li><div class="code_line">s[:<span class="hljs-number">-1</span>]  <span class="hljs-comment"># 负数表示倒过来数，因此这会刨除最后一个字符，得到 'hell'</span>
</div></li><li><div class="code_line">s[<span class="hljs-number">-2</span>:]  <span class="hljs-comment"># 同上，表示获取最后两个字符，得到 'lo'</span>
</div></li><li><div class="code_line">s[::<span class="hljs-number">-1</span>] <span class="hljs-comment"># 获取字符串的倒序排列，相当于 reverse 函数</span>
</div></li></ul></code></pre>
<p>step 和它前面的冒号要么同时写，要么同时不写，但 start 和 end 之间的冒号不能省，否则就不是切片而是获取元素了。再次强调 <code>array[start:end]</code> 表示的区间是 [a, b)，也许你会觉得这很难记，但同样的，这会得出以下美妙的公式：</p>
<blockquote>
  <p>array[:n] + array[n:] = array (0 &lt;= n &lt;= len(array))</p>
</blockquote>
<p>用代码来表示就是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">s[:<span class="hljs-number">2</span>] + s[<span class="hljs-number">2</span>:] == s  
</div></li><li><div class="code_line"><span class="hljs-comment"># True，因为 s[:2] 是 'he'，s[2:] 是 'llo'</span>
</div></li></ul></code></pre>
<p>切片不仅可以用来获取数组的一部分值，修改切片也可以直接修改数组的对应部分，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]
</div></li><li><div class="code_line"><span class="hljs-comment"># a = [1, 22, 33, 44, 4, 5, 6]</span>
</div></li></ul></code></pre>
<p>并没有人规定切片的新值必须和原来的长度一致：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">3</span>]
</div></li><li><div class="code_line"><span class="hljs-comment"># a = [1, 3, 4, 5, 6]</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] = []
</div></li><li><div class="code_line"><span class="hljs-comment"># a = [1, 6]，相当于删除了中间的三个数字</span>
</div></li></ul></code></pre>
<p>但切片的新值必须也是可迭代的对象，比如这样写是不合法的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># TypeError: can only assign an iterable</span>
</div></li></ul></code></pre>
<h4 id="section114">1.1.4 循环与遍历</h4>
<p>一般来说，在 Python 中我们不会写出 <code>for (int i = 0; i &lt; len(array); ++i)</code> 这种风格的代码，而是使用 <code>for in</code> 这种语法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:
</div></li><li><div class="code_line">    print(i)
</div></li></ul></code></pre>
<p>虽然大家都知道 <code>for in</code> 语法，但它的某些灵活用法或许就不是那么众所周知了。有时候，我们会在 <code>if</code> 语句中对某个变量的值做多次判断，只要满足一个条件即可：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">name = <span class="hljs-string">'bs'</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> name == <span class="hljs-string">'hello'</span> <span class="hljs-keyword">or</span> name == <span class="hljs-string">'hi'</span> <span class="hljs-keyword">or</span> name == <span class="hljs-string">'bs'</span> <span class="hljs-keyword">or</span> name == <span class="hljs-string">'admin'</span>:
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Valid'</span>) 
</div></li></ul></code></pre>
<p>这种情况推荐用 <code>in</code> 来代替：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">name = <span class="hljs-string">'bs'</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> (<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>, <span class="hljs-string">'bs'</span>, <span class="hljs-string">'admin'</span>):
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Valid'</span>)
</div></li></ul></code></pre>
<p>有时候，如果我们想要把某件事重复固定的次数，用 <code>for in</code> 会显得有些啰嗦，这时候可以借助 <code>range</code> 类型：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hi'</span>) <span class="hljs-comment"># 打印五次 'Hi'</span>
</div></li></ul></code></pre>
<p><code>range</code> 的语法和切片类似，比如我们需要访问数组所有奇数下标的元素，可以这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(a), <span class="hljs-number">2</span>):
</div></li><li><div class="code_line">    print(a[i])
</div></li></ul></code></pre>
<p>在这种写法中，我们不仅能获得元素，还能知道元素的下标，这与使用 <code>enumerate(iterable [, start ])</code> 函数类似：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i, n <span class="hljs-keyword">in</span> enumerate(a):
</div></li><li><div class="code_line">    print(i, n)
</div></li></ul></code></pre>
<h4 id="section115">1.1.5 魔术方法</h4>
<p>也许你已经注意到了，数组和字符串都支持切片，而且语法高度统一。这在某些强类型语言（比如我经常接触的 Objective-C 和 Java）中是不可能的，事实上，Python 能够支持这样统一的语法，并非巧合，而是因为所有用中括号进行下标访问的操作，其实都是调用这个类的 <code>__getitem__</code> 方法。</p>
<p>比如我们完全可以让自己的类也支持通过下标访问：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.chapters = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, n)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self.chapters[n]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">b = Book()
</div></li><li><div class="code_line">print(b[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 结果是 2</span>
</div></li></ul></code></pre>
<p>需要注意的是，这段代码几乎不会出问题（除非数组越界），这是因为我们直接把下标传到了内部的 <code>self.chapters</code> 数组上。但如果要自己处理下标，需要牢记它不一定是数字，也可以是切片，因此更完整的逻辑应该是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, n)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> isinstance(n, int): <span class="hljs-comment"># n是索引</span>
</div></li><li><div class="code_line">        <span class="hljs-comment"># 处理索引</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> isinstance(n, slice): <span class="hljs-comment"># n是切片</span>
</div></li><li><div class="code_line">        <span class="hljs-comment"># 通过 n.start，n.stop 和 n.step 来处理切片</span>
</div></li></ul></code></pre>
<p>与静态语言不同的是，任何实现了 <code>__getitem__</code> 都支持通过下标访问，而不用声明为实现了某个协议，这种特性也被称为 “鸭子类型”。鸭子类型并不要求某个类 <strong>是什么</strong>，仅仅要求这个类 <strong>能做什么</strong>。</p>
<p>顺便说一句，实现了 <code>__getitem__</code> 方法的类都是可迭代的，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">b = Book()
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> b:
</div></li><li><div class="code_line">    print(c)
</div></li></ul></code></pre>
<p>后续的章节还会介绍更多 Python 中的魔术方法，这种方法的名称前后都有两个下划线，如果读作 “下划线-下划线-getitem” 会比较拗口，因此可以读作 “dunder-getitem” 或者 “双下-getitem”，类似的，我想每个人都能猜到 <code>__setitem__</code> 的作用和用法。</p>
<h3 id="section12">1.2 字典</h3>
<h4 id="section121">1.2.1 初始化字典</h4>
<p>最简单的创建一个字典的方式就是直接写字面量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">{<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">63</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">64</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">65</span>}
</div></li></ul></code></pre>
<p>字典字面量由大括号包住（注意区别于数组的中括号），键值对之间由逗号分割，每个键值对内部用冒号分割键和值。</p>
<p>如果数组的每个元素都是二元的元组，这个数组可以直接转成字典：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">dict([(<span class="hljs-string">'a'</span>, <span class="hljs-number">61</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-number">62</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-number">63</span>), (<span class="hljs-string">'d'</span>, <span class="hljs-number">64</span>), (<span class="hljs-string">'e'</span>, <span class="hljs-number">65</span>)])
</div></li></ul></code></pre>
<p>就像数组可以推导一样，字典也可以推导：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [(<span class="hljs-string">'a'</span>, <span class="hljs-number">61</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-number">62</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-number">63</span>), (<span class="hljs-string">'d'</span>, <span class="hljs-number">64</span>), (<span class="hljs-string">'e'</span>, <span class="hljs-number">65</span>)]
</div></li><li><div class="code_line">d = {letter: number <span class="hljs-keyword">for</span> letter, number <span class="hljs-keyword">in</span> a} <span class="hljs-comment"># 这里用到了元组拆包</span>
</div></li></ul></code></pre>
<p>只要记得外面还是大括号就行了。</p>
<p>两个独立的数组可以被压缩成一个字典：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">numbers = [<span class="hljs-number">61</span>, <span class="hljs-number">62</span>, <span class="hljs-number">63</span>, <span class="hljs-number">64</span>, <span class="hljs-number">65</span>]
</div></li><li><div class="code_line">letters = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]
</div></li><li><div class="code_line">dict(zip(letters, numbers))
</div></li></ul></code></pre>
<p>正如 zip 的意思所表示的，超出长处的那部分数组会被抛弃。</p>
<h4 id="section122">1.2.2 查询字典</h4>
<p>最简单方法是直接写键名，但如果键名不存在会抛出 <code>KeyError</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>}
</div></li><li><div class="code_line">d[<span class="hljs-string">'a'</span>] <span class="hljs-comment"># 值是 61</span>
</div></li><li><div class="code_line">d[<span class="hljs-string">'b'</span>] <span class="hljs-comment"># KeyError: 'b'</span>
</div></li></ul></code></pre>
<p>可以用 <code>if key in dict</code> 的判断来检查键是否存在，甚至可以先 <code>try</code> 再 <code>catch KeyError</code> ，但更加优雅简洁一些的写法是用 <code>get(k, default)</code> 方法来提供默认值：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>}
</div></li><li><div class="code_line">d.get(<span class="hljs-string">'a'</span>, <span class="hljs-number">62</span>) <span class="hljs-comment"># 得到 61</span>
</div></li><li><div class="code_line">d.get(<span class="hljs-string">'b'</span>, <span class="hljs-number">62</span>) <span class="hljs-comment"># 得到 62</span>
</div></li></ul></code></pre>
<p>不过有时候，我们可能不仅仅要读出默认属性，更希望能把这个默认属性能写入到字典中，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {}
</div></li><li><div class="code_line"><span class="hljs-comment"># 我们想对字典中某个 Value 做操作，如果 Key 不存在，就先写入一个空值</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> <span class="hljs-string">'list'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> d:
</div></li><li><div class="code_line">    d[<span class="hljs-string">'list'</span>] = []
</div></li><li><div class="code_line">d[<span class="hljs-string">'list'</span>].append(<span class="hljs-number">1</span>)
</div></li></ul></code></pre>
<p>这种情况下，<code>setdefault(key, default)</code> 函数或许更合适：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d.setdefault(<span class="hljs-string">'key'</span>, []).append(<span class="hljs-number">1</span>)
</div></li></ul></code></pre>
<p>这个函数虽然名为 <code>set</code>，但作用其实是查找，仅仅在查找不到时才会把默认值写入字典。</p>
<h4 id="section123">1.2.3 遍历字典</h4>
<p>直接遍历字典实际上是遍历了字典的键，因此也可以通过键获取值：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">63</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">64</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">65</span>}
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d:
</div></li><li><div class="code_line">    print(i, d[i])
</div></li><li><div class="code_line"><span class="hljs-comment">#b 62</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#a 61</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#e 65</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#d 64</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#c 63</span>
</div></li></ul></code></pre>
<p>我们也可以用字典的 <code>keys()</code> 或者 <code>values()</code> 方法显式的获取键和值。字典还有一个 <code>items()</code> 方法，它返回一个数组，每个元素都是由键和值组成的二元元组：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">63</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">64</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">65</span>}
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> d.items():
</div></li><li><div class="code_line">    print(k, v)
</div></li><li><div class="code_line"><span class="hljs-comment">#e 65</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#d 64</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#a 61</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#c 63</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#b 62</span>
</div></li></ul></code></pre>
<p>可见 <code>items()</code> 方法和字典的构造方法互为逆操作，因为这个公式总是成立的：</p>
<blockquote>
  <p>dict(d.items()) == d</p>
</blockquote>
<h4 id="section124">1.2.4 字典的魔术方法</h4>
<p>在 1.1.4 节中介绍过，通过下标访问最终都会由 <code>__getitem__</code> 这个魔术方法处理，因此字典的 <code>d[key]</code> 这种写法也不例外， 如果键不存在，则会走到 <code>__missing__</code> 方法，再给一次挽救的机会。比如我们可以实现一个字典， 自动忽略键的大小写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDict</span><span class="hljs-params">(dict)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__missing__</span><span class="hljs-params">(self, key)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> key.islower():
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> KeyError(key)
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> self[key.lower()]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = MyDict({<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>})
</div></li><li><div class="code_line">d[<span class="hljs-string">'A'</span>] <span class="hljs-comment"># 返回 61</span>
</div></li><li><div class="code_line"><span class="hljs-string">'A'</span> <span class="hljs-keyword">in</span> d <span class="hljs-comment"># False</span>
</div></li></ul></code></pre>
<p>这个字典比较简陋，比如 key 可能不是字符串，不过我没有处理太多情况，因为它主要是用来演示 <code>__missing__</code> 的用法，如果想要最后一行的 <code>in</code> 语法正确工作，需要重写 <code>__contains__</code> 这个魔术方法，过程类似，就不赘述了。</p>
<p>虽然通过自定义的函数也能实现相似的效果，不过这个自定义字典对用户更加透明，如果不在文档中说明，调用方很难察觉到字典的内部逻辑被修改了。 Python 有很多强大的功能，可以具备这种内部进行修改，但是对外保持透明的能力。这可能是我们第一次体会到，后续还会不断的经历。</p>
<h4 id="section125">1.2.5 集合</h4>
<p>集合更像是不会有重复元素的数组，但它的本质是以元素的哈希值作为 Key，从而实现去重的逻辑。因此，集合也可以推导，不过得用字典的语法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
</div></li><li><div class="code_line">d = {i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">5</span>}
</div></li><li><div class="code_line"><span class="hljs-comment"># d = {1, 2, 3, 4}，注意这里的大括号</span>
</div></li></ul></code></pre>
<p>回忆一下，二进制逻辑运算一共有三个运算符，按位或 <code>|</code>，按位与 <code>&amp;</code> 和异或 <code>^</code>，这三个运算符也可以用在集合之间，而且含义变化不大。比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a | b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {1, 2, 3, 4, 5}</span>
</div></li></ul></code></pre>
<p>这里的 <code>|</code> 运算表示并集，也就是 c 中的任意元素，要么在 a，要么在 b 集合中。类似的，按位与 <code>&amp;</code> 运算求的就是交集：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a &amp; b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {3}</span>
</div></li></ul></code></pre>
<p>而异或则表示那些只在 a 不在 b 或者只在 b 不在 a 的元素。或者换个说法，表示那些在集合 a 和 b 中出现了且仅出现了一次的元素：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a ^ b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {1, 2, 4, 5}</span>
</div></li></ul></code></pre>
<p>还有一个差集运算 <code>-</code>，表示在集合 a 中但不在集合 b 中的元素：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a - b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {1, 2}</span>
</div></li></ul></code></pre>
<p>回忆一下韦恩图，就会得到以下公式（虽然并没有什么卵用）：</p>
<blockquote>
  <p>A | B = (A ^ B) | (A &amp; B)<br>
  A ^ B = (A - B) | (B - A)</p>
</blockquote>
<h3 id="section13">1.3 字符串</h3>
<h4 id="section131">1.3.1 字符串编码</h4>
<p>用 Python 写过爬虫的人都应该感受过被字符串编码支配的恐惧。简单来说，编码指的是将可读的字符串转换成不太可读的数字，用来存储或者传输。解码则指的是将数字还原成字符串的过程。常见的编码有 ASCII、GBK 等。</p>
<p>ASCII 编码是一个相当小的字符集合，只有一百多个常用的字符，因此只用一个字节（8 位）就能表示，为了存储本国语言，各个国家都开发出了自己的编码，比如中文的 GBK。这就带来了一个问题，如果我想要在一篇文章中同时写中文和日文，就无法实现了，除非能对每个字符指定编码，这个成本高到无法接受。</p>
<p>Unicode 则是一个最全的编码方式，每个 Unicode 字符占据 6 个字节，可以表示出 2 ^ 48 种字符。但随之而来的是 Unicode 编码后的内容不适合存储和发送，因此诞生了基于 Unicode 的再次编码，目的是为了更高效的存储。</p>
<p>更详细的概念分析和配图说明可以参考我的这篇文章：<a href="http://fullstack.blog/2017/09/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E5%85%A5%E9%97%A8%E7%A7%91%E6%99%AE/" target="_blank">字符串编码入门科普</a>，这里我们主要聊聊 Python 对字符串编码的处理。</p>
<p>首先，编码的函数是 <code>encode</code>，它是字符串的方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">s.encode()         <span class="hljs-comment"># 得到 b'hello'</span>
</div></li><li><div class="code_line">s.encode(<span class="hljs-string">'utf16'</span>)  <span class="hljs-comment"># 得到 b'\xff\xfeh\x00e\x00l\x00l\x00o\x00'</span>
</div></li></ul></code></pre>
<p><code>encode</code> 函数有两个参数，第一个参数不写表示使用默认的 <code>utf8</code> 编码，理论上会输出二进制格式的编码结果，但在终端打印时，被自动还原回字符串了。如果用 <code>utf16</code> 进行编码，则会看到编码以后的二进制结果。</p>
<p>前面说过，编码是字符转到二进制的转化过程，有时候在某个编码规范中，并没有指定某个字符是如何编码的，也就是找不到对应的数字，这时候编码就会报错：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">city = <span class="hljs-string">'São Paulo'</span>
</div></li><li><div class="code_line">b_city = city.encode(<span class="hljs-string">'cp437'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># UnicodeEncodeError: 'charmap' codec can't encode character '\xe3' in position 1: character maps to &lt;undefined&gt;</span>
</div></li></ul></code></pre>
<p>此时需要用到 <code>encode</code> 函数的第二个参数，用来指定遇到错误时的行为。它的值可以是 <code>'ignore'</code>，表示忽略这个不能编码的字符，也可以是 <code>'replace'</code>，表示用默认字符代替：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">b_city = city.encode(<span class="hljs-string">'cp437'</span>, errors=<span class="hljs-string">'ignore'</span>) 
</div></li><li><div class="code_line"><span class="hljs-comment"># b'So Paulo'</span>
</div></li><li><div class="code_line">b_city = city.encode(<span class="hljs-string">'cp437'</span>, errors=<span class="hljs-string">'replace'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># b'S?o Paulo'</span>
</div></li></ul></code></pre>
<p><code>decode</code> 完全是 <code>encode</code> 的逆操作，只有二进制类型才有这个函数。它的两个参数含义和 <code>encode</code> 函数完全一致，就不再介绍了。</p>
<p>从理论上来说，仅从编码后的内容上来看，是无法确定编码方式的，也无法解码出原来的字符。但不同的编码有各自的特点，虽然无法完全倒推，但可以从概率上来猜测，如果发现某个二进制内容，有 99% 的可能性是 <code>utf8</code> 编码生成的，我们就可以用 <code>utf8</code> 进行解码。Python 提供了一个强大的工具包 <code>Chardet</code>  来完成这一任务：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">octets = <span class="hljs-string">b'Montr\xe9al'</span>
</div></li><li><div class="code_line">chardet.detect(octets)
</div></li><li><div class="code_line"><span class="hljs-comment"># {'encoding': 'ISO-8859-1', 'confidence': 0.73, 'language': ''}</span>
</div></li><li><div class="code_line">octets.decode(<span class="hljs-string">'ISO-8859-1'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># Montréal</span>
</div></li></ul></code></pre>
<p>返回结果中包含了猜测的编码方式，以及可信度。可信度越高，说明是这种编码方式的可能性越大。</p>
<p>有时候，我们拿到的是二进制的字符串字面量，比如 <code>68 65 6c 6c 6f</code>，前文说过只有二进制类型才有 <code>decode</code> 函数，所以需要通过二进制的字面量生成二进制变量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'68 65 6c 6c 6f'</span>
</div></li><li><div class="code_line">b = bytearray.fromhex(s)
</div></li><li><div class="code_line">b.decode()  <span class="hljs-comment"># hello</span>
</div></li></ul></code></pre>
<h4 id="section132">1.3.2 字符串的常用方法</h4>
<p>字符串的 <code>split(sep, maxsplit)</code> 方法可以以指定的分隔符进行分割，有点类似于 Shell 中的 <code>awk -F ' '</code>'，第一个 <code>sep</code> 参数表示分隔符，不填则为空格：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'a b c d e'</span>
</div></li><li><div class="code_line">a = s.split()
</div></li><li><div class="code_line"><span class="hljs-comment"># a = ['a', 'b', 'c', 'd', 'e']</span>
</div></li></ul></code></pre>
<p>第二个参数 <code>maxsplit</code> 表示最多分割多少次，因此返回数组的长度是 <code>maxsplit + 1</code>。举个例子说明下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'a;b;c;d;e'</span>
</div></li><li><div class="code_line">a = s.split(<span class="hljs-string">';'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># a = ['a', 'b', 'c', 'd', 'e']</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">b = s.split(<span class="hljs-string">';'</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># b = ['a', 'b', 'c;d;e']</span>
</div></li></ul></code></pre>
<p>如果想批量替换，则可以用 <code>replace(old, new[, count])</code> 方法，由中括号括起来的参数表示选填。</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">old = <span class="hljs-string">'a;b;c;d;e'</span>
</div></li><li><div class="code_line">new = old.replace(<span class="hljs-string">';'</span>, <span class="hljs-string">' '</span>, <span class="hljs-number">3</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># new = 'a b c d;e'</span>
</div></li></ul></code></pre>
<p><code>strip[chars]</code> 用于移除指定的字符们：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">old = <span class="hljs-string">"*****!!!Hello!!!*****"</span>
</div></li><li><div class="code_line">new = old.strip(<span class="hljs-string">'*'</span>)  <span class="hljs-comment"># 得到 '!!!Hello!!!'</span>
</div></li><li><div class="code_line">new = old.strip(<span class="hljs-string">'*！'</span>)  <span class="hljs-comment"># 得到 'Hello'</span>
</div></li></ul></code></pre>
<p>如果不传参数，则默认移除空格。其实 <code>strip</code> 等价于分别执行 <code>lstrip()</code> 和 <code>rstrip()</code>，即分别从左侧和右侧进行移除。比如 <code>lstrip()</code> 表示从左侧第一个字符开始，移除空格，直到第一个非空格字符为止，所以字符串中间的空格，无论是 <code>lstrip</code> 还是 <code>strip()</code> 都是无法移除的。</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">old = <span class="hljs-string">'  Hello world  '</span>
</div></li><li><div class="code_line">new = old.strip()   <span class="hljs-comment"># 得到 'Hello wrold'</span>
</div></li><li><div class="code_line">new = old.lstrip()  <span class="hljs-comment"># 得到 'Hello world  '</span>
</div></li></ul></code></pre>
<p>最后一个常用方法是 <code>join</code>，其实这个可以理解为字符串的构造方法，它可以把数组转换成字符串：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = <span class="hljs-string">'a b c d e'</span>.split() <span class="hljs-comment"># 之前说过，结果是 ['a', 'b', 'c', 'd', 'e']</span>
</div></li><li><div class="code_line">s = <span class="hljs-string">';'</span>.join(array) <span class="hljs-comment"># 以分号为连接符，把数组中的元素连接起来</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># s = 'a;b;c;d;e'</span>
</div></li></ul></code></pre>
<p>所以 <code>join</code> 可以理解为 <code>split</code> 的逆操作，这个公式始终是成立的：</p>
<blockquote>
  <p>c.join(string.split(c)) = string</p>
</blockquote>
<p>上面这些字符串处理的函数，大多返回的还是字符串，因此可以链式调用，避免使用临时变量和多行代码，但也要避免过长（超过 3 个）的链式调用，以免影响可读性。</p>
<h4 id="section133">1.3.3 字符串格式化</h4>
<p>最初级的字符串格式化方法是使用 <code>+</code> 来拼接：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">        self.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">        self.sex = <span class="hljs-string">'m'</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">print(<span class="hljs-string">'Name: '</span> + p.name + <span class="hljs-string">', Age: '</span> + str(p.age) + <span class="hljs-string">', Sex: '</span> + p.sex)
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span>
</div></li></ul></code></pre>
<p>这里必须要把 <code>int</code> 类型的年龄转成字符串以后才能进行拼接，这是因为 Python 是强类型语言，不支持类型的隐式转换。</p>
<p>这种做法的缺点在于如果输出结构比较复杂，极容易出现引号匹配错误的问题，可读性非常低。</p>
<p>Python 2 中的做法是使用占位符，类似于 C 语言中 <code>printf</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">content = <span class="hljs-string">'Name: %s, Age: %i, Sex: %c'</span> % (p.name, p.age, p.sex)
</div></li><li><div class="code_line">print(content)
</div></li></ul></code></pre>
<p>从结构上看，要比上一种写法清楚得多， 但每个变量都需要指定类型，这和 Python 的简洁不符。实际上每个对象都可以通过 <code>str()</code> 函数转换成字符串，这个函数的背后是 <code>__str__</code> 魔术方法。</p>
<p>Python 3 中的写法是使用 <code>format</code> 函数，比如我们来实现一下 <code>__str__</code> 方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">        self.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">        self.sex = <span class="hljs-string">'m'</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Name: {user.name}, Age: {user.age}, Sex: {user.sex}'</span>.format(user=self)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">print(p)
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span>
</div></li></ul></code></pre>
<p>除了把对象传给 <code>format</code> 函数并在字符串中展开以外， 也可以传入多个参数，并且通过下标访问他们：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">print(<span class="hljs-string">'{0}, {1}, {0}'</span>.format(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出：1, 2, 1，这里的 {1} 表示第二个参数</span>
</div></li></ul></code></pre>
<h4 id="section134heredoc">1.3.4 HereDoc</h4>
<p>Heredoc 不是 Python 特有的概念， 命令行和各种脚本中都会见到，它表示一种所见即所得的文本。</p>
<p>假设我们在写一个 HTML 的模板，绝大多数字符串都是常量，只有有限的几个地方会用变量去替换，那这个字符串该如何表示呢？一种写法是直接用单引号去定义：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;\nFriends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;\n&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;\n&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;\n&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back\nONCLICK=\'window.history.back()\'&gt;&lt;/FORM&gt;\n&lt;/BODY&gt;&lt;/HTML&gt;'</span>
</div></li></ul></code></pre>
<p>这段代码是自动生成的还好，如果是手动维护的，那么可读性就非常差，因为换行符和转义后的引号增加了理解的难度。如果用 heredoc 来写，就非常简单了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back
</span></div></li><li><div class="code_line"><span class="hljs-string">ONCLICK='window.history.back()'&gt;&lt;/FORM&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;/BODY&gt;&lt;/HTML&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">'''</span>
</div></li></ul></code></pre>
<p>Heredoc 主要是用来书写大段的字符串常量，比如 HTML 模板，SQL语句等等。</p>
<h2 id="section2">2 函数</h2>
<h3 id="section21">2.1 函数是一等公民</h3>
<p>一等公民指的是 Python 的函数能够动态创建，能赋值给别的变量，能作为参传给函数，也能作为函数的返回值。总而言之，函数和普通变量并没有什么区别。</p>
<p>函数是一等公民，这是函数式编程的基础，然而 Python 中基本上不会使用 lambda 表达式，因为在 lambda 表达式的中仅能使用单纯的表达式，不能赋值，不能使用 while、try 等语句，因此 lambda 表达式要么难以阅读，要么根本无法写出。这极大的限制了 lambda 表达式的使用场景。</p>
<p>上文说过，函数和普通变量没什么区别，但普通变量并不是函数，因为这些变量无法调用。但如果某个类实现了 <code>__call__</code> 这个魔术方法，这个类的实例就都可以像函数一样被调用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">        self.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">        self.sex = <span class="hljs-string">'m'</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        print(self)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Name: {user.name}, Age: {user.age}, Sex: {user.sex}'</span>.format(user=self)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">p() <span class="hljs-comment"># 等价于 print(p)</span>
</div></li></ul></code></pre>
<h3 id="section22">2.2 函数参数</h3>
<h4 id="section221">2.2.1 函数传参</h4>
<p>对于熟悉 C 系列语言的人来说，函数传参的方式一目了然。默认是拷贝传值，如果传指针是引用传值。我们先来看一段简单的 Python 代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(arg)</span>:</span>
</div></li><li><div class="code_line">    arg = <span class="hljs-number">5</span>
</div></li><li><div class="code_line">    print(arg)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">a = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">foo(a)
</div></li><li><div class="code_line">print(a)
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出 5 和 1</span>
</div></li></ul></code></pre>
<p>这段代码的结果符合我们的预期，从这段代码来看，Python 也属于拷贝传值。但如果再看这段代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(arg)</span>:</span>
</div></li><li><div class="code_line">    arg.append(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">    print(arg)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">a = [<span class="hljs-number">1</span>]
</div></li><li><div class="code_line">foo(a)
</div></li><li><div class="code_line">print(a) <span class="hljs-comment"># 输出两个 [1, 1]</span>
</div></li></ul></code></pre>
<p>你会发现参数数组在函数内部被改变了。就像是 C 语言中传递了变量的指针一样。所以 Python 到底是拷贝传值还是引用传值呢？答案<strong>都是否定的</strong>！</p>
<p>Python 的传值方式可以被理解为混合传值。对于那些不可变的对象（比如 1.1.2 节中介绍过的元组，还有数字、字符串类型），传值方式是拷贝传值；对于那些可变对象（比如数组和字典）则是引用传值。</p>
<h4 id="section222">2.2.2 默认参数</h4>
<p>Python 的函数可以有默认值，这个功能很好用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(a, l=[])</span>:</span>
</div></li><li><div class="code_line">    l.append(a)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> l
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">foo(<span class="hljs-number">2</span>,[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 给数组 [1] 添加一个元素 2，得到 [1,2]</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">2</span>)      <span class="hljs-comment"># 没有传入数组，使用默认的空数组，得到 [2]</span>
</div></li></ul></code></pre>
<p>然而如果这样调用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 利用默认参数，得到 [2]</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 竟然得到了 [2, 3]</span>
</div></li></ul></code></pre>
<p>函数调用了两次以后，默认参数被改变了，也就是说函数调用产生了副作用。这是因为默认参数的存储并不像函数里的临时变量一样存储在栈上、随着函数调用结束而释放，而是存储在函数这个对象的内部：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo.__defaults__  <span class="hljs-comment"># 一开始确实是空数组</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 利用默认参数，得到 [2]</span>
</div></li><li><div class="code_line">foo.__defaults__  <span class="hljs-comment"># 如果打印出来看，已经变成 [2] 了</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 再添加一个元素就得到了 [2, 3]</span>
</div></li></ul></code></pre>
<p>因为函数 <code>foo</code> 作为一个对象，不会被释放，因此这个对象内部的属性也不会随着多次调用而自动重置，会一直保持上次发生的变化。基于这个前提，我们得出一个结论：<strong>函数的默认参数不允许是可变对象</strong>，比如这里的 <code>foo</code> 函数需要这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(a, l=None)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
</div></li><li><div class="code_line">        l = []
</div></li><li><div class="code_line">    l.append(a)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> l
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">print(foo(<span class="hljs-number">2</span>)) <span class="hljs-comment"># 得到 [2]</span>
</div></li><li><div class="code_line">print(foo(<span class="hljs-number">3</span>)) <span class="hljs-comment"># 得到 [3]</span>
</div></li></ul></code></pre>
<p>现在，给参数添加默认值的行为在函数体中完成，不会随着函数的多次调用而累积。</p>
<p>对于 Python 的默认参数来说：</p>
<blockquote>
  <p>如果默认值是不可变的，可以直接设置默认值，否则要设置为 None 并在函数体中设置默认值。</p>
</blockquote>
<h4 id="section223">2.2.3 多参数传递</h4>
<p>当参数个数不确定时，可以在参数名前加一个 <code>*</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args)</span>:</span>
</div></li><li><div class="code_line">    print(args)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 输出 [1, 2, 3]</span>
</div></li></ul></code></pre>
<p>如果直接把数组作为参数传入，它其实是单个参数，如果要把数组中所有元素都作为单独的参数传入，则在数组前面加上 <code>*</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]    
</div></li><li><div class="code_line">foo(a)  <span class="hljs-comment"># 会输出 ([1,2,3], )   因为只传了一个数组作为参数</span>
</div></li><li><div class="code_line">foo(*a) <span class="hljs-comment"># 输出 [1, 2, 3]</span>
</div></li></ul></code></pre>
<p>这里的单个 <code>*</code> 只能接收非关键字参数，也就是仅有参数值的哪些参数。如果想接受关键字参数，需要用 <code>**</code> 来表示：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args, **kwargs)</span>:</span>
</div></li><li><div class="code_line">    print(args)
</div></li><li><div class="code_line">    print(kwargs)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">foo(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>, a=<span class="hljs-number">61</span>, b=<span class="hljs-number">62</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># 第一行输出：(1, 2, 3)</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 第二行输出：{'a': 61, 'b': 62}</span>
</div></li></ul></code></pre>
<p>类似的，字典变量传入函数只能作为单个参数，如果要想展开并被 <code>**kwargs</code> 识别，需要在字典前面加上两个星号 <code>**</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>}
</div></li><li><div class="code_line">foo(*a, **d)
</div></li></ul></code></pre>
<h4 id="section224">2.2.4 参数分类</h4>
<p>Python 中函数的参数可以分为两大类：</p>
<ol>
<li>定位参数（Positional）：表示参数的位置是固定的。比如对于函数 <code>foo(a, b)</code> 来说，<code>foo(1, 2)</code> 和 <code>foo(2, 1)</code> 就是截然不同的，a 和 b 的位置是固定的，不可随意调换。</li>
<li>关键词参数（Keyword）：表示参数的位置不重要，但是参数名称很重要。比如 <code>foo(a = 1, b = 2)</code> 和 <code>foo(b = 2, a = 1)</code> 的含义相同。</li>
</ol>
<p>有一种参数叫做仅限关键字（Keyword-Only）参数，比如考虑这个函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args, n=<span class="hljs-number">1</span>, **kwargs)</span>:</span>
</div></li><li><div class="code_line">    print(n)
</div></li></ul></code></pre>
<p>这个函数在调用时，如果参数 n 不指定名字，就会被前面的 <code>*args</code> 处理掉，如果指定的名字不是 n，又会被后面的 <code>**kwargs</code> 处理掉，所以参数 n 必须精确的以 <code>(n = xxx)</code> 的形式出现，也就是 Keyworld-Only。</p>
<h3 id="section23">2.3 函数内省</h3>
<p>在 2.2.2 节中，我们查看了函数变量的 <code>__defaults__</code> 属性，其实这就是一种内省，也就是在运行时动态的查看变量的信息。</p>
<p>前文说过，函数也是对象，因此函数的变量个数，变量类型都应该有办法获取到，如果你需要开发一个框架，也许会对函数有各种奇葩的检查和校验。 </p>
<p>以下面这个函数为例：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">g = <span class="hljs-number">1</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(m, *args, n, **kwargs)</span>:</span>
</div></li><li><div class="code_line">    a = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    b = <span class="hljs-number">2</span>
</div></li></ul></code></pre>
<p>首先可以获取函数名，函数所在模块的全局变量等：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo.__globals__   <span class="hljs-comment"># 全局变量，包含了 g = 1</span>
</div></li><li><div class="code_line">foo.__name__      <span class="hljs-comment"># foo</span>
</div></li></ul></code></pre>
<p>我们还可以看到函数的参数，函数内部的局部变量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo.__code__.co_varnames  <span class="hljs-comment"># ('m', 'n', 'args', 'kwargs', 'a', 'b')</span>
</div></li><li><div class="code_line">foo.__code__.co_argcount  <span class="hljs-comment"># 只计算参数个数，不考虑可变参数和仅限关键字参数，所以得到 1</span>
</div></li></ul></code></pre>
<p>或者用 <code>inspect</code> 模块来查看更详细的信息：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> inspect
</div></li><li><div class="code_line">sig = inspect.signature(foo)  <span class="hljs-comment"># 获取函数签名</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'m'</span>].kind      <span class="hljs-comment"># POSITIONAL_OR_KEYWORD 表示可以是定位参数或关键字参数</span>
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'args'</span>].kind   <span class="hljs-comment"># VAR_POSITIONAL 定位参数构成的数组</span>
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'n'</span>].kind      <span class="hljs-comment"># KEYWORD_ONLY 仅限关键字参数</span>
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'kwargs'</span>].kind <span class="hljs-comment"># VAR_KEYWORD 关键字参数构成的字典</span>
</div></li><li><div class="code_line">inspect.getfullargspec(foo)       
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：ArgSpec(args=['m', 'n'], varargs='args', keywords='kwargs', defaults=None)</span>
</div></li></ul></code></pre>
<p>本节的新 API 比较多，但并不要求记住这些 API 的用法。再次强调，本文的写作目的是为了建立读者对 Python 的总体认知，了解 Python <strong>能做什么</strong>，至于怎么做，那是文档该做的事。</p>
<h3 id="section24">2.4 装饰器</h3>
<h4 id="section241">2.4.1 设计模式的消亡</h4>
<p>经典的设计模式有 23 个，虽然设计模式都是常用代码的总结，理论上来说与语法无关。但不得不承认的是，标准的设计模式在不同的语言中，有的因为语法的限制根本无法轻易实现（比如在 C 语言中实现组合模式），有的则因为语言的特定功能，变得冗余啰嗦。</p>
<p>以策略模式为例，有一个抽象的策略类，定义了策略的接口，然后使用者选择一个具体的策略类，构造他们的实例并且调用策略方法。具体代码可以参考：<a href="https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/646307?fr=aladdin" target="_blank">策略模式在百度百科的定义</a>。</p>
<p>然而这些对象本身并没有作用，它们仅仅是可以调用相同的方法而已，只不过在 Java 中，所有的任务都需要由对象来完成。即使策略本身就是一个函数，但也必须把它包裹在一个策略对象中。所以在 Python 中更优雅写法是直接把策略函数作为变量使用。不过这就引入一个问题，如何判断某个函数是个策略呢，毕竟在面向对象的写法中，只要检查它的父类是否是抽象的策略类即可。</p>
<p>也许你已经见过类似的写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@strategy</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strategyA</span><span class="hljs-params">(n)</span>:</span>
</div></li><li><div class="code_line">    print(n * <span class="hljs-number">2</span>)
</div></li></ul></code></pre>
<p>下面就开始介绍装饰器。</p>
<h4 id="section242">2.4.2 装饰器的基本原理</h4>
<p>首先，装饰器是个函数，它的参数是被装饰的函数，返回值也是一个函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(origin_func)</span>:</span>  <span class="hljs-comment"># 这个参数是被装饰的函数</span>
</div></li><li><div class="code_line">    print(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 先输出点东西</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> origin_func  <span class="hljs-comment"># 把原函数直接返回</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-meta">@decorate    # 注意这里不是函数调用，所以不用加括号，也不用加被修饰的函数名</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sayHello()  <span class="hljs-comment"># 如果没有装饰器，只会打印 'Hello'，实际结果是打印 1 再打印 'Hello'</span>
</div></li></ul></code></pre>
<p>因此，使用装饰器的这种写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@decorate</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li></ul></code></pre>
<p>和下面这种写法是完全等价的， 初学者可以把装饰器在心中默默的转换成下一种写法，以方便理解：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">foo = decorate(foo)
</div></li></ul></code></pre>
<p>需要注意的是，装饰器函数 <code>decorate</code> 在模块被导入时就会执行，而被装饰的函数只在被调用时才会执行，也就是说即使不调用 <code>sayHello</code> 函数也会输出 1，但这样就不会输出 Hello 了。</p>
<p>有了装饰器，配合前面介绍的函数对象，函数内省，我们可以做很多有意思的事，至少判断上一节中某个函数是否是策略是非常容易的。在装饰器中，我们还可以把策略函数都保存到数组中， 然后提供一个“推荐最佳策略”的功能， 其实就是遍历执行所有的策略，然后选择最好的结果。</p>
<h4 id="section243">2.4.3 装饰器进阶</h4>
<p>上一节中的装饰器主要是为了介绍工作原理，它的功能非常简单，并不会改变被装饰函数的运行结果，仅仅是在导入时装饰函数，然后输出一些内容。换句话说，即使不执行函数，也要执行装饰器中的 <code>print</code> 语句，而且因为直接返回函数的缘故，其实没有真正的起到装饰的效果。</p>
<p>如何做到装饰时不输出任何内容，仅在函数执行最初输出一些东西呢？这是常见的 AOP（面向切片编程） 的需求。这就要求我们不能再直接返回被装饰的函数，而是应该返回一个新的函数，所以新的装饰器需要这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(origin_func)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_func</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">        origin_func()
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> new_func
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">decorate
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sayHello() <span class="hljs-comment"># 运行结果不变，但是仅在调用函数 sayHello 时才会输出 1</span>
</div></li></ul></code></pre>
<p>这个例子的工作原理是，<code>sayHello</code> 函数作为参数 <code>origin_func</code> 被传到装饰器中，经过装饰以后，它实际上变成了 <code>new_func</code>，会先输出 1 再执行原来的函数，也就是 <code>sayHello</code>。</p>
<p>这个例子很简陋，因为我们知道了 <code>sayHello</code> 函数没有参数，所以才能定义一个同样没有参数的替代者：<code>nwe_func</code>。如果我们在开发一个框架，要求装饰器能对任意函数生效，就需要用到 2.2.3 中介绍的 <code>*</code> 和 <code>**</code> 这种不定参数语法了。</p>
<p>如果查看 <code>sayHello</code> 函数的名字，得到的结果将是 <code>new_func</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">sayHello.__name__  <span class="hljs-comment"># new_func</span>
</div></li></ul></code></pre>
<p>这是很自然的，因为本质上其实执行的是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">new_func = decorate(sayHello)
</div></li></ul></code></pre>
<p>而装饰器的返回结果是另一个函数 <code>new_func</code>，两者仅仅是运行结果类似，但两个对象并没有什么关联。</p>
<p>所以为了处理不定参数，并且不改变被装饰函数的外观（比如函数名），我们需要做一些细微的修补工作。这些工作都是模板代码，所以 Python 早就提供了封装：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> functools
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(origin_func)</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @functools.wraps(origin_func)  # 这是 Python 内置的装饰器</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_func</span><span class="hljs-params">(*args, **kwargs)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">        origin_func(*args, **kwargs)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> new_func
</div></li></ul></code></pre>
<h4 id="section244">2.4.4 装饰器工厂</h4>
<p>在 2.4.2 节的代码注释中我解释过，装饰器后面不要加括号，被装饰的函数自动作为参数，传递到装饰器函数中。如果加了括号和参数，就变成手动调用装饰器函数了，大多数时候这与预期不符（因为装饰器的参数一般都是被装饰的函数）。</p>
<p>不过装饰器可以接受自定义的参数，然后返回另一个装饰器，这样外面的装饰器实际上就是一个装饰器工厂，可以根据用户的参数，生成不同的装饰器。还是以上面的装饰器为例，我希望输出的内容不是固定的 1，而是用户可以指定的，代码就应该这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> functools
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(content)</span>:</span>                        <span class="hljs-comment"># 这其实是一个装饰器工厂</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">real_decorator</span><span class="hljs-params">(origin_func)</span>:</span>          <span class="hljs-comment"># 这才是刚刚的装饰器</span>
</div></li><li><div class="code_line"><span class="hljs-meta">        @functools.wraps(origin_func)</span>
</div></li><li><div class="code_line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_func</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">            print(<span class="hljs-string">'You said '</span> + str(content)) <span class="hljs-comment"># 现在输出内容可以由用户指定</span>
</div></li><li><div class="code_line">            origin_func()
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> new_func                       <span class="hljs-comment"># 在装饰器里，返回的是新的函数</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> real_decorator                     <span class="hljs-comment"># 装饰器工厂返回的是装饰器</span>
</div></li></ul></code></pre>
<p>装饰器工厂和装饰器的区别在于它可以接受参数，返回一个装饰器：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@decorate(2017)</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sayHello()
</div></li></ul></code></pre>
<p>其实等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">real_decorator = decorate(<span class="hljs-number">2017</span>)      <span class="hljs-comment"># 通过装饰器工厂生成装饰器</span>
</div></li><li><div class="code_line">new_func = real_decorator(sayHello)  <span class="hljs-comment"># 正常的装饰器工作逻辑</span>
</div></li><li><div class="code_line">new_func()                           <span class="hljs-comment"># 调用的是装饰过的函数</span>
</div></li></ul></code></pre>
<h2 id="section3">3 面向对象</h2>
<h3 id="section31">3.1 对象内存管理</h3>
<h4 id="section311">3.1.1 对象不是盒子</h4>
<p>C 语言中我们定义变量用到的语法是：</p>
<pre><code class="c language-c hljs cpp"><ul><li><div class="code_line"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;
</div></li></ul></code></pre>
<p>这背后的含义是定义了一个 <code>int</code> 类型的变量 <code>a</code>，相当于申请了一个名为 <code>a</code> 的盒子（存储空间），里面装了数字 1。<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/d488dd71e0be57efe82f076c550e6a22.png" alt=""></p>
<p>然后我们改变 <code>a</code> 的值：<code>a = 2;</code>，可以打印 <code>a</code> 的地址来证明它并没有发生变化。所以只是盒子里装的内容（指针指向的位置）发生了改变：<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/63785ebe7adfb514dcc88d4b96a34cad.png" alt=""></p>
<p>但是在 Python 中，变量不是盒子。比如同样的定义变量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = <span class="hljs-number">1</span>
</div></li></ul></code></pre>
<p>这里就不能把 <code>a</code> 理解为 <code>int</code> 类型的变量了。因为在 Python 中，变量没有类型，值才有，或者说只有对象才有类型。因为即使是数字 1，也是 <code>int</code> 类的实例，而变量 <code>a</code> 更像是给这个对象贴的一个标签。</p>
<p><img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/6d30c0da2d2108ccc071c8751c4e7c1a.png" alt=""><br>
如果执行赋值语句 <code>a = 2</code>，相当于把标签 a 贴在另一个对象上：<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/05a4f3b25b942f0656f1759eb5b6dbc6.png" alt=""></p>
<p>基于这个认知，我们现在应该更容易理解 2.2.1 节中所说的函数传参规则了。如果传入的是不可变类型，比如 <code>int</code>，改变它的值实际上就是把标签挂在新的对象上，自然不会改变原来的参数。如果是可变类型，并且做了修改，那么函数中的变量和外面的变量都是指向同一个对象的标签，所以会共享变化。</p>
<h4 id="section312">3.1.2 默认浅复制</h4>
<p>根据上一节的描述，直接把变量赋值给另一个变量， 还算不上复制：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">b = a
</div></li><li><div class="code_line">b == a   <span class="hljs-comment"># True，等同性校验，会调用 __eq__ 函数，这里只判断内容是否相等</span>
</div></li><li><div class="code_line">b <span class="hljs-keyword">is</span> a   <span class="hljs-comment"># True，一致性校验，会检查是否是同一个对象，调用 hash() 函数，可以理解为比较指针</span>
</div></li></ul></code></pre>
<p>可见不仅仅数组相同，就连变量也是相同的，可以把 b 理解为 a 的别名。</p>
<p>如果用切片，或者数组的构造函数来创建新的数组，得到的是原数组的浅拷贝：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">b = list(a)
</div></li><li><div class="code_line">b == a   <span class="hljs-comment"># True，因为数组内容相同</span>
</div></li><li><div class="code_line">b <span class="hljs-keyword">is</span> a   <span class="hljs-comment"># False，现在 a 和 b 是两个变量，恰好指向同一个数组对象</span>
</div></li></ul></code></pre>
<p>但如果数组中的元素是可变的，可以看到这些元素并没有被完全拷贝：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [[<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>]]
</div></li><li><div class="code_line">b = list(a)
</div></li><li><div class="code_line">b[<span class="hljs-number">0</span>].append(<span class="hljs-number">2</span>)
</div></li><li><div class="code_line">a <span class="hljs-comment"># 得到 [[1, 2], [2], [3]]，因为 a[0] 和 b[0] 其实还是挂在相同对象上的不同标签</span>
</div></li></ul></code></pre>
<p>如果想要深拷贝，需要使用 <code>copy</code> 模块的 <code>deepcopy</code> 函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> copy 
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">b = copy.deepcopy(a)
</div></li><li><div class="code_line">b[<span class="hljs-number">0</span>].append(<span class="hljs-number">2</span>)
</div></li><li><div class="code_line">b  <span class="hljs-comment"># 变成了 [[1, 2], [2], [3]]</span>
</div></li><li><div class="code_line">a  <span class="hljs-comment"># 还是 [[1], [2], [3]]</span>
</div></li></ul></code></pre>
<p>此时，不仅仅是每个元素的引用被拷贝，就连每个元素自己也被拷贝。所以现在的 <code>a[0]</code> 和 <code>b[0]</code> 是指向两个不同对象的两个不同变量（标签），自然就互不干扰了。</p>
<p>如果要实现自定义对象的深复制，只要实现 <code>__deepcopy__</code> 函数即可。这个概念在几乎所有面向对象的语言中都会存在，就不详细介绍了。</p>
<h4 id="section313">3.1.3 弱引用</h4>
<p>Python 内存管理使用垃圾回收的方式，当没有指向对象的引用时，对象就会被回收。然而对象一直被持有也并非什么好事，比如我们要实现一个缓存，预期目标是缓存中的内容随着真正对象的存在而存在，随着真正对象的消失而消失。如果因为缓存的存在，导致被缓存的对象无法释放，就会导致内存泄漏。</p>
<p>Python 提供了语言级别的支持，我们可以使用 <code>weakref</code> 模块，它提供了 <code>weakref.WeakValueDictionary</code> 这个弱引用字典来确保字典中的值不会被引用。如果想要获取某个对象的弱引用，可以使用 <code>weakref.ref(obj)</code>  函数。</p>
<h3 id="section32python">3.2 Python 风格的对象</h3>
<h4 id="section321">3.2.1 静态函数与类方法</h4>
<p>静态函数其实和类的方法没什么关系，它只是恰好定义在类的内部而已，所以这里我用函数（function) 来形容它。它可以没有参数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @staticmethod   # 用 staticmethod 这个修饰器来表明函数是静态的</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">Person.sayHello() <span class="hljs-comment"># 输出 'Hello`</span>
</div></li></ul></code></pre>
<p>静态函数的调用方式是类名加上函数名。类方法的调用方式也是这样，唯一的不同是需要用 <code>@staticmethod</code> 修饰器，而且方法的第一个参数必须是类：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @classmethod    # 用 classmethod 这个修饰器来表明这是一个类方法</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span><span class="hljs-params">(cls)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'Hi: '</span> + cls.__name__)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">Person.sayHi() <span class="hljs-comment"># 输出 'Hi: Person`</span>
</div></li></ul></code></pre>
<p>类方法和静态函数的调用方法一致，在定义时除了修饰器不一样，唯一的区别就是类方法需要多声明一个参数。这样看起来比较麻烦，但静态函数无法引用到类对象，自然就无法访问类的任何属性。</p>
<p>于是问题来了，静态函数有何意义呢？有的人说类名可以提供命名空间的概念，但在我看来这种解释并不成立，因为每个 Python 文件都可以作为模块被别的模块引用，把静态函数从类里抽取出来，定义成全局函数，也是有命名空间的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-comment"># 在 module1.py 文件中：</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">global</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span> 
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Util</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @staticmethod</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 在 module2.py 文件中：</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> module1
</div></li><li><div class="code_line">module1.<span class="hljs-keyword">global</span>()        <span class="hljs-comment"># 调用全局函数</span>
</div></li><li><div class="code_line">module1.Util.helper()   <span class="hljs-comment"># 调用静态函数</span>
</div></li></ul></code></pre>
<p>从这个角度看，定义在类中的静态函数不仅不具备命名空间的优点，甚至调用语法还更加啰嗦。对此，我的理解是：<strong>静态函数可以被继承、重写，但全局函数不行</strong>，由于 Python 中的函数是一等公民，因此很多时候用函数替代类都会使代码更加简洁，但缺点就是无法继承，后面还会有更多这样的例子。</p>
<h4 id="section322attribute">3.2.2 属性 attribute</h4>
<p>Python （等多数动态语言）中的类并不像 C/OC/Java 这些静态语言一样，需要预先定义属性。我们可以直接在初始化函数中创建属性：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.name  <span class="hljs-comment"># 值是 'bestswifter'</span>
</div></li></ul></code></pre>
<p>由于 <code>__init__</code> 函数是运行时调用的，所以我们可以直接给对象添加属性：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">bs.age  <span class="hljs-comment"># 因为刚刚赋值了，所以现在取到的值是 22</span>
</div></li></ul></code></pre>
<p>如果访问一个不存在的属性，将会抛出异常。从以上特性来看，对象其实和字典非常相似，但这种过于灵活的特性其实蕴含了潜在的风险。比如某个封装好的父类中定义了许多属性， 但是子类的使用者并不一定清楚这一点，他们很可能会不小心就重写了父类的属性。一种隐藏并保护属性的方式是在属性前面加上两个下划线：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.__name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs.__name          <span class="hljs-comment"># 这样是无法获取属性的</span>
</div></li><li><div class="code_line">bs._Person__name   <span class="hljs-comment"># 这样还是可以读取属性</span>
</div></li></ul></code></pre>
<p>这是因为 Python 会自动处理以双下划线开头的属性，把他们重名为 <code>_Classname__attrname</code> 的格式。由于 Python 对象的所有属性都保存在实例的 <code>__dict__</code>  属性中，我们可以验证一下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs = Person()
</div></li><li><div class="code_line">bs.__dict__ 
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到 {'_Person__name': 'bestswifter'}</span>
</div></li></ul></code></pre>
<p>但很多人并不认可通过名称改写（name mangling) 的方式来存储私有属性，原因很简单，只要知道改写规则，依然<strong>很容易的</strong>就能读写私有属性。与其自欺欺人，不如采用更简单，更通用的方法，比如给私有属性前面加上单个下划线 <code>_</code>。</p>
<p>注意，以单个下划线开头的属性不会触发任何操作，完全靠自觉与共识。<strong>任何稍有追求的 Python 程序员，都不应该读写这些属性。</strong></p>
<h4 id="section323property">3.2.3 特性 property</h4>
<p>使用过别的面向对象语言的读者应该都清楚属性的 <code>getter</code> 和 <code>setter</code> 函数的重要性。它们封装了属性的读写操作，可以添加一些额外的逻辑，比如校验新值，返回属性前做一些修饰等等。最简陋的 <code>getter</code> 和 <code>setter</code> 就是两个普通函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self.name.upper()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span><span class="hljs-params">(self, new_name)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> isinstance(new_name, str):
</div></li><li><div class="code_line">            self.name = new_name.lower()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.get_name()   <span class="hljs-comment"># 得到大写的名字： 'BESTSWIFTER'</span>
</div></li><li><div class="code_line">bs.set_name(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 由于新的名字不是字符串，所以无法赋值</span>
</div></li><li><div class="code_line">bs.get_name()   <span class="hljs-comment"># 还是老的名字： 'BESTSWIFTER'</span>
</div></li></ul></code></pre>
<p>工作虽然完成了，但方法并不高明。在 1.2.3 节中我们就见识到了 Python 的一个特点：“内部高度封装，完全对外透明”。这里手动调用 <code>getter</code> 和 <code>setter</code> 方法显得有些愚蠢、啰嗦，比如对比下面的两种写法，在变量名和函数名很长的情况下，差距会更大：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs.name += <span class="hljs-string">'1995'</span>
</div></li><li><div class="code_line">bs.set_name(bs.get_name() + <span class="hljs-string">'1995'</span>)
</div></li></ul></code></pre>
<p>Python 提供了 <code>@property</code> 关键字来装饰 <code>getter</code> 和 <code>setter</code> 方法，这样的好处是可以直接使用点语法，了解 Objective-C 的读者对这一特性一定倍感亲切：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @property                        # 定义 getter</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>                  <span class="hljs-comment"># 函数名就是点语法访问的属性名</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self._name.upper()    <span class="hljs-comment"># 现在真正的属性是 _name 了</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-meta">    @name.setter                     # 定义 setter</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self, new_name)</span>:</span>        <span class="hljs-comment"># 函数名不变</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> isinstance(new_name, str):
</div></li><li><div class="code_line">            self._name = new_name.lower()  <span class="hljs-comment"># 把值存到私有属性 _name 里</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.name      <span class="hljs-comment"># 其实调用了 name 函数，得到大写的名字： 'BESTSWIFTER'</span>
</div></li><li><div class="code_line">bs.name = <span class="hljs-number">1</span>  <span class="hljs-comment"># 其实调用了 name 函数，因为类型不符，无法赋值</span>
</div></li><li><div class="code_line">bs.name      <span class="hljs-comment"># 还是老的名字： 'BESTSWIFTER'</span>
</div></li></ul></code></pre>
<p>我们已经在 2.4 节详细学习了装饰器，应该能意识到这里的 <code>@property</code> 和 <code>@xxx.setter</code> 都是装饰器。因此上述写法实际上等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self._name.upper()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span><span class="hljs-params">(self, new_name)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> isinstance(new_name, str):
</div></li><li><div class="code_line">            self._name = new_name.lower()
</div></li><li><div class="code_line">    <span class="hljs-comment"># 以上是老旧的 getter 和 setter 定义</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 如果不用 @property，可以定义一个 property 类的实例</span>
</div></li><li><div class="code_line">    name = property(get_name, set_name)
</div></li></ul></code></pre>
<p>可见，特性的本质是给类创建了一个类属性，它是 <code>property</code> 类的实例，构造方法中需要把 <code>getter</code>、<code>setter</code> 等函数传入，我们可以打印一下类的 <code>name</code> 属性来证明：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">Person.name  <span class="hljs-comment"># &lt;property object at 0x107c99868&gt;</span>
</div></li></ul></code></pre>
<p>理解特性的工作原理至关重要。以这里的 <code>name</code> 特性为例，我们访问了对象的 <code>name</code> 属性，但是它并不存在，所以会尝试访问类的 <code>name</code> 属性，这个属性是 <code>property</code> 类的实例，会对读写操作做特殊处理。这也意味着，如果我们重写了类的 <code>name</code> 属性，那么对象的读写方法就不会生效了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs = Person()
</div></li><li><div class="code_line">Person.name = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">bs.name  <span class="hljs-comment"># 实例并没有 name 属性，因此会访问到类的属性 name，现在的值是 'hello` 了</span>
</div></li></ul></code></pre>
<p>如果访问不存在的属性，默认会抛出异常，但如果实现了 <code>__getattr__</code> 函数，还有一次挽救的机会：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, attr)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.name    <span class="hljs-comment"># 直接访问属性</span>
</div></li><li><div class="code_line">bs.age     <span class="hljs-comment"># 得到 0，这是 __getattr__ 方法提供的默认值</span>
</div></li><li><div class="code_line">bs.age = <span class="hljs-number">1</span> <span class="hljs-comment"># 动态给属性赋值</span>
</div></li><li><div class="code_line">bs.age     <span class="hljs-comment"># 得到 1，注意！！！这时候就不会再调用 __getattr__ 方法了</span>
</div></li></ul></code></pre>
<p>由于 <code>__getattr__</code> 只是兜底策略，处理一些异常情况，并非每次都能被调用，所以不能把重要的业务逻辑写在这个方法中。</p>
<h4 id="section324">3.2.4 特性工厂</h4>
<p>在上一节中，我们利用特性来封装 <code>getter</code> 和 <code>setter</code>，对外暴露统一的读写接口。但有些 <code>getter</code> 和 <code>setter</code> 的逻辑其实是可以复用的，比如商品的价格和剩余数量在赋值时，都必须是大于 0 的数字。这时候如果每次都要写一遍 <code>setter</code>，代码就显得很冗余，所以我们需要一个能批量生产特性的函数。由于我们已经知道了特性是 <code>property</code> 类的实例，而且是类的属性，所以代码可以这样写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quantity</span><span class="hljs-params">(storage_name)</span>:</span>  <span class="hljs-comment"># 定义 getter 和 setter</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_getter</span><span class="hljs-params">(instance)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[storage_name]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_setter</span><span class="hljs-params">(instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            <span class="hljs-comment"># 把值保存在实例的 __dict__ 字典中</span>
</div></li><li><div class="code_line">            instance.__dict__[storage_name] = value 
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> property(qty_getter, qty_setter) <span class="hljs-comment"># 返回 property 的实例</span>
</div></li></ul></code></pre>
<p>有了这个特性工厂，我们可以这样来定义特性：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>:</span>
</div></li><li><div class="code_line">    price = quantity(<span class="hljs-string">'price'</span>)
</div></li><li><div class="code_line">    number = quantity(<span class="hljs-string">'number'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = Item()
</div></li><li><div class="code_line">i.price = <span class="hljs-number">-1</span> 
</div></li><li><div class="code_line"><span class="hljs-comment"># Traceback (most recent call last):</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ValueError: value must be &gt; 0</span>
</div></li></ul></code></pre>
<p>作为追求简洁的程序员，我们不禁会问，在 <code>price = quantity('price')</code> 这行代码中，属性名重复了两次，能不能在 <code>quantity</code> 函数中自动读取左边的属性名呢，这样代码就可以简化成 <code>price = quantity()</code> 了。</p>
<p>答案显然是否定的，因为右边的函数先被调用，然后才能把结果赋值给左边的变量。不过我们可以采用迂回策略，变相的实现上面的需求：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quantity</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">try</span>:
</div></li><li><div class="code_line">        quantity.count += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">except</span> AttributeError:
</div></li><li><div class="code_line">        quantity.count = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    storage_name = <span class="hljs-string">'_{}:{}'</span>.format(<span class="hljs-string">'quantity'</span>, quantity.count)  
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_getter</span><span class="hljs-params">(instance)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[storage_name]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_setter</span><span class="hljs-params">(instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            instance.__dict__[storage_name] = value
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> property(qty_getter, qty_setter)
</div></li></ul></code></pre>
<p>这段代码中我们利用了两个技巧。首先函数是一等公民， 所以函数也是对象，自然就有属性。所以我们利用 <code>try ... except</code> 很容易的就给函数工厂添加了一个计数器对象 <code>count</code>，它每次调用都会增加，然后再拼接成存储时用的键 <code>storage_name</code> ，并且可以保证不同 <code>property</code> 实例的存储键名各不相同。</p>
<p>其次，<code>storage_name</code> 在 <code>getter</code> 和 <code>setter</code> 函数中都被引用到，而这两个函数又被 <code>property</code> 的实例引用，所以 <code>storage_name</code> 会因为被持有而延长生命周期。这也正是闭包的一大特性：能够捕获自由变量并延长它的生命周期和作用域。</p>
<p>我们来验证一下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>:</span>
</div></li><li><div class="code_line">    price = quantity()
</div></li><li><div class="code_line">    number = quantity()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = Item()
</div></li><li><div class="code_line">i.price = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">i.number = <span class="hljs-number">2</span>
</div></li><li><div class="code_line">i.price     <span class="hljs-comment"># 得到 1，可以正常访问</span>
</div></li><li><div class="code_line">i.number    <span class="hljs-comment"># 得到 2，可以正常访问</span>
</div></li><li><div class="code_line">i.__dict__  <span class="hljs-comment"># {'_quantity:0': 1, '_quantity:1': 2}</span>
</div></li></ul></code></pre>
<p>可见现在存储的键名可以被正确地自动生成。</p>
<h4 id="section325">3.2.5 属性描述符</h4>
<p>文件描述符的作用和特性工厂一样，都是为了批量的应用特性。它的写法也和特性工厂非常类似：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quantity</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, storage_name)</span>:</span>
</div></li><li><div class="code_line">        self.storage = storage_name
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[self.storage]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            instance.__dict__[self.storage] = value
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li></ul></code></pre>
<p>主要有以下几个改动：</p>
<ol>
<li>不用返回 <code>property</code> 类的实例了，因此 <code>getter</code> 和 <code>setter</code> 方法的名字是固定的，这样才能满足协议。</li>
<li><code>__get__</code> 方法的第一个参数是描述符类 <code>Quantity</code> 的实例，第二个参数 <code>self</code> 是要读取属性的实例，比如上面的 <code>i</code>，也被称作托管实例。第三个参数是托管类，也就是 <code>Item</code>。</li>
<li><code>__set__</code> 方法的前两个参数含义类似，第三个则是要读取的属性名，比如 <code>price</code>。</li>
</ol>
<p>和特性工厂类似，属性描述符也可以实现 <code>storage_name</code> 的自动生成，这里就不重复代码了。看起来属性描述符和特性工厂几乎一样，但由于属性描述符是类，它就可以继承。比如这里的 <code>Quantity</code> 描述符有两个功能：自动存储和值的校验。自动存储是一个非常通用的逻辑，而值的校验是可变的业务逻辑，所以我们可以先定义一个 <code>AutoStorage</code> 描述符来实现自动存储功能，然后留下一个空的 <code>validate</code> 函数交给子类去重写。</p>
<p>而特性工厂作为函数，自然就没有上述功能，这两者的区别类似于 3.2.1 节中介绍的静态函数与全局函数的区别。</p>
<h4 id="section326">3.2.6 实例属性的查找顺序</h4>
<p>我们知道类的属性都会存储在 <code>__dict__</code> 字典中，即使没有显式的给属性赋值，但只要字典里面有这个字段，也是可以读取到的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">p.__dict__[<span class="hljs-string">'name'</span>] = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">p.name  <span class="hljs-comment"># 不会报错，而是返回字典中的值，'bestswifter'</span>
</div></li></ul></code></pre>
<p>但我们在特性工厂和属性描述符的实现中，都是直接把属性的值存储在 <code>__dict__</code> 中，而且键就是属性名。之前我们还介绍过，特性的工作原理是没有直接访问实例的属性，而是读取了 <code>property</code> 的实例。那直接把值存在 <code>__dict__</code> 中，会不会导致特性失效，直接访问到原始内容呢？从之前的实践结果来看，答案是否定的，要解释这个问题，我们需要搞明白访问实例属性的查找顺序。</p>
<p>假设有这么一段代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">o = cls()   <span class="hljs-comment"># 假设 o 是 cls 类的实例</span>
</div></li><li><div class="code_line">o.attr      <span class="hljs-comment"># 试图访问 o 的属性 attr</span>
</div></li></ul></code></pre>
<p>再对上一节中的属性描述符做一个简单的分类：</p>
<ol>
<li>覆盖型描述符：定义了 <code>__set__</code> 方法的描述符</li>
<li>非覆盖型描述符：没有定义 <code>__set__</code> 方法的描述符</li>
</ol>
<p>在执行 <code>o.attr</code> 时，查找顺序如下：</p>
<ol>
<li>如果 <code>attr</code> 出现在 <code>cls</code> 或父类的 <code>__dict__</code> 中，且 <code>attr</code> 是覆盖型描述符，那么调用 <code>__get__</code> 方法。</li>
<li>否则，如果 <code>attr</code> 出现在 <code>o</code> 的<code>__dict__</code> 中，返回 <code>o.__dict__[attr]</code></li>
<li>否则，如果<code>attr</code> 出现在 <code>cls</code> 或父类的 <code>__dict__</code> 中，如果 <code>attr</code> 是非覆盖型描述符，那么调用 <code>__get__</code> 方法。</li>
<li>否则，如果没有非覆盖型描述符，直接返回 <code>cls.__dict__[attr]</code></li>
<li>否则，如果 <code>cls</code> 实现了 <code>__getattr__</code> 方法，调用这个方法</li>
<li>抛出 <code>AttributeError</code></li>
</ol>
<p>所以，在访问类的属性时，覆盖型描述符的优先级是高于直接存储在 <code>__dict__</code> 中的值的。</p>
<h3 id="section33">3.3 多继承</h3>
<p>本节内容部分摘自我的这篇文章：<a href="http://www.jianshu.com/p/fc105512bf40" target="_blank">从 Swift 的面向协议编程说开去</a>，本节聊的是多继承在 Python 中的知识，如果想阅读关于多继承的讨论，请参考原文。</p>
<h4 id="section331">3.3.1 多继承的必要性</h4>
<p>很多语言类的书籍都会介绍，多继承是个危险的行为。诚然，狭义上的多继承在绝大多数情况下都是不合理的。这里所谓的 <strong>“狭义”</strong>，指的是一个类拥有多个父类。我们要明确一个概念：继承的目的不是代码复用，而是声明一种 <code>is a</code> 的关系，代码复用只是 <code>is a</code> 关系的一种外在表现。</p>
<p>因此，如果你需要狭义上的多继承，还是应该先问问自己，真的存在这么多 <code>is a</code> 的关系么？你是需要声明这种关系，还是为了代码复用。如果是后者，有很多更优雅的解决方案，因为多继承的一个直接问题就是菱形问题（Diamond Problem）。</p>
<p>但是广义上的多继承是必须的，不能因为害怕多继承的问题就忽略多继承的优点。<strong>广义多继承</strong> 指的是通过定义接口（Interface）以及接口方法的默认实现，形成“一个父类，多个接口”的模式，最终实现代码的复用。当然，不是每个语言都有接口的概念，比如 Python 里面叫 Mixin，会在 3.3.3 节中介绍。</p>
<p>广义上的多继承非常常见，有一些教科书式的例子，比如动物可以按照哺乳动物，爬行动物等分类，也可以按照有没有翅膀来分类。某一个具体的动物可能满足上述好几类。在实际的开发中也到处都是广义多继承的使用场景，比如 iOS 或者安卓开发中，系统控件的父类都是固定的，如果想让他们复用别的父类的代码，就会比较麻烦。</p>
<h4 id="section332python">3.3.2 Python 的多继承</h4>
<p>Python 语法直接支持多继承：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'A'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-params">(A)</span>:</span>     <span class="hljs-comment"># 继承自 A，重写 foo 方法</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'B'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span><span class="hljs-params">(A)</span>:</span>     <span class="hljs-comment"># 继承自 A，重写 foo 方法</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'C'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span><span class="hljs-params">(B, C)</span>:</span>  <span class="hljs-comment"># 多继承的语法，父类之间用逗号间隔</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = D()
</div></li><li><div class="code_line">d.foo()         <span class="hljs-comment"># 输出：'B'</span>
</div></li></ul></code></pre>
<p>这就是著名的菱形问题，D 继承自 B 和 C，而 B 和 C 都继承自 A，他们的继承关系构成一个菱形。调用 D 类实例的 <code>foo</code> 方法会让人产生疑惑，它的父类们都实现了 <code>foo</code> 方法，到底以谁为准？</p>
<p>Python 有一套算法来计算遍历顺序，这个顺序叫做<strong>方法解析顺序（Method Resolution Oder，MRO）</strong>。这个算法叫做 C3 算法，可以参考这篇官方文档：<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank">The Python 2.3 Method Resolution Order</a></p>
<p>不过在绝大多数情况下，除非你的代码极度依赖多继承，否则都不需要了解这个算法的具体工作原理。一方面，我们可以调用某个特定父类的方法。我们也许已经注意到两个事实，首先类中定义的方法其实都是类的属性，但调用者都是类的实例。其次，类方法的第一个参数都是 <code>self</code>，表示方法的调用者，但我们调用时并不需要传入实例。这是因为其实实例方法的正规调用方式是这样的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">C.foo(C())
</div></li><li><div class="code_line"><span class="hljs-comment"># 或者是</span>
</div></li><li><div class="code_line">C.foo(d)
</div></li></ul></code></pre>
<p>这种调用方式符合定义，而且能够解释上述的两个疑问。然而这种调用方式不仅写起来麻烦，还很不合理，因为我们不仅要实例对象，还需这个实例所属的类才能调用。因此，Python 的做法是将类中定义的方法绑定到每一个实例上：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">D.foo  <span class="hljs-comment"># &lt;function B.foo at 0x10696c158&gt; 这个是真正的方法对象</span>
</div></li><li><div class="code_line">d      <span class="hljs-comment"># &lt;__main__.D object at 0x1075fa400&gt;  这个是 D 的一个实例</span>
</div></li><li><div class="code_line">d.foo  <span class="hljs-comment"># &lt;bound method B.foo of &lt;__main__.D object at 0x106967400&gt;&gt; 注意看地址和 d 是一致的</span>
</div></li><li><div class="code_line">d.foo.__self__ <span class="hljs-comment"># &lt;__main__.D object at 0x1075fa400&gt;，通过 __self__ 引用绑定的实例</span>
</div></li></ul></code></pre>
<p>可以清楚的从 <code>d.foo</code> 的输出结果看出来，它是绑定到 <code>d</code> 对象上的函数，第一个参数 <code>self</code> 就是 <code>d</code>。</p>
<p>另一方面，我们不仅可以调用任意父类的方法，还可以通过类的 <code>__mro__</code> 属性查看父类的继承顺序：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">D.__mro__
</div></li><li><div class="code_line"><span class="hljs-comment"># (&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)</span>
</div></li></ul></code></pre>
<p>所以，多继承的方法调用顺序一般情况下不会对开发代码造成太大的困扰。</p>
<h4 id="section333mixin">3.3.3 Mixin</h4>
<p>Mixin 不是 <strong>迷信</strong> 的拼音，它表示<strong>混入</strong>，可以方便的实现代码复用。在 Python 中，Mixin 是以多继承的形式实现的，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSONable</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_json</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">         <span class="hljs-keyword">return</span> str(self.__dict__)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugMixin</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">         <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Controller</span><span class="hljs-params">(BaseController, JSONable, DebugMixin)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li></ul></code></pre>
<p>Mixin 和多继承最大的区别在于它一般不产生菱形问题，但 Python 并没有语法层面的约束来保证这一点，所以对于 Mixin，我们一般需要遵守以下几个约定：</p>
<ol>
<li>一般命名以 Mixin、able、ible 结尾，明确表示混入，或者提供某种能力。</li>
<li>一般不要有复杂的继承关系，尤其不要和被混入的类（比如上面的 <code>Controller</code> 类）有共同的父类，避免菱形问题。</li>
<li>一般提供简单的功能，如果有多个功能，就写成多个 Mixin。</li>
<li>功能完备、独立，不要依赖被混入的类。</li>
<li>看到上述命名风格的类，不要实例化他们，仅用在多继承中。</li>
</ol>
<p>在 5.3.2 节中会有实际的 Mixin 的使用场景。</p>
<h4 id="section334">3.3.4 抽象类</h4>
<p>有时候我们需要在父类定义一个方法，然后交给子类去实现。这种方法叫做抽象方法， 定义了抽象方法的类叫做抽象类。抽象类不应该被实例化，在 Java 中，<code>Interface</code> 就是抽象类，它不能被实例化，只有实现了协议的类才能创建实例。</p>
<p>在 Python 中，抽象类需要把自己的 <code>metaclass</code> 设置为 <code>abc.ABCMeta</code>，并且用装饰器去标记抽象函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> abc
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseItem</span><span class="hljs-params">(Base, metaclass=abc.ABCMeta)</span>:</span>   <span class="hljs-comment"># 需要标记 metaclass</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @abc.abstractmethod                        # 抽象函数</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_price</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">         <span class="hljs-string">"""Method that should do something."""</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">item = BaseItem()
</div></li><li><div class="code_line"><span class="hljs-comment"># Traceback (most recent call last):</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># TypeError: Can't instantiate abstract class BaseItem with abstract methods get_price</span>
</div></li></ul></code></pre>
<p>如果设置了 <code>metaclass</code> 并且标记了抽象函数，那么任何没有实现抽象函数的子类（包括抽象类自己）都无法实例化。</p>
<h3 id="section34">3.4 元编程</h3>
<h4 id="section341">3.4.1 类工厂函数</h4>
<p>有些类的功能很单一，仅仅用来存储数据。但如果先声明一个长长的 <code>__init__</code> 函数，再挨个写 <code>self.xxx = xxx</code> 这种模板代码，就显得很啰嗦。其实也可以自己实现一个 1.1.2 节中的具名元组。具名元zu组是一个函数，它返回一个类：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">People = collections.namedtuple(<span class="hljs-string">'People'</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>])
</div></li><li><div class="code_line">p = People(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'22'</span>)
</div></li></ul></code></pre>
<p><code>namedtuple</code> 这种函数可以称为<strong>类工厂函数</strong>，因为它可以根据传入的参数，动态的生成类，我们来实现一个简化版的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_tuple</span><span class="hljs-params">(cls, names)</span>:</span>
</div></li><li><div class="code_line">    names = names.split(<span class="hljs-string">' '</span>)   <span class="hljs-comment"># 这里会得到属性的数组</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, *args)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">for</span> (name, value) <span class="hljs-keyword">in</span> zip(self.__slots__, args):
</div></li><li><div class="code_line">            <span class="hljs-comment"># slots 是属性名，args 是初始化的参数，一一对应起来用 setattr 给实例的属性赋值</span>
</div></li><li><div class="code_line">            setattr(self, name, value)  
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    cls_attrs = dict(__slots__ = names, __init__ = __init__)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> type(cls, (object, ), cls_attrs)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">People = my_tuple(<span class="hljs-string">'People'</span>, <span class="hljs-string">'name age'</span>)
</div></li><li><div class="code_line">p = People(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'22'</span>)
</div></li><li><div class="code_line">p.name   <span class="hljs-comment"># 'bestswifter'</span>
</div></li><li><div class="code_line">p.age    <span class="hljs-comment"># 22</span>
</div></li></ul></code></pre>
<p>这个类工厂非常简陋，比如不支持关键字参数，但用来演示类工厂的原理是已经足够了。类工厂的核心原理在于 <code>type</code> 函数，它不仅可以传入一个实例，返回实例的类型，也可以像这里的使用一样，传入三个参数，构造一个类。第一个参数表示类名，第二个参数是继承关系，最后一个则是类的属性。</p>
<h4 id="section342">3.4.2 元类的概念</h4>
<p>元类和类工厂函数的区别就像属性描述符和特性工厂函数的区别一样，<strong>前者是类，可以继承</strong>，后者不行。就像我们上一节中用 <code>type</code> 来生成类一样，Python 中的类都是 <code>type</code> 类的实例：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-string">'bestswifter'</span>.__class__  <span class="hljs-comment"># &lt;class 'str'&gt;，字符串都是 str 类的实例</span>
</div></li><li><div class="code_line">str.__class__            <span class="hljs-comment"># &lt;class 'type'&gt; str 类是 type 类的实例</span>
</div></li><li><div class="code_line">int.__class__            <span class="hljs-comment"># &lt;class 'type'&gt; int 也是 type 类的实例</span>
</div></li><li><div class="code_line">type.__class__           <span class="hljs-comment"># &lt;class 'type'&gt; type 类是自己的实例，防止死循环</span>
</div></li></ul></code></pre>
<p>需要说明的是，<code>__class__</code> 表示的是元类，而不是父类，父类可以通过 3.3.2 节中介绍的 <code>__mro__</code> 属性来查看：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">int.__mro__  <span class="hljs-comment"># (&lt;class 'int'&gt;, &lt;class 'object'&gt;)</span>
</div></li><li><div class="code_line">str.__mro__  <span class="hljs-comment"># (&lt;class 'str'&gt;, &lt;class 'object'&gt;)</span>
</div></li></ul></code></pre>
<p>可见 <code>int</code> 和 <code>str</code> 这些内置类的父类都是 <code>objcet</code>，我们可以认为 <code>object</code> 是所有类的父类，而 <code>type</code> 是所有类的元类，这个规则在这两个类之间也适用，可以验证一下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">object.__class__   <span class="hljs-comment"># &lt;class 'type'&gt;</span>
</div></li><li><div class="code_line">type.__mro__       <span class="hljs-comment"># (&lt;class 'type'&gt;, &lt;class 'object'&gt;)</span>
</div></li></ul></code></pre>
<p>可见 <code>object</code> 是 <code>type</code> 类构建出来的实例，<code>type</code> 是 <code>object</code> 类的元类，而 <code>object</code> 则是 <code>type</code> 类的父类。如下图所示：<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/7cfd0dcc1843eac2a7e4e84afd794533.png" alt=""></p>
<p>这里介绍元类和父类并非是为了烧脑，除了描述最基本的概念以外，我们应该意识到，类是由元类的 <code>__init__</code> 方法构造出来的实例，如果我们继承元类并且重写 <code>__init__</code> 方法，就可以控制类的初始化方法。</p>
<h4 id="section343">3.4.3 元类的使用示例</h4>
<p>在介绍属性描述符时，我们用计数器来实现 <code>storage_name</code> 的自动生成，从而避免冗余的代码，但代码的可读性会下降，因为属性的名称无法获得，只能用递增的数字来区别。利用元类，我们可以在不影响可读性的前提下，实现存储名称的自动生成：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quantity</span>:</span>
</div></li><li><div class="code_line">    __counter = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        cls = self.__class__
</div></li><li><div class="code_line">        self.storage = <span class="hljs-string">'_{}#{}'</span>.format(cls.__name__, cls.__counter)
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[self.storage]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            instance.__dict__[self.storage] = value
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># Quantity 类是可以自动生成 storage 名称的描述符类，和之前的逻辑基本类似，可以不用关注</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 继承自 type 类，是一个自定义的元类    </span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuantityMeta</span><span class="hljs-params">(type)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, bases, attr_dict)</span>:</span> 
</div></li><li><div class="code_line">        <span class="hljs-comment"># name 表示类名，bases 是继承关系，attr_dict 则是属性列表，和 type 方法的参数含义一致</span>
</div></li><li><div class="code_line">        super().__init__(name, bases, attr_dict)
</div></li><li><div class="code_line">        <span class="hljs-keyword">for</span> key, attr <span class="hljs-keyword">in</span> attr_dict.items():
</div></li><li><div class="code_line">            <span class="hljs-comment"># 注意，类有很多属性，但只有描述符类型的属性才需要修改</span>
</div></li><li><div class="code_line">            <span class="hljs-keyword">if</span> isinstance(attr, Quantity):
</div></li><li><div class="code_line">                type_name = type(attr).__name__
</div></li><li><div class="code_line">                <span class="hljs-comment"># 这里的 key 就是原来的属性名，比如 price、number</span>
</div></li><li><div class="code_line">                attr.storage = <span class="hljs-string">'_{}#{}'</span>.format(type_name, key)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 为了避免让用户知道太多元类的细节，我们创建一个基类 Entity，并把它的元类设置为 QuantityMeta</span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entity</span><span class="hljs-params">(metaclass=QuantityMeta)</span>:</span> <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 现在用户的类只要继承自 Entity 就可以了</span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span><span class="hljs-params">(Entity)</span>:</span>
</div></li><li><div class="code_line">    price = Quantity()
</div></li><li><div class="code_line">    number = Quantity()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = Item()
</div></li><li><div class="code_line">i.price = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">print(i.__dict__)  <span class="hljs-comment"># 得到 {'_Quantity#price': 1}，可读性良好</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#i.price = -1      # 抛出异常</span>
</div></li></ul></code></pre>
<p>虽然代码比较长，但其实核心很简单，在元类的 <code>__init__</code> 方法中，我们可以获取将要生成的类的名称、父类和属性，就像在类工厂函数中传给 <code>type</code> 类的那些参数一样。有了这些信息，我们可以把当初用计数器生成的临时存储名称给改正为可读性更高的名称。</p>
<h2 id="section4">4. 流程控制</h2>
<h3 id="section41else">4.1 else</h3>
<p>除了最常见的 <code>if ... else ...</code> 语句外，还有很多地方都会用到 <code>else</code>，它的用法各不相同，但如果灵活使用，会使代码更简洁， 更具可读性。</p>
<h4 id="section411forelse">4.1.1 for else</h4>
<p>for 语句的末尾可以加上 else，仅当 for 循环没有因为 break 而终止，顺利运行完以后才运行。这个用法看起来怪怪的，毕竟其他 for 循环后面的代码，也会正常执行。所以这个规则应该反过来理解：<strong>如果 for 循环因为 break 而终止，else 代码块就不会执行</strong>。</p>
<p>有过一些编程经验的读者应该经常会写出这样的代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">found = <span class="hljs-keyword">False</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> some_judge(i):  <span class="hljs-comment"># 只要找到一个满足条件的，就把 found 置为 True</span>
</div></li><li><div class="code_line">        found = <span class="hljs-keyword">True</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">break</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> found:          <span class="hljs-comment"># 如果全都不符合条件，执行某个逻辑</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Nothing found'</span>)
</div></li></ul></code></pre>
<p>如果用 <code>else</code> 语句，代码就会简化：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> some_judge(i):
</div></li><li><div class="code_line">        <span class="hljs-keyword">break</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Nothing found'</span>)
</div></li></ul></code></pre>
<p>如果 <code>if</code> 判断成立了，就会进入 <code>break</code>，于是 <code>else</code> 的代码就不会执行，否则就会输出 Nothing found。和上面的例子相比，使用 <code>else</code> 的代码更简洁，而且不需要再用一个变量来标记了。</p>
<h4 id="section412whileelse">4.1.2 while else</h4>
<p>仅当 <code>while</code> 循环因为判断条件不成立而退出，而不是因为 <code>break</code> 才退出时，才会执行 <code>else</code> 代码块，用法和 <code>for ... else ...</code> 基本一致。</p>
<h4 id="section413tryelse">4.1.3 try else</h4>
<p>仅当 <code>try</code> 代码块中没有抛出异常时才会执行 <code>else</code>。为了理解 <code>try ... else</code> 的使用场景，我们先看一个常见的场景。</p>
<p>一个很常见的错误是为了处理异常，把一大段代码都放在 <code>try</code> 语句中：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">try</span>:
</div></li><li><div class="code_line">    <span class="hljs-comment"># 写了几十行毫无问题的代码</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    some_dangarous_operation()
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 下面跟了几十行毫无问题的代码</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
</div></li><li><div class="code_line">    <span class="hljs-comment"># 处理异常</span>
</div></li></ul></code></pre>
<p>这种写法非常不负责任，<code>try</code> 不是防止崩溃的银弹，而是应该用在真正可能导致异常的函数上，所以要保证 <code>try</code> 的代码块尽可能简单，突出要尝试执行的代码。以这段代码为例，<code>some_dangarous_operation</code> 函数之前的代码可以放在 <code>try</code> 代码块上面写，但如果 <code>some_dangarous_operation</code> 函数之后的代码依赖于这个函数的正确执行，就不太好独立出来了。这时候就该 <code>try ... else</code> 发挥作用了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-comment"># some_dangarous_operation 之前的安全代码写在这里</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">try</span>:
</div></li><li><div class="code_line">    some_dangarous_operation()
</div></li><li><div class="code_line"><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
</div></li><li><div class="code_line">    <span class="hljs-comment"># 处理异常</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 依赖于 some_dangarous_operation 的安全代码</span>
</div></li></ul></code></pre>
<h3 id="section42">4.2 迭代器</h3>
<h4 id="section421">4.2.1 迭代器</h4>
<p>迭代器接口定义了两个方法，<code>__next__</code>  方法没有参数，用于返回序列的下一个元素，如果没有元素就抛出 <code>StopIteration</code> 异常，<code>__iter__</code>方法返回自己。</p>
<p>根据鸭子类型的定义，一个类不用声明为迭代器，只要它实现了迭代器接口中定义的两个方法，就可以迭代：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyIterator</span>:</span>
</div></li><li><div class="code_line">    index = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> self.index &gt; <span class="hljs-number">2</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span>  StopIteration
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            self.index += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> self.index
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = MyIterator()
</div></li><li><div class="code_line">next(i) <span class="hljs-comment"># 得到 1，i 的 index 为 1</span>
</div></li><li><div class="code_line">next(i) <span class="hljs-comment"># 得到 1，i 的 index 为 2</span>
</div></li><li><div class="code_line">next(i) <span class="hljs-comment"># 得到 1，i 的 index 为 3</span>
</div></li><li><div class="code_line">next(i) <span class="hljs-comment"># 根据 if 判断的条件，抛出 StopIteration 异常，迭代结束</span>
</div></li></ul></code></pre>
<p><code>next</code> 函数的参数是迭代器，用于获取迭代器中的下一个元素。</p>
<h4 id="section422">4.2.2 可迭代对象</h4>
<p>用 <code>next</code> 函数去迭代一个迭代器对象，不仅语法繁琐，每次还要用 <code>try catch</code> 来处理随时都有可能发生的 <code>StopIteration</code> 异常，这种写法实在是太啰嗦了。所以我们平时都用 <code>for in</code> 语法来遍历字符串、数组等可迭代对象：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">'bestswifter'</span>:
</div></li><li><div class="code_line">    print(c)
</div></li></ul></code></pre>
<p>这种写法其实是对迭代器的封装：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">it = iter(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line"><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">    <span class="hljs-keyword">try</span>:
</div></li><li><div class="code_line">        print(next(it))
</div></li><li><div class="code_line">    <span class="hljs-keyword">except</span> StopIteration:
</div></li><li><div class="code_line">        <span class="hljs-keyword">del</span> it
</div></li><li><div class="code_line">        <span class="hljs-keyword">break</span>
</div></li></ul></code></pre>
<p>可见 <code>for in</code> 语法省略了大量的模板代码。可以看到这里的字符串是可迭代对象，在用 <code>for in</code> 遍历时，其实是通过 <code>iter</code> 函数获取了可迭代对象的迭代器，然后用 <code>next</code> 函数去遍历这个迭代器，这揭示了迭代器和可迭代对象之间重要的关系：<strong>Python 用 iter 函数从可迭代对象中获取迭代器</strong>。</p>
<h4 id="section423__iter__">4.2.3 \__iter__ 方法</h4>
<p>能够用 <code>for in</code> 语法遍历的对象必须是可迭代的，除了内置的数组、元组等类型外，自定义的类型也有办法变成可迭代的，因为 <code>iter</code> 函数最终会调用对象的  <code>__iter</code> 方法。我们只要能实现这个方法，返回适当的迭代器，就可以让对象变成可迭代的，并支持 <code>for in</code> 语法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> iter([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> Foo():
</div></li><li><div class="code_line">    print(i) <span class="hljs-comment"># 共三行输出，分别是 1、2 和 3</span>
</div></li></ul></code></pre>
<p>没实现 <code>__iter__</code> 方法，但是实现了 <code>__getitem__</code> 方法的对象也是可迭代的，这个函数在 1.1.5 节中已经介绍过，用来处理下标访问。Python 会创建一个迭代器，并且用从 0 开始的整数调用 <code>__getitem__</code> 方法作为迭代器的 <code>next</code> 值。如果实现了 <code>__len__</code> 是最好，Python 解释器只会调用指定次数的 <code>__getitem__</code>，否则会在越界时自动停止。</p>
<p>再次总结下，可迭代对象和迭代器是两个概念，写在 <code>for in</code> 中的是可迭代对象，它需要实现 <code>__iter__</code> 方法为 <code>iter</code> 方法提供一个迭代器。迭代器需要满足迭代器接口， 也就是两个函数。无参数的 <code>__next__</code> 方法提供下一个元素或者抛出异常，<code>__iter__</code> 函数返回自己。从这个角度看，迭代器都是可迭代对象。</p>
<h4 id="section424">4.2.4 标准迭代器</h4>
<p>有了上述知识作为铺垫，我们来尝试实现一个定义的可迭代对象。它只需要实现一个 <code>__iter__</code> 方法，返回迭代器即可，一个常见的写法如下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span>:</span>
</div></li><li><div class="code_line">    count = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    _private_data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> self.count &lt; len(self._private_data):
</div></li><li><div class="code_line">            temp = self._private_data[self.count]
</div></li><li><div class="code_line">            self.count += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> temp
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> StopIteration
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">c = MyCollection()
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c:
</div></li><li><div class="code_line">    print(i) <span class="hljs-comment"># 输出三行，分别是 1，2 和 3</span>
</div></li></ul></code></pre>
<p>这段代码中，<code>__iter__</code> 函数返回了自己，并且自己实现了迭代器的接口，一切运行正常。</p>
<p>并且这段代码向我们展示了迭代器的第一个特点：<strong>屏蔽内部的存取细节， 对外提供统一的访问逻辑。</strong></p>
<p>很可惜的是，这段代码是<strong>标标准准的错误写法</strong>，因为可迭代对象的迭代器一定不能是自己，或者说可迭代对象一定不能实现 <code>__next__</code> 方法，理由很简单，看一眼 4.2.1 节中的迭代器，它是一次性的，遍历完以后就回不去了。这里也是同理，如果我们再执行一次 <code>for in</code>，就得不到输出了。换个角度思考，上一节的结论告诉我们，同时实现了 <code>__iter__</code> 和 <code>__iter__</code> 方法的是迭代器，而迭代器是不能用于 <code>for in</code> 语句的。</p>
<p>正确的写法如下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span>:</span>
</div></li><li><div class="code_line">    _private_data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> MyCollectionIterator(self._private_data)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollectionIterator</span>:</span>
</div></li><li><div class="code_line">    count = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, data)</span>:</span>
</div></li><li><div class="code_line">        self.data = data
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> self.count &lt; len(self.data):
</div></li><li><div class="code_line">            temp = self.data[self.count]
</div></li><li><div class="code_line">            self.count += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> temp
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> StopIteration
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> MyCollection():
</div></li><li><div class="code_line">    print(i)
</div></li></ul></code></pre>
<p>代码很长，但思路很简单，就是遵守迭代器和可迭代对象的定义，把一次性的迭代工作交给可以重复创建实例的  <code>MyCollectionIterator</code> 类完成。</p>
<p>这也正是迭代器模式的另一个特点，<strong>对象能够正确保存多次迭代的进度，支持多次迭代。</strong></p>
<h4 id="section425">4.2.5 初识生成器</h4>
<p>稍有追求的程序员都难以容忍这么多模板代码（两个 <code>__iter__</code>， 一个 <code>__next__</code>），好在 Python 的生成器可以简化上述代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCollection</span>:</span>
</div></li><li><div class="code_line">    _private_data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self._private_data:
</div></li><li><div class="code_line">            <span class="hljs-keyword">yield</span> i
</div></li></ul></code></pre>
<p>从直观上看，这里用 <code>yield</code> 关键字替换了 <code>return</code>，打破了 “可迭代对象不能实现 <code>__next__</code> ” 的规定，但却能够支持多次遍历，这段代码的工作原理会在介绍完生成器以后解释。</p>
<h3 id="section43">4.3 生成器</h3>
<h4 id="section431">4.3.1 生成器的定义</h4>
<p>先给出生成器的定义：</p>
<ol>
<li>只要函数体重有 <code>yield</code> 关键字，这个函数就是生成器函数</li>
<li>调用生成器函数，会得到<strong>生成器</strong>，生成器函数可以理解为生成器的工厂</li>
<li>调用 <code>next</code> 函数会激发生成器的下一个值</li>
</ol>
<p>举个例子:</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Start'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Continue'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">g = gen()       <span class="hljs-comment"># 注意，这里没有输出！！！</span>
</div></li><li><div class="code_line">print(next(g))  <span class="hljs-comment"># 输出两行，start 和 1</span>
</div></li><li><div class="code_line">print(next(g))  <span class="hljs-comment"># 输出两行，Continue 和 2</span>
</div></li><li><div class="code_line">print(next(g))  <span class="hljs-comment"># 输出 2</span>
</div></li><li><div class="code_line">print(next(g))  <span class="hljs-comment"># 抛出异常 StopIteration</span>
</div></li></ul></code></pre>
<p>从输出内容中可以看出，调用生成器函数会返回一个生成器对象，但生成器函数中的代码不会执行。在调用 <code>next(g)</code> 函数时才会执行生成器函数的代码，阻塞在 <code>yield x</code> 这一行，并且<code>next(g)</code> 函数的返回值就是 <code>x</code>。第几次调用 <code>next</code> 函数，就会阻塞在第几个 <code>yield</code> 处。如果是第一次接触生成器，这个逻辑需要反复体会几次。</p>
<p>生成器的使用方式和迭代器一致，我们可以认为生成器都是迭代器，都实现了迭代器接口。因此 4.2.5 节中的代码就很容易解释了。当外部调用 <code>iter()</code> 函数时，实际上 <code>__iter__</code> 方法中的代码并没有被立刻执行，而是返回了一个生成器。</p>
<h4 id="section432">4.3.2 生成器表达式</h4>
<p>我们在文章开头的 1.1.1 节中介绍了数组推导，生成器表达式可以理解为惰性版的数组推导：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">[x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> array] <span class="hljs-comment"># 数组推导</span>
</div></li><li><div class="code_line">(x * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> array) <span class="hljs-comment"># 生成器表达式</span>
</div></li></ul></code></pre>
<p>两者的写法非常类似，只是把数组的大括号换成了圆括号，区别在于前者生成了一个新的数组，如果原来的数组占用 M 兆内存，现在两个数组就会占用 2 * M 兆内存。而生成器是懒计算的，并不增加内存占用。</p>
<p>生成器表达式对于大容量的数组，或者无尽数组特别适用，比如可以写一个斐波那契数组：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    a = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    b = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">        <span class="hljs-keyword">yield</span> b
</div></li><li><div class="code_line">        a, b = b, a + b
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># fib() 可以被当成无尽队列，我们只取前 10 个元素        </span>
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i, n <span class="hljs-keyword">in</span> enumerate(fib()):
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span>:
</div></li><li><div class="code_line">        print(n)
</div></li></ul></code></pre>
<h4 id="section433">4.3.3 协程</h4>
<p>上一节中介绍的生成器有两个小缺点：</p>
<ol>
<li>这段代码无法正常退出，因为 <code>fib</code> 函数是个死循环，最终会停在第 11 个 yield 上，等待外部的 <code>next</code> 函数。</li>
<li>现在的数据传递都是单向的，只有生成器给调用方传值，调用方无法给生成器传值。</li>
</ol>
<p>实际上，生成器函数都是协程，我们可以利用协程的特性解决这两个问题：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">fibs = fib()
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i, n <span class="hljs-keyword">in</span> enumerate(fibs):
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span>:
</div></li><li><div class="code_line">        print(n)
</div></li><li><div class="code_line">    <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">        fibs.close()
</div></li></ul></code></pre>
<p>只要在遍历完以后调用生成器的 <code>close</code> 方法，就可以结束生成器并正确的退出了。如果需要向生成器中传值，需要调用生成器对象的 <code>send</code> 方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    a = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    b = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    i = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">        i = <span class="hljs-keyword">yield</span> <span class="hljs-string">'第{0}个数是: {1}'</span>.format(i, b)
</div></li><li><div class="code_line">        a, b = b, a + b
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">fibs = fib()
</div></li><li><div class="code_line">next(fibs)
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
</div></li><li><div class="code_line">    print(fibs.send(i))
</div></li></ul></code></pre>
<p>此时，<code>yield</code> 表达式左边的值就是 <code>send</code> 函数中的参数，而 <code>send</code> 函数的返回值则是 <code>yield</code> 关键字右边的结果。</p>
<p>协程的用法并不复杂，但它是异步编程的基础，比如 ES 7 中的 <code>async/await</code> 语法，能将异步回调变成同步的写法，它就是依靠协程实现的。感兴趣的读者可以参考我的这篇文章：<a href="http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/" target="_blank">异步与回调的设计哲学</a>。</p>
<h4 id="section434">4.3.4 预激协程</h4>
<p>在创建生成器时，并不会执行生成器函数中的代码，第一次调用 <code>next(g)</code> 函数时会执行到第一个 <code>yield</code> 处。而协程的 <code>send</code> 函数用来给 <code>yield</code> 左侧的变量赋值。所以在调用 <code>send</code> 函数之前一定要确保已经调用过 <code>next()</code> 函数，这样协程才会停留在 <code>yield</code> 处而不是停留在刚创建的状态。这一步操作叫做协程的预激，上一节的代码中已经演示了这一点。</p>
<p>在使用协程时，一般都需要预激，也就是说 <code>next(g)</code> 其实是一个模板代码，可以被优化掉。要想改变一个函数的运行逻辑，最好的方法是使用装饰器：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> functools
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coroutine</span><span class="hljs-params">(original_coroutine)</span>:</span>       
</div></li><li><div class="code_line"><span class="hljs-meta">    @functools.wraps(original_coroutine)</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activate</span><span class="hljs-params">(*args, **kwargs)</span>:</span>  <span class="hljs-comment"># 用 active 函数替换被装饰的 fib 函数</span>
</div></li><li><div class="code_line">        gen = original_coroutine(*args, **kwargs)  <span class="hljs-comment"># 调用 fib 函数</span>
</div></li><li><div class="code_line">        next(gen)  <span class="hljs-comment"># 预激协程</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> gen   <span class="hljs-comment"># 像 fib 函数一样，返回预激过的协程</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> activate  <span class="hljs-comment"># 被装饰的函数 fib 现在替换为了 active 函数，会自动预激</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-meta">@coroutine</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    a = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    b = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    i = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">        i = <span class="hljs-keyword">yield</span> <span class="hljs-string">'第{0}个数是: {1}'</span>.format(i, b)
</div></li><li><div class="code_line">        a, b = b, a + b
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">fibs = fib()
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
</div></li><li><div class="code_line">    print(fibs.send(i))
</div></li></ul></code></pre>
<p>温故一下装饰器的定义，被 <code>coroutine</code> 装饰的 <code>fib</code> 函数等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">new_fib = coroutine(fib)
</div></li><li><div class="code_line"><span class="hljs-comment"># 根据 coroutine 函数的定义，coroutine(fib) 实际上会返回下面这个函数</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activate</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    gen = fib()
</div></li><li><div class="code_line">    next(gen)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> gen
</div></li></ul></code></pre>
<h4 id="section435">4.3.5 标准库中的生成器函数</h4>
<p><code>itertools</code> 模块提供了很多生成器函数，这些函数处理可迭代的对象，并且返回生成器（节省内存，可迭代）。想要了解生成器函数，唯一可能的知识来源就是这篇<a href="https://docs.python.org/3/library/itertools.html#module-itertools" target="_blank">官方文档</a>，本节会做简单的翻译和解释。它把生成器函数分为三大类。</p>
<p>第一类函数返回的是无限生成器：</p>
<table>
<thead>
<tr>
<th style="text-align:left;">函数名</th>
<th style="text-align:left;">参数</th>
<th style="text-align:left;">返回结果</th>
<th style="text-align:left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.count" target="_blank">count()</a></td>
<td style="text-align:left;">start, [step]</td>
<td style="text-align:left;">start, start+step, start+2*step, …</td>
<td style="text-align:left;"><code>count(10) --&gt; 10 11 12 13 14 ...</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://xiaozhuanlan.com/topic/1053427869" target="_blank">copy()</a></td>
<td style="text-align:left;">p（数组）</td>
<td style="text-align:left;">p0, p1, ...， pn, p0, p1, ...</td>
<td style="text-align:left;"><code>cycle('ABCD') --&gt; A B C D A B C D ...</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.repeat" target="_blank">repeat()</a></td>
<td style="text-align:left;">elem [,n]</td>
<td style="text-align:left;">elem, elem, elem, … 无尽队列或最多 n 次</td>
<td style="text-align:left;"><code>repeat(10, 3) --&gt; 10 10 10</code></td>
</tr>
</tbody>
</table>
<p>这三个函数的注释都说明得清楚了，配合示例应该非常容易理解。</p>
<p>第二类函数返回的是有限生成器，长度和传入的可迭代对象有关，我选择几个比较常用的列出来 ：</p>
<table>
<thead>
<tr>
<th style="text-align:left;">函数名</th>
<th style="text-align:left;">参数</th>
<th style="text-align:left;">返回结果</th>
<th style="text-align:left;">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.accumulate" target="_blank">accumulate()</a></td>
<td style="text-align:left;">p [,func]</td>
<td style="text-align:left;">p0, func(p0, p1), func(p1, p2), func(p2, p3) ...</td>
<td style="text-align:left;"><code>accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.chain" target="_blank">chain()</a></td>
<td style="text-align:left;">p, q, …</td>
<td style="text-align:left;">p0, p1, … plast, q0, q1, …</td>
<td style="text-align:left;"><code>chain('ABC', 'DEF') --&gt; A B C D E F</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.compress" target="_blank">compress()</a></td>
<td style="text-align:left;">data, selectors</td>
<td style="text-align:left;">(d[0] if s[0]), (d[1] if s[1]), …</td>
<td style="text-align:left;"><code>compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.dropwhile" target="_blank">dropwhile()</a></td>
<td style="text-align:left;">pred, seq</td>
<td style="text-align:left;">假设 pred 在第 n 个元素开始不成立：seq[n], seq[n+1]</td>
<td style="text-align:left;"><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1</code></td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.tee" target="_blank">tee()</a></td>
<td style="text-align:left;">it, n</td>
<td style="text-align:left;">产出 n 各元素的数组，每个元素可以看做 it 的备份，相当于把 it 复制了 n 份</td>
<td style="text-align:left;"><code>tee('ABC', 2) --&gt; g1, g2(迭代 g1 和 g2 都会得到 A、B、C)</code></td>
</tr>
</tbody>
</table>
<p>最后一类是可以实现排列组合操作的生成器函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left;">函数名</th>
<th style="text-align:left;">参数</th>
<th style="text-align:left;">返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.product" target="_blank">product()</a></td>
<td style="text-align:left;">p, q, … [repeat=1]</td>
<td style="text-align:left;">生成各个可迭代对象的笛卡尔积，n 表示每个可迭代对象对象重复几次</td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.permutations" target="_blank">permutations()</a></td>
<td style="text-align:left;">p[, r]</td>
<td style="text-align:left;">序列 p 所有长度为 r 的无重复元素排列</td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations" target="_blank">combinations()</a></td>
<td style="text-align:left;">p, [r]</td>
<td style="text-align:left;">序列 p 所有长度为 r 的无重复元素有序排列</td>
</tr>
<tr>
<td style="text-align:left;"><a href="https://docs.python.org/3/library/itertools.html#itertools.combinations_with_replacement" target="_blank">combinations_with_replacement()</a></td>
<td style="text-align:left;">p, [r]</td>
<td style="text-align:left;">序列 p 所有长度为 r 的有重复元素有序排列</td>
</tr>
</tbody>
</table>
<p>举例说明：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> *
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># ABC 和 12 的笛卡尔积，所以共有 6 个元素</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：A1、A2、B1、B2、C1、C2</span>
</div></li><li><div class="code_line">l1 = list(product(<span class="hljs-string">'ABC'</span>, <span class="hljs-string">'12'</span>))
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 相当于 product('AB', 'AB')</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：AA、AB、BA、BB</span>
</div></li><li><div class="code_line">l2 = list(product(<span class="hljs-string">'AB'</span>, repeat=<span class="hljs-number">2</span>))
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># ABCD 所有所有长度为 2 的无重复、无序子排列</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 每个元素可以和除了自己的另外三个元素组合，因此有 4 * 3 个</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：AB、AC、AD、BA、BC、BD、CA、CB、CD、DA、DB、DC</span>
</div></li><li><div class="code_line">l3 = list(permutations(<span class="hljs-string">'ABCD'</span>, <span class="hljs-number">2</span>))
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># ABCD 所有所有长度为 2 的无重复、有序子排列</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># AB 和 BA 会被认为是相同的，所以只有 12 / 2 = 6 个</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># AB、AC、AD、BC、BD、CD</span>
</div></li><li><div class="code_line">l4 = list(combinations(<span class="hljs-string">'ABCD'</span>, <span class="hljs-number">2</span>))
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># ABCD 所有所有长度为 2 的有重复、有序子排列</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># AA、BB 这样的也合法，所以有 6 + 4 = 10 个</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：AA、AB、AC、AD、BB、BC、BD、CC、CD、DD</span>
</div></li><li><div class="code_line">l5 = list(combinations_with_replacement(<span class="hljs-string">'ABCD'</span>, <span class="hljs-number">2</span>))
</div></li></ul></code></pre>
<p>本节仅列出了一部分常用的生成器函数，他们是系统库提供的轮子。因此在自己实现关于序列的操作以前，应该思考下这是否是常见操作，系统是否已经提供了轮子。在<a href="https://docs.python.org/3/library/itertools.html#itertools-recipes" target="_blank">官方文档的最后一节</a> 还有一些基于上述生成器函数的拓展，通过简单的封装了 <code>itertools</code> 模块中的生成器函数，提供了更多常见的函数，比如 <code>take</code>、<code>tail</code>、<code>consume</code>、<code>nth</code>、<code>flatten</code> 等等，<strong>强烈建议阅读一遍并且形成基本印象!</strong></p>
<h3 id="section44">4.4 上下文管理器</h3>
<h4 id="section441with">4.4.1 with 块</h4>
<p><code>with</code> 代码块的一个常见用法是用于打开文件，有经验的 Python 程序员不会建议你写出这样的代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">f = open(file_path)
</div></li><li><div class="code_line">data = f.readlines()
</div></li><li><div class="code_line"><span class="hljs-comment"># 处理 data</span>
</div></li><li><div class="code_line">f.close()
</div></li></ul></code></pre>
<p>用 <code>with</code> 块的写法则是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">with</span> open(file_path) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    data = f.readlines()
</div></li><li><div class="code_line">    <span class="hljs-comment"># 处理 data</span>
</div></li></ul></code></pre>
<p>这样写的好处不仅仅是不用在最后关闭文件。试想一下，如果在处理文件的过程中有多个地方有可能会抛出异常，那么在所有 <code>try catch</code> 语法的最后都要写上 <code>finally</code> 以便关闭文件。如果放到 <code>with</code> 块中写，则不需要在这么多代码。</p>
<h4 id="section442">4.4.2 自定义上下文</h4>
<p><code>with</code> 块的本质是为了简化 <code>try finally</code> 语句，以上一节的代码为例，跟在 <code>with</code> 后面的<code>open()</code> 函数会返回一个对象，它是 <code>TextIOWrapper</code> 类的实例，我们把它称为上下文管理器，上下文管理器需要实现 <code>__enter__</code> 和 <code>__exit__</code> 方法。</p>
<p><code>__enter__</code> 方法的返回值可以用 <code>as</code> 来引用，这里上下文管理器的 <code>__enter__</code> 方法的返回值是 self，所以以下两种写法中的文件句柄 <code>fp</code> 是等价的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">fp = open(file_path)
</div></li><li><div class="code_line"><span class="hljs-keyword">with</span> open(file_path) <span class="hljs-keyword">as</span> fp
</div></li></ul></code></pre>
<p>第一行中的 <code>fp</code> 可以理解为第二行中的上下文管理器，也就是 <code>with</code> 后面表达式的返回值。而 <code>as</code> 后面的 <code>fp</code> 则是上下文管理器的 <code>__enter__</code> 方法的返回值，由于这里返回的是 <code>self</code>，所以两者恰好相同。</p>
<p>无论以哪种方式退出 <code>with</code> 块（正常结束或者因为抛出异常而退出），都会调用上下文管理器的 <code>__exit__</code> 方法。注意，这里不是 <code>__enter__</code> 方法返回值的 <code>__exit__</code> 方法。这一点很好理解，因为前者一定实现了 <code>__enter__</code> 方法，但后者不一定。</p>
<p>了解了上下文的概念后，我们可以自定义一个上下文，其实也就是定义一个实现了 <code>__enter__</code> 和 <code>__exit__</code> 方法的类：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> sys
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reverse</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_write</span><span class="hljs-params">(self, content)</span>:</span>
</div></li><li><div class="code_line">        self.original_write(content[::<span class="hljs-number">-1</span>])
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.original_write = sys.stdout.write
</div></li><li><div class="code_line">        sys.stdout.write = self.reverse_write
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Enter context'</span>[::<span class="hljs-number">-1</span>]  <span class="hljs-comment"># 这个字符串会被倒序打印，所以先倒序一次</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self, exc_type, exc_value, traceback)</span>:</span>
</div></li><li><div class="code_line">        sys.stdout.write = self.original_write
</div></li><li><div class="code_line">        print(exc_type, exc_value, traceback)
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">with</span> Reverse() <span class="hljs-keyword">as</span> r:
</div></li><li><div class="code_line">    print(r)  <span class="hljs-comment"># 因为字符串已经被倒序过，所以这里输出 'Enter context'</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'bestswifter'</span>) <span class="hljs-comment"># 输出 'retfiwstseb'</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">raise</span> AttributeError <span class="hljs-comment"># 输出 &lt;class 'AttributeError'&gt;  &lt;traceback object at 0x10bcb45c8&gt;</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'will not be print'</span>)  <span class="hljs-comment"># 因为发生了异常，所以不会执行这一行</span>
</div></li></ul></code></pre>
<p>在进入上下文的时候，我们用自定义的方法替换了系统的标准输出，所以上下文中所有的输出都是倒序的。直到上下文结束时才换回来。</p>
<p><code>__exit__</code> 方法有三个参数，分别表示异常的类型，异常的实例，以及发生异常处的调用栈。如果在 <code>with</code> 块中发生了异常，异常处后面的代码都不会执行。<code>__exit__</code> 方法如果返回 True，表示异常已经被正确处理，否则异常会向上冒泡到 <code>with</code> 代码块外面。</p>
<h4 id="section443">4.4.3 标准库中的上下文</h4>
<p>使用标准库中的装饰器可以节省一些模板代码，<code>__enter__</code> 和 <code>__exit__</code> 方法可以写在一起，以 <code>yield</code> 为分界线：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@contextlib.contextmanager</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Reverse</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_write</span><span class="hljs-params">(content)</span>:</span>
</div></li><li><div class="code_line">        original_write(content[::<span class="hljs-number">-1</span>])
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    original_write = sys.stdout.write
</div></li><li><div class="code_line">    sys.stdout.write = reverse_write
</div></li><li><div class="code_line">    <span class="hljs-keyword">yield</span> <span class="hljs-string">'Enter context'</span>[::<span class="hljs-number">-1</span>] <span class="hljs-comment"># 下一行开始，是 __exit__ 的逻辑</span>
</div></li><li><div class="code_line">    sys.stdout.write = original_write
</div></li></ul></code></pre>
<p><code>@contextlib.contextmanager</code> 的缺点是无法通过 <code>return True/False</code> 来控制是否需要冒泡异常，必须把 <code>yield</code> 代码放到 <code>try catch</code> 中。</p>
<h2 id="section5python">5. 其他 Python 特色</h2>
<h3 id="section51gil">5.1 多线程与GIL</h3>
<h4 id="section511">5.1.1 多线程</h4>
<p>多线程操作一般通过 <code>threading</code> 模块来完成，启动一个线程其实就是把线程要执行的函数传递到 <code>Thread</code> 类的初始化方法中，然后调用 <code>Thread</code> 实例的 <code>start</code> 方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> threading
</div></li><li><div class="code_line"><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">think</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'start thinking in thread: '</span> + threading.current_thread().name)
</div></li><li><div class="code_line">    sleep(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">    print(<span class="hljs-string">'end thinking'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):
</div></li><li><div class="code_line">    t = threading.Thread(target = think)
</div></li><li><div class="code_line">    t.start()
</div></li><li><div class="code_line">print(<span class="hljs-string">'Exit'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-1</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-2</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-3</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># Exit</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li></ul></code></pre>
<p>从输出结果来看，Python 的线程都是异步执行，如果要同步执行某个线程，需要调用线程的 <code>join</code> 方法，表示阻塞当前线程，直到整个线程退出为止：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):
</div></li><li><div class="code_line">    t = threading.Thread(target = think)
</div></li><li><div class="code_line">    t.start()
</div></li><li><div class="code_line">    t.join()
</div></li><li><div class="code_line">print(<span class="hljs-string">'Exit'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-1</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-2</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># start thinking in thread: Thread-3</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># end thinking</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># Exit</span>
</div></li></ul></code></pre>
<h4 id="section512">5.1.2 线程锁</h4>
<p>像 <code>a += 1</code> 这样的语句，是线程不安全的，因为它不是原子性操作。如果想保证某段代码最多同时被一个线程执行，可以给它加锁：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">i = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">lock = threading.Lock()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">think</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">global</span> i
</div></li><li><div class="code_line">    lock.acquire()
</div></li><li><div class="code_line">    i += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    lock.release()
</div></li></ul></code></pre>
<p>注意到这里的加锁和释放锁又是上下对应的模板代码，这类代码都可以用 <code>with</code> 块配合上下文解决。Python 提供了现成的写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">lock = threading.Lock()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">think</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">global</span> i
</div></li><li><div class="code_line">    <span class="hljs-keyword">with</span> lock:
</div></li><li><div class="code_line">        i += <span class="hljs-number">1</span>
</div></li></ul></code></pre>
<p>在 <code>threading.Lock</code> 类的 <code>__exit__</code> 方法中会自动释放锁。</p>
<h4 id="section513gil">5.1.3 GIL</h4>
<p>我们知道 Python 这种动态语言是由解释器在运行时动态解释并执行的，如果有多个线程同时执行，就意味着有多个解释器也在运行。为了保证解释器自己的线程安全性，有些  Python 解释器（比如最常见的 CPython）采用了一种很暴力的解决方式：<strong>全局锁</strong>，也就是 Global Interpreter Lock， GIL。再次声明，GIL 不是 Python 的特性，仅仅是特定解释器的特性，比如另一个解释器 JPython 就没有 GIL，不过 CPython 是绝大多数场景下默认的 Python 的解释器，所以有人可能会把 GIL 与 Python 混为一谈。</p>
<p>GIL 最直接的副作用就是严重影响多线程的性能，因为同一时刻只有一个线程能获得锁。GIL 可以用如下伪代码表示：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
</div></li><li><div class="code_line">    acquire GIL
</div></li><li><div class="code_line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):
</div></li><li><div class="code_line">        do_something()
</div></li><li><div class="code_line">    release GIL
</div></li></ul></code></pre>
<p>当某个线程因为睡眠、IO 或超时释放 GIL 后，从代码中可以看到，它距离再次获得 GIL 仅有一条指令。所以在实际运行时，有很大可能是一个线程不断的释放、获取 GIL，而别的线程一直在等待。由于线程上下文切换存在一定的开销，多个 CPU 密集型的线程同时运行，性能反而比在同一个线程内运行要低。</p>
<p>如果是多个 IO 密集型的线程同时运行，GIL 不会影响性能，因为线程在执行 IO 操作时会主动释放 GIL 锁，因此会出现没有线程获取 GIL 锁（因为大家都在 IO），谁结束了 IO 谁就使用线程的情况。不过需要注意的是，多个 IO 密集型的线程和一个 CPU 密集型线程同时执行时，性能也会受到影响。因为之前解释过，CPU 密集型的线程倾向于一直占有 GIL，导致 IO 密集型线程在 IO 结束后无法立刻获取 GIL，空等一段时间。</p>
<p>具体的测试结果可以参考：<a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank">Python的GIL是什么鬼，多线程性能究竟如何</a>。</p>
<p>如果想要避免 GIL 对性能的影响，有以下几种思路：</p>
<ol>
<li>多个 IO 密集型线程不受影响，但不要混入 CPU 密集型线程</li>
<li>使用 JPython 这样的解释器代替 CPython，但这样做就无法再使用社区已有的 C 语言模块</li>
<li>使用多进程，多个进程有多个 GIL，自然就互不干扰</li>
</ol>
<h4 id="section514">5.1.4 多进程</h4>
<p>Python 中实现多进程非常简单，因为接口与多线程基本一致：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> multiprocessing
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> os
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_proc</span><span class="hljs-params">(i)</span>:</span>
</div></li><li><div class="code_line">    print(i)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
</div></li><li><div class="code_line">    p = multiprocessing.Process(target=run_proc, args=(i,))
</div></li><li><div class="code_line">    p.start()
</div></li><li><div class="code_line">print(<span class="hljs-string">'End'</span>)
</div></li></ul></code></pre>
<p>多进程中没有锁的概念，因为不同的线程可以共享进程的堆，而不同的进程就没有应用层面可以共享的内容了，只能依赖于操作系统提供的 API，比如共享内存、socket、管道、消息队列等。</p>
<p>以消息队列为例，简单展示下进程间共享数据：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> os
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_proc</span><span class="hljs-params">(q)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
</div></li><li><div class="code_line">        i = q.get()
</div></li><li><div class="code_line">        i += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">        q.put(i)
</div></li><li><div class="code_line">        print(i)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">q = Queue()
</div></li><li><div class="code_line">q.put(<span class="hljs-number">0</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p1 = Process(target=run_proc, args=(q,))
</div></li><li><div class="code_line">p1.start()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p2 = Process(target=run_proc, args=(q,))
</div></li><li><div class="code_line">p2.start()
</div></li></ul></code></pre>
<p>每个进程都会从消息队列中读取变量，加一后放回队列，所以输出结果是 1 到 20。如果不用消息队列来共享，每个进程的变量 <code>i</code> 都是独立的，会输出两次 1 到 10。</p>
<h3 id="section52python">5.2 我眼中的  Python</h3>
<h4 id="section521python">5.2.1 Python 是动态强类型语言</h4>
<p>这句话其实说了两个概念： <strong>Python 是动态类型语言</strong>，以及 <strong>Python 是强类型语言</strong>，很多人会把这两组概念混淆。</p>
<p>首先，动/静态类型语言的区别在于类型被确认的时机。以 C 这类语言来说，编译器会检查变量的类型，比如 <code>int a = "hello";</code> 就无法通过编译，这就说明 C 语言是静态类型语言。而对于 Python 来说，<code>a = "hello"</code> 直到运行时，才会确定 a 引用的对象的类型是 <code>str</code>。</p>
<p>动态类型语言并非看上去没有类型标记那么简单，一方面，Swift 这样的语言支持类型推导，所以支持 <code>var s = "hello"</code> 这种写法，但这并不意味着 Swift 就是动态类型语言了，因为它的类型判断还是在编译期完成的，只不过编译器更加智能，可以推导出来而已。</p>
<p>另一方面，不在编译期检查类型并不意味着动态类型语言对类型的校验就是宽松的，这是另一个维度的衡量指标。如果语言对类型的校验很宽松，支持隐式转换，我们就称这种语言是 <strong>“弱类型语言”</strong>，否则就是<strong>强类型语言</strong>。强类型语言更严格，一定程度上语法会更啰嗦，弱类型语言代码更简单，更脚本化。以输出 <strong>"My age is 22"</strong> 为例：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">number = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">string = <span class="hljs-string">'My age is '</span>
</div></li><li><div class="code_line">print(string + str(number))
</div></li></ul></code></pre>
<p>这里必须把数字先转为字符串，才能和别的字符串拼接，这是因为 <code>str</code> 类的 <code>__add__</code> 函数只支持 <code>str</code> 类型的参数。可以看到，虽然数字（或者其他实现了 <code>__str__</code> 方法的自定义类）可以转为字符串，但这种转换必须是显式写明的，Python 并不支持隐式转换。</p>
<p>但用别的语言，比如 JavaScript 来实现类似的逻辑就非常简单了：</p>
<pre><code class="javascript language-javascript hljs"><ul><li><div class="code_line">number = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">string = <span class="hljs-string">'My age is '</span>
</div></li><li><div class="code_line"><span class="hljs-built_in">console</span>.log(string + number);
</div></li></ul></code></pre>
<p>可见，JavaScript 支持从数字到字符串的隐式转换。但这种隐式的转换也不一定是好事，比如再举一个例子：</p>
<pre><code class="javascript language-javascript hljs"><ul><li><div class="code_line">number = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">string = <span class="hljs-string">'2'</span>
</div></li><li><div class="code_line"><span class="hljs-built_in">console</span>.log(string + number)
</div></li></ul></code></pre>
<p>它的输出结果是 '222'，可见是把数字隐式的转成了字符串，然而如果我的本意是要把字符串转数字呢，比如这段代码在 PHP 中的输出就是 24：</p>
<pre><code class="PHP language-PHP hljs"><ul><li><div class="code_line"><span class="hljs-meta">&lt;?php</span>
</div></li><li><div class="code_line">    $n = <span class="hljs-number">22</span>;
</div></li><li><div class="code_line">    $s = <span class="hljs-string">"2"</span>;
</div></li><li><div class="code_line">    <span class="hljs-keyword">print</span> $s + $n
</div></li><li><div class="code_line"><span class="hljs-meta">?&gt;</span>
</div></li></ul></code></pre>
<p>因此，关于语言的强/弱类型，我想可以总结两点：</p>
<ol>
<li>类型的强弱是一个相对的概念，不像动态/静态类型那样有明确的判断标准。因为隐式转换可以发生在很多地方，有的语言支持的隐式转换场景很多，有的支持的场景很少，所以一般来说我们只能说某个语言的类型比较强（弱）或者说某个语言的类型比另一个语言更强（弱）。</li>
<li>强弱类型没有优劣之分，强类型语言更严谨，不容易出现 Bug，但是代码复杂，书写成本高。弱类型语言更脚本化，写起来很简单，但很多规则并不那么显然，增加了学习成本。</li>
</ol>
<h4 id="section522">5.2.2 开发效率高</h4>
<p>Python 中到处都是<strong>鸭子类型</strong>的实践：不关注一个类的类型本身，而是关注这个类具有什么能力。比如我们会发现，数组和字符串的下标访问高度类似，这在很多静态类型语言中是几乎不可能发生的。很多自定义类因为使用了多继承、迭代器、双下方法，使用起来与内置的数据类型基本上没有区别。</p>
<p>此外，脚本语言的一个主要特色就是 handy，理论上来说 Python 能做的事，没什么是 C 做不到的。然而我们希望用简单的 API，用文本编辑器花上一两分钟就写出来一个脚本，而不是查阅手册，打开 IDE，编译以后再执行。所以 Python 提供了很多语言层面的支持，比如推导、else 块、切片和功能强大的内置函数等。</p>
<p>另外，Python 具备强大的元编程能力，装饰器、高阶函数、函数内省、元类具有非常强的内省和动态能力。内省帮助我们在运行时获取足够多的信息，动态性帮助我们实现很多很有意思的能力。因此我们看到 Python 中很少有模板代码，虽然内部实现有时候相对晦涩难懂，但对外的接口则是高度统一。</p>
<h4 id="section523">5.2.3 对新人不是很友好</h4>
<p>开发效率高的背后也有隐患，简洁高效的语法可能意味着过度封装，因此 Python 的性能经常遭到抨击（但是脚本语言并不应该考虑这一点）。</p>
<p>鸭子类型容易带来太多的魔术方法。在 Java 中，一切都有迹可循，某个类能调用方法，一定是因为它自己实现了方法，或者从接口、父类那里继承来了。而 Python 不一样，方法的调用和方法的真正实现之间也许没有语言层面的直接关联，而是依靠文档规范、魔术方法或者约定。这给新手阅读 Python 代码带来了极大的困难，通常无从下手，连搜索什么关键字都不知道，这也是本文写作的目的之一。</p>
<p>元编程能力允许用户直接享受到大牛们封装好的库和能力，但也容易被滥用。元编程学习门槛高，而且通常实现一个需求有不止一种方法。如果大家各自造轮子，很可能质量参差不齐，互相理解起来也比较困难。</p>
<h3 id="section53python">5.3 其它 Python 技巧</h3>
<p>很多时候我们从网上摘抄下来的代码仅仅刚好能工作，但对它的细节却不是很了解。本节主要列出一些常用的 Python 代码或者技巧并用实际的例子解释各处细节，持续更新中。</p>
<h4 id="section531">5.3.1 文件读写</h4>
<p>读取文件时，一般会这样写代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'path_to_file'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
</div></li><li><div class="code_line">        print(line)
</div></li><li><div class="code_line"><span class="hljs-comment"># first line</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># second line</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># third line</span>
</div></li></ul></code></pre>
<p><code>open</code> 函数的第二个参数表示打开模式，<code>r</code> 表示读取，<code>w</code> 表示写入，会删除原来的所有内容，<code>a</code> 表示在文件后面追加写入。</p>
<p>一般来说不要用 <code>readlines</code> 读取文件，因为如果文件特别大， 读出来的数组可能会非常占用内存。我们会看到输出结果一般都有多个空行，这是因为每行的结尾都有 '\n' 换行符，而且 <code>print</code> 函数自己就会换行。如果想要更美观的输出，可以用 <code>replace</code> 或者 <code>rstrip</code> 函数干掉换行符。</p>
<p>如果我们用 <code>open('path_to_file'. 'rb')</code> 来打开文件，就可以读取到原来的二进制：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'file_to_path'</span>, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:
</div></li><li><div class="code_line">        print(line)
</div></li><li><div class="code_line"><span class="hljs-comment"># b'first line\n'</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># b'second line\n'</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># b'third line\n'</span>
</div></li></ul></code></pre>
<p>这里我们本来应该看到的是各个字母的 UTF-8 编码后的二进制，不过在打印的时候被系统自动转成字母了。在文件不是UTF-8 编码时，一定要用二进制格式去打开文件并且自行解码，否则 Python 会尝试用 UTF-8 去解码，极有可能会因为无法解码而导致报错。</p>
<p>我们可以试着把二进制写入到文件中：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello world'</span>
</div></li><li><div class="code_line">b = [x.encode(<span class="hljs-string">'utf16'</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> s]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'path_to_file'</span>, <span class="hljs-string">'wb'</span>) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    f.writelines(b)
</div></li></ul></code></pre>
<p><code>writelines</code> 函数的参数是数组，相当于对数组中的每个元素调用了 <code>write()</code> 方法。</p>
<p>感兴趣的读者可以试着分别用 <code>r</code> 和 <code>rb</code> 去打开文件，感受其中的区别。</p>
<h4 id="section532json">5.3.2 JSON 读写</h4>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = {<span class="hljs-string">'name'</span>: <span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">22</span>}
</div></li><li><div class="code_line">json.dumps(d)  <span class="hljs-comment"># 返回字符串：{"name": "bestswifter", "age": 22}</span>
</div></li></ul></code></pre>
<p>最简单的对象转 JSON 通过 <code>json</code> 模块的 <code>dumps</code> 函数来完成，最后一个字母 s 表示生成字符串，也可以用 <code>dump(data, fp)</code> 来把内容写入文件：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = {<span class="hljs-string">'name'</span>: <span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">22</span>}
</div></li><li><div class="code_line"><span class="hljs-keyword">with</span> opne(<span class="hljs-string">'path_to_file'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:
</div></li><li><div class="code_line">    json.dump(d, f)
</div></li></ul></code></pre>
<p>调用 <code>dumps</code> 参数时，有几个命令可能会派上作用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = {<span class="hljs-string">'name'</span>: <span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'age'</span>: <span class="hljs-number">22</span>}
</div></li><li><div class="code_line">json.dumps(d, skipkeys=<span class="hljs-keyword">True</span>, sort_keys=<span class="hljs-keyword">True</span>, indent=<span class="hljs-number">4</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment">#{</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "age": 22,</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "name": "bestswifter"</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#}</span>
</div></li></ul></code></pre>
<p>其中，<code>sort_keys</code> 表示对字典的键排序，这样输出结果一定是固定的，<code>indent</code> 用于控制多少个空格缩进，可以增加可读性。<code>skipkeys</code> 表示如果字典的键不是字符串，就忽略这一条记录。</p>
<p>JSON 支持的类型很有限，只有 <code>None</code> ， <code>bool</code> ， <code>int</code> ， <code>float</code> 和 <code>str</code> 这五种基本类型和包含这些类型的字典或者数组。自定义的对象如果转成 JSON 默认会报错，我们可以实现一个通用函数，读取任意对象的 <code>__dict__</code>，这样就可以用于 JSON 化了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize_instance</span><span class="hljs-params">(obj)</span>:</span>
</div></li><li><div class="code_line">    d = { <span class="hljs-string">'class'</span> : type(obj).__name__ }
</div></li><li><div class="code_line">    d.update(vars(obj))
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> d
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">        self.age = age
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-number">22</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 直接 dumps(bs) 会得到这个报错：</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># TypeError: Object of type 'Person' is not JSON serializable</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">json.dumps(serialize_instance(bs), skipkeys=<span class="hljs-keyword">True</span>, sort_keys=<span class="hljs-keyword">True</span>, indent=<span class="hljs-number">4</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment">#{</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "age": 22,</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "class": "Person",</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#    "name": "bestswifter"</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#}</span>
</div></li></ul></code></pre>
<p>或者更优雅的做法是使用 3.3.3 节中介绍的 Mixin：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 注意 Mixin 的原则，功能要单一，实现上不能依赖子类</span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serializable</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">serialize</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        d = { <span class="hljs-string">'class'</span> : type(self).__name__ }
</div></li><li><div class="code_line">        d.update(vars(self))
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> d
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 混入 Serializable 立刻就有了转字典的能力，或者也可以重写</span>
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(Serializable)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">        self.age = age
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-number">22</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">json.dumps(bs.serialize())
</div></li></ul></code></pre>
<p>解析 JSON 字符串的方法也是类似的，调用 <code>json.loads()</code> 函数即可：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">s = <span class="hljs-string">'{"name": "bestswifter", "age": 22}'</span>
</div></li><li><div class="code_line">d = json.loads(s)
</div></li><li><div class="code_line">print(d)
</div></li></ul></code></pre>
<p>这里的 <code>loads</code> 表示从字符串中读取 JSON，也可以用 <code>load</code> 函数从文件中读取。不过有时候我们更希望把读取出来的字典直接转成对象。这需要调用者提供一个函数，把字典转换成对象，一般需要用到元编程。下面是一个简单的示例：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> json
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deserializable</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @classmethod</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(cls, d)</span>:</span>
</div></li><li><div class="code_line">        clsname = d.pop(<span class="hljs-string">'classname'</span>, <span class="hljs-keyword">None</span>)
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> clsname:
</div></li><li><div class="code_line">            obj = cls.__new__(cls)
</div></li><li><div class="code_line">            <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():
</div></li><li><div class="code_line">                setattr(obj, key, value)
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> obj
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> d
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(Deserializable)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name, age)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">        self.age = age
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">s = <span class="hljs-string">'{"age": 22, "name": "bestswifter"}'</span>
</div></li><li><div class="code_line">bs = json.loads(s, object_hook = Person.deserialize)
</div></li><li><div class="code_line">print(bs)
</div></li></ul></code></pre>
<p><code>Person</code> 类通过混入 <code>Deserializable</code> 具备了反序列化的能力，只要把这个函数传入 <code>loads</code> 方法中即可，<code>deserialize</code> 函数的第一个参数是调用类，第二个参数是解析出来的字典。这段代码其实等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = json.loads(s)
</div></li><li><div class="code_line">bs = Person.deserialize(d)
</div></li></ul></code></pre>
<h4 id="section533shell">5.3.3 执行 Shell</h4>
<p>Python 中调用 <code>Shell</code> 命令的方法有很多种，我最常用的是 <code>os.popen</code> 函数，它的返回结果是文件句柄，因此可以调用 <code>readlines</code> 函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> os
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">r = os.popen(<span class="hljs-string">'pwd'</span>)
</div></li><li><div class="code_line">print(r.readlines())
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出 ['/Users/zxy/Desktop\n']</span>
</div></li></ul></code></pre>
<p>这个结果表示 Shell 命令的输出只有一行，且内容是 <code>/Users/zxy/Desktop</code>。</p>
<h3 id="section54python">5.4 Python 模块化</h3>
<h4 id="section541python">5.4.1 Python 中的模块</h4>
<p>Python 不仅可以用来编写短小精悍的脚本文件，也能用来开发大型项目，这就需要把代码合理的写在各个模块中，确保<strong>高内聚、低耦合</strong>。</p>
<p>每一个 Python 文件都是一个模块，我们知道 <code>import</code> 关键字可以导入系统模块，也可以用 <code>import module_name</code> 的写法导入别的模块。</p>
<p>假设文件路径如下：</p>
<pre><code class="hljs ruby"><ul><li><div class="code_line">package
</div></li><li><div class="code_line"><span class="hljs-params">|-- main.py
</span></div></li><li><div class="code_line"><span class="hljs-params">|</span>-- <span class="hljs-class"><span class="hljs-keyword">module</span>.<span class="hljs-title">py</span></span>
</div></li></ul></code></pre>
<p>那么可以这样引用别的模块 </p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-comment"># In module.py</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> a + b
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># In main.py</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> module
</div></li><li><div class="code_line">modul1.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 返回 3</span>
</div></li></ul></code></pre>
<h4 id="section542">5.4.2 模块查找顺序</h4>
<p>对于被 <code>import</code> 的模块，Python 首先会检查它是不是内置的模块，比如我们把刚刚的 <code>module.py</code> 文件重命名为 <code>time.py</code>，再引用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> time
</div></li><li><div class="code_line">time.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># 报错：AttributeError: module 'time' has no attribute 'add'</span>
</div></li></ul></code></pre>
<p>这是因为 Python 最先查找内置的模块，我们打印 time 模块就可以看到 <code>&lt;module 'time' (built-in)&gt;</code> ，说明这是一个内置模块。PS：<code>string</code> 模块不是内置模块，坑了我一晚上。</p>
<p>如果导入的不是内置模块，Python 会依次在 <code>sys.path</code> 这个数组中的每个路径中寻找。按照查找优先级，它由三个部分组成：</p>
<ol>
<li>Python 执行的入口文件（比如这里的 <code>main.py</code>）所在的路径</li>
<li>系统的环境变量 <code>$PYTHONPATH</code> 所表示的目录</li>
<li><code>site</code> 路径，也就是 <code>/usr/local/lib/python3.5/site-packages</code> 这种。</li>
</ol>
<p>如果我们把 <code>time.py</code> 改名为 <code>string.py</code> 就会得到正常结果，这是因为它属于第一部分，而 Python 默认的 <code>string</code> 模块位于第三部分，优先级比较低。</p>
<p>一般来说，Python 工程中的文件都能在第一部分被找到，而 <code>pip</code> 安装的第三方库位于第三部分。环境变量 <code>PYTHONPATH</code> 一般都是空，但不排除某些 IDE，比如 PyCharm 会修改它。这种行为很危险，因为能在 PyCharm 中编译通过很可能是借助环境变量才找到了模块，一旦迁移到别的环境就无法编译，我似乎遇到过这个坑，将本地可以运行的代码上传到 VPS 以后就找不到模块了。</p>
<h4 id="section543__init__py">5.4.3 包与 \__init__.py</h4>
<p>当代码量进一步膨胀时，可能多个模块也无法合理的拆分逻辑了，我们可以把实现某个特定功能的若干个模块组合起来，形成一个包。包在逻辑上可以理解为若干个模块的组合， 在物理上讲，包都是文件夹，模块都是文件。</p>
<p>注意，<strong>文件夹不都是包，只有存在 \__init__.py 文件的文件夹才是模块！</strong></p>
<p>在导入时，我们可以导入类，也可以导入类里面的全局变量或者全局函数，还可以导入包：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> package
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> module
</div></li></ul></code></pre>
<p>如果类名和变量名太长，可以用 as 关键字重命名：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> module.var <span class="hljs-keyword">as</span> v
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> module.func <span class="hljs-keyword">as</span> f
</div></li></ul></code></pre>
<p>一般来说导入包并没有太大的作用，后续还是需要导入包中的模块。如果确实需要直接用到包中的函数或者变量，可以把它定义在 <code>__init__.py</code> 文件中。</p>
<p><code>__init__.py</code> 用于把一个目录标记为包，如果没有这个文件，目录又和 Python 模块重名，就会调用到 Python 的模块，假设文件层级如下：</p>
<pre><code class="hljs sql"><ul><li><div class="code_line">dir
</div></li><li><div class="code_line">|<span class="hljs-comment">-- main.py</span>
</div></li><li><div class="code_line">|<span class="hljs-comment">-- string</span>
</div></li><li><div class="code_line">  |<span class="hljs-comment">-- module1.py</span>
</div></li></ul></code></pre>
<p>我们尝试在 <code>main.py</code> 中导入包：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> string
</div></li><li><div class="code_line">print(string)
</div></li><li><div class="code_line"><span class="hljs-comment"># &lt;module 'string' from '/usr/local/Cellar/python3/3.5.2_3/Frameworks/Python.framework/Versions/3.5/lib/python3.5/string.py'&gt;</span>
</div></li></ul></code></pre>
<p>会发现导入的其实是模块。虽然这里 <code>string</code> 目录如果是一个文件，它的查找优先级会高于 Python 中的非内置模块，但如果当做包来导入，Python 就无法识别了。解决方案也很简单，给 <code>string</code> 目录添加一个 <code>__init__.py</code> 文件，把 <code>string</code> 目录标记为包即可。</p>
<p>除了标记目录为包以外，<code>__init__.py</code> 文件还可以定义一个 <code>__all__</code> 变量，用于批量导入，假设目录层级如下：</p>
<pre><code class="hljs sql"><ul><li><div class="code_line">dir
</div></li><li><div class="code_line">|<span class="hljs-comment">-- main.py</span>
</div></li><li><div class="code_line">|<span class="hljs-comment">-- string</span>
</div></li><li><div class="code_line">  |<span class="hljs-comment">-- module1.py</span>
</div></li><li><div class="code_line">  |<span class="hljs-comment">-- module2.py</span>
</div></li><li><div class="code_line">  |<span class="hljs-comment">-- module3.py</span>
</div></li></ul></code></pre>
<p>先在 <code>__init__</code> 文件中定义要批量导入的模块：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-comment"># In __init__.py</span>
</div></li><li><div class="code_line">__all__ = [<span class="hljs-string">'module1'</span>, <span class="hljs-string">'module2'</span>]
</div></li></ul></code></pre>
<p>然后在 <code>main.py</code> 文件中用星号 <code>*</code> 批量导入：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> string <span class="hljs-keyword">import</span> *
</div></li><li><div class="code_line">print(module1) <span class="hljs-comment"># &lt;module 'string.module1' from '/Users/zxy/Desktop/string/module1.py'&gt;</span>
</div></li><li><div class="code_line">print(module2) <span class="hljs-comment"># &lt;module 'string.module1' from '/Users/zxy/Desktop/string/module1.py'&gt;</span>
</div></li><li><div class="code_line">print(module3) <span class="hljs-comment"># NameError: name 'module3' is not defined</span>
</div></li></ul></code></pre>
<p>在打印 <code>module3</code> 的时候会报错，这是因为 <code>__all__</code> 变量没有暴露它，需要我们手动导入。</p>
<h4 id="section554">5.5.4 相对导入和绝对导入</h4>
<p>接上面的例子，假设我们在 <code>module2</code> 中要引用 <code>module1</code>，代码如下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> string.module1
</div></li></ul></code></pre>
<p>这样写没有问题，因为有 <code>__init__.py</code> 文件把目录标记为包，所以可以正确识别。然而如果我们的入口不是 <code>main.py</code>，而是直接执行 <code>python3 module2.py</code>，就无法识别到父目录里面的 <code>__init__.py</code> 文件了。此时可以采用相对导入：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> module1
</div></li></ul></code></pre>
<p>一个点表示当前的包，两个点就表示上一个包，以此类推……；相对导入只能使用 <code>from import</code> 的语法，而绝对路径导入则不受限制，两种写法皆可。</p>
<p>相对路径的缺点在于容易丢失命名空间，比较这两种写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">from</span> foo <span class="hljs-keyword">import</span> bar
</div></li><li><div class="code_line">bar()     <span class="hljs-comment"># bar 在哪里定义？</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> foo.bar
</div></li><li><div class="code_line">foo.bar() <span class="hljs-comment"># 在 foo 模块中定义</span>
</div></li></ul></code></pre>
<p>前者丢失了 <code>bar</code> 的来源，而后一种写法不会。</p>
<h4 id="section545python">5.4.5 运行 Python 脚本</h4>
<p>每个 Python 脚本既可以直接用 <code>python xxx.py</code> 命令执行，也可以被别的 Python 文件当做模块引入。对于一个项目来说，入口文件只有一个（就像 C 语言的 <code>main.c</code> 文件一样），其他的文件都作为模块对外提供功能。</p>
<p>我们也可以用 <code>python</code> 命令执行一个文件夹，此时会自动运行文件夹中的 <code>__main__.py</code> 文件。 </p>
<p>假设我们写了一个函数，可以爬取给定 URL 的标题：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTitle</span><span class="hljs-params">(url)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># return html.title</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">getTitle(<span class="hljs-string">'https://baidu.com'</span>)
</div></li></ul></code></pre>
<p>直接执行或者在别的模块中导入这个文件都会调用 <code>getTitle</code> 函数，然而我们希望的效果是只有直接执行这个文件时才执行函数，被导入时只要提供方法即可。或者可以通过判断全局变量 <code>__name__</code> 来完成：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getTitle</span><span class="hljs-params">(url)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># return html.title</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
</div></li><li><div class="code_line">    print(getTitle(<span class="hljs-string">'https://baidu.com'</span>))
</div></li></ul></code></pre>
<p>只有当直接运行文件时，全局变量 <code>__name__</code> 的值才是 <code>__main__</code>，因此当这个模块被导入时，<code>if</code> 语句中的代码就不会被调用。</p>
<p><code>python</code> 作为一个 Shell 命令，可以和其他系统命令通过管道联系在一起，比如实现一个 <code>show_file.py</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> sys
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> sys.stdin:
</div></li><li><div class="code_line">    print(file)
</div></li></ul></code></pre>
<p>然后执行命令行脚本：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line">ls | python3 show_file.py
</div></li></ul></code></pre>
<p>将会打印出当前目录中所有文件的名字。每个 Shell 脚本都有返回值， 用于表示脚本是否成功，通过命令 <code>echo $?</code> 可以查看上一条命令的返回结果，比如：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line">./create_file.sh
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> [ $? = 0 ] ; <span class="hljs-keyword">then</span>  <span class="hljs-comment"># 只有成功创建文件，才会写入内容</span>
</div></li><li><div class="code_line">    ./write_to_file.sh
</div></li><li><div class="code_line"><span class="hljs-keyword">else</span>
</div></li><li><div class="code_line">    <span class="hljs-built_in">echo</span> <span class="hljs-string">"error"</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">fi</span>
</div></li></ul></code></pre>
<p>由于脚本命令的返回值具有重要的参考价值，因此我们的 Python 脚本也要遵循这一规范，这样别的命令可以很容易的知道 Python 脚本的执行情况。因此，标准的入口文件总是应该套用这个模板：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> sys
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 执行某些逻辑</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 如果发生错误</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># sys.exit(1)</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
</div></li><li><div class="code_line">    sys.exit(main())
</div></li></ul></code></pre>
<h3 id="section55venv">5.5 venv</h3>
<h4 id="section551venv">5.5.1 什么是 venv</h4>
<p>假设我们开发程序 A 是用到了 <code>pip install module1==1.0</code>，也就是安装了 <code>module1</code> 这个第三方库的 1.0 版本，同时开发程序 B 用到了这个第三方库的 2.0 版本，但是在 <code>/usr/local/lib/python3.5/site-packages</code> 这个目录下只能留一份，那么 A 和 B 就无法分别使用两个版本的第三方库了。</p>
<p>于是诞生了虚拟环境（virtualenv，简称 venv）的概念，它会为每个应用单独提供一份 Python 的运行环境，从而起到隔离的效果。</p>
<p>执行以下命令：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line">pip3 install virtualenv
</div></li><li><div class="code_line">virtualenv <span class="hljs-built_in">test</span>
</div></li></ul></code></pre>
<p>这首先会安装 <code>virtualenv</code> 这个工具模块，然后在当前目录下新建一个虚拟环境 <code>test</code>，其实也就是一个目录。</p>
<h4 id="section552venv">5.5.2 venv 结构初探</h4>
<p>观察目录的组成可以发现，主要是有三个文件夹：<code>bin</code>、<code>include</code> 和 <code>lib</code>。</p>
<p><code>bin</code> 目录下主要是一些可执行文件，比如虚拟环境的激活与退出，以及 Python 和 pip 的可执行文件。比如：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line"><span class="hljs-built_in">source</span> bin/active
</div></li><li><div class="code_line"><span class="hljs-comment"># 现在开始，虚拟环境已经生效，安装的模块都在这个文件夹内部</span>
</div></li><li><div class="code_line">pip instal module1
</div></li><li><div class="code_line">pip instal module2
</div></li><li><div class="code_line"><span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line">deactive
</div></li></ul></code></pre>
<p><code>inlcude</code> 目录下的会通过软连接，导入一些 C 语言的头文件，暂时不清楚作用。</p>
<p><code>lib</code> 目录下引用了 Python 自带的一些模块，以及第三方包 <code>site-packages</code> 文件夹的拷贝。如果执行的是 <code>virtualenv --no-site-packages test</code> 将会得到一个不含第三方包，纯净的虚拟环境。</p>
<h4 id="section553">5.5.3 工作原理</h4>
<p>其实 venv 的工作原理非常简单，完全集中在 <code>bin/active</code> 这个简单的脚本中，它的核心部分如下：</p>
<pre><code class="bash language-bash hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-title">deactive</span></span> () {
</div></li><li><div class="code_line">    <span class="hljs-comment"># 恢复环境</span>
</div></li><li><div class="code_line">}
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">VIRTUAL_ENV=<span class="hljs-string">"/Users/zxy/Desktop/testvenv"</span>
</div></li><li><div class="code_line"><span class="hljs-built_in">export</span> VIRTUAL_ENV
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">_OLD_VIRTUAL_PATH=<span class="hljs-string">"<span class="hljs-variable">$PATH</span>"</span>
</div></li><li><div class="code_line">PATH=<span class="hljs-string">"<span class="hljs-variable">$VIRTUAL_ENV</span>/bin:<span class="hljs-variable">$PATH</span>"</span>
</div></li><li><div class="code_line"><span class="hljs-built_in">export</span> PATH
</div></li></ul></code></pre>
<p>可见它把当前目录标记为 <code>VIRTUAL_ENV</code>，然后添加到系统的 <code>PATH</code> 最前面，这样我们执行 <code>pip</code> 命令时，第三方的包就会被安装虚拟环境内的 <code>site-packages</code> 文件夹中，不会与系统的干扰。</p>
<h2 id="section6">6 学习方向</h2>
<p>由于作者水平和文章篇幅有限，不可能所有知识点都面面俱到，如果本文激起了你对 Python 的兴趣，我有几个建议或许能帮助你进一步的提高自己的 Python 水平，按照重要级的降序排列：</p>
<ol>
<li>先确保本文中的所有 Demo 都自己实现过一遍，看代码和写代码是两种截然不同的体验</li>
<li>了解 Python 标准库中提供的函数，避免重复造轮子，更高效的完成需求</li>
<li>尝试用 Tornado、Flask、Django、MITM 等著名的 Python 框架完成一些自己的需求，把 Python 知识与实践结合起来，有机会的话可以阅读这些框架的源码</li>
<li>针对自己还不够了解的知识点，查找 Google 上的优秀博客</li>
</ol>
<h2 id="section7">7 版本历史</h2>
<h4 id="section100">1.0.0</h4>
<p>首次发布</p>
<h4 id="section101">1.0.1</h4>
<ol>
<li>改正了 1.1.2 节中的错别字，<code>精度</code> -&gt; <code>经度</code>，<code>维度</code> -&gt; <code>纬度</code></li>
<li>改正了 1.1.2 节中 <code>p.name</code> 错误的写成了 22 的问题</li>
<li>改正了 1.2.2 节中单词拼写错误， <code>seddefault</code> -&gt; <code>setdefault</code></li>
<li>改正了 2.3 节中 <code>co_argcount</code> 值错误的问题，经过查阅<a href="https://docs.python.org/3/library/inspect.html#types-and-members" target="_blank">官方文档</a>，这个值不会统计 <code>*</code>、<code>**</code> 和仅限关键字参数</li>
<li>改正了 2.2.3 节中的输出结果，<code>[1, 2, 3]</code> -&gt; <code>(1, 2, 3)</code></li>
<li>改正了 3.4.1 节中的错别字，<code>元祖</code> -&gt; <code>元组</code></li>
<li>改正了 3.1.2 节中的代码错误，<code>a</code> -&gt; <code>b</code></li>
<li>改正了 1.2.5 节中的错误，<code>交集</code> -&gt; <code>并集</code></li>
<li>改正了 2.4.2 节中的语法错误 <code>decorate</code> -&gt; <code>@decorate</code></li>
<li>改正了 5.3.1 节中的代码错误 <code>r</code> -&gt; <code>rb</code></li>
</ol>
<h2 id="section">参考资料：</h2>
<ol>
<li><a href="http://www.cnblogs.com/xybaby/p/6270551.html" target="_blank">python属性查找 深入理解（attribute lookup）</a></li>
<li><a href="https://www.python.org/download/releases/2.3/mro/" target="_blank">The Python 2.3 Method Resolution Order</a></li>
<li><a href="http://www.bjhee.com/python-mixin.html" target="_blank">关于Python的Mixin模式</a></li>
<li><a href="https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods" target="_blank">The definitive guide on how to use static, class or abstract methods in Python</a></li>
<li><a href="http://fullstack.blog/2017/02/26/%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%9B%9E%E8%B0%83%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6/" target="_blank">异步与回调的设计哲学</a></li>
<li><a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank">Python的GIL是什么鬼，多线程性能究竟如何</a></li>
<li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c06/p02_read-write_json_data.html" target="_blank">6.2 读写JSON数据</a></li>
<li><a href="https://loggerhead.me/posts/python-de-import-ji-zhi.html#_1" target="_blank">Python 的 import 机制</a></li>
</ol></div>
                    <div class="xzl-topic-summary-content hidden_topic_body hidden" id="xzl-topic-summary-content"><p>Python 是一门非常容易上手的语言，通过查阅资料和教程，也许一晚上就能写出一个简单的爬虫。但 Python 也是一门很难精通的语言，因为简洁的语法背后隐藏了许多黑科技。本文主要针对的读者是：</p>
<ol>
<li>毫无 Python 经验的小白</li>
<li>有一些简单 Python 经验，但只会复制粘贴代码，不知其所以然的读者</li>
<li>觉得单独一篇文章太琐碎，质量没保证，却没空读完一本书，但又想对 Python 有全面了解的读者</li>
</ol>
<p>当然， 用一篇文章来讲完某个语言是不可能的事情，我希望读完本文的读者可以：</p>
<ol>
<li>对 Python 的整体知识结构形成初步的概念</li>
<li>了解 Python 特有的知识点，比如装饰器、上下文、生成器等等，不仅会写 Demo，还对背后的原理有一定了解</li>
<li>避免 C++/Java 等风格的 Python 代码，能够写出地道的 Python 代码</li>
<li>能够熟练的使用 Python 编写脚本实现日常的简单需求，能够维护小型 Python 项目，能够阅读较复杂的 Python 源码</li>
</ol>
<p>如果以上介绍符合你对自己的定位，在开始阅读前，还需要明确几点：</p>
<ol>
<li>本文不会只介绍用法，那样太肤浅</li>
<li>本文不会深入介绍某个知识点，比如分析源码等，那样太啰嗦，我希望做一名引路人，描述各个知识点的概貌并略作引申，为读者指出下一步的研究方向</li>
<li>代码注释非常重要，一定要看，几乎所有的代码段都可以执行，<strong>强烈建议</strong>手敲一遍！</li>
</ol>
<p></p><div class="toc">
<ul>
<li><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section0" target="_blank" rel="noopener">0. 准备工作</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section1" target="_blank" rel="noopener">1. 数据结构</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section11" target="_blank" rel="noopener">1.1 数组</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section111" target="_blank" rel="noopener">1.1.1 列表推导</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section112" target="_blank" rel="noopener">1.1.2 元组</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section113" target="_blank" rel="noopener">1.1.3 数组切片</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section114" target="_blank" rel="noopener">1.1.4 循环与遍历</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section115" target="_blank" rel="noopener">1.1.5 魔术方法</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section12" target="_blank" rel="noopener">1.2 字典</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section121" target="_blank" rel="noopener">1.2.1 初始化字典</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section122" target="_blank" rel="noopener">1.2.2 查询字典</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section123" target="_blank" rel="noopener">1.2.3 遍历字典</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section124" target="_blank" rel="noopener">1.2.4 字典的魔术方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section125" target="_blank" rel="noopener">1.2.5 集合</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section13" target="_blank" rel="noopener">1.3 字符串</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section131" target="_blank" rel="noopener">1.3.1 字符串编码</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section132" target="_blank" rel="noopener">1.3.2 字符串的常用方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section133" target="_blank" rel="noopener">1.3.3 字符串格式化</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section134heredoc" target="_blank" rel="noopener">1.3.4 HereDoc</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section2" target="_blank" rel="noopener">2 函数</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section21" target="_blank" rel="noopener">2.1 函数是一等公民</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section22" target="_blank" rel="noopener">2.2 函数参数</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section221" target="_blank" rel="noopener">2.2.1 函数传参</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section222" target="_blank" rel="noopener">2.2.2 默认参数</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section223" target="_blank" rel="noopener">2.2.3 多参数传递</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section224" target="_blank" rel="noopener">2.2.4 参数分类</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section23" target="_blank" rel="noopener">2.3 函数内省</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section24" target="_blank" rel="noopener">2.4 装饰器</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section241" target="_blank" rel="noopener">2.4.1 设计模式的消亡</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section242" target="_blank" rel="noopener">2.4.2 装饰器的基本原理</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section243" target="_blank" rel="noopener">2.4.3 装饰器进阶</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section244" target="_blank" rel="noopener">2.4.4 装饰器工厂</a></li>
</ul>
</li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section3" target="_blank" rel="noopener">3 面向对象</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section31" target="_blank" rel="noopener">3.1 对象内存管理</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section311" target="_blank" rel="noopener">3.1.1 对象不是盒子</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section312" target="_blank" rel="noopener">3.1.2 默认浅复制</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section313" target="_blank" rel="noopener">3.1.3 弱引用</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section32python" target="_blank" rel="noopener">3.2 Python 风格的对象</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section321" target="_blank" rel="noopener">3.2.1 静态函数与类方法</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section322attribute" target="_blank" rel="noopener">3.2.2 属性 attribute</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section323property" target="_blank" rel="noopener">3.2.3 特性 property</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section324" target="_blank" rel="noopener">3.2.4 特性工厂</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section325" target="_blank" rel="noopener">3.2.5 属性描述符</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section326" target="_blank" rel="noopener">3.2.6 实例属性的查找顺序</a></li>
</ul>
</li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section33" target="_blank" rel="noopener">3.3 多继承</a><ul>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section331" target="_blank" rel="noopener">3.3.1 多继承的必要性</a></li>
<li><a data-no-turbolink="true" data-turbolinks="false" href="https://xiaozhuanlan.com/topic/1053427869#section332python" target="_blank" rel="noopener">3.3.2 Python 的多继承</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p></p>
<h2 id="section0">0. 准备工作</h2>
<p>请不要在学习 Python2 还是 Python3 之间犹豫了，除非你很明确自己只接触 Python2，否则就从 Python3 学起，新版本的语言总是意味着进步的生产力（Swift 和 Xcode 除外）。Python 2 和 3 之间语法不兼容，但这并不影响熟悉 Python3 的开发者迅速写出 Python 2 的代码，反之亦然。所以与其在反复纠结中浪费时间，不如立刻行动起来。</p>
<p>推荐使用 <strong>CodeRunner</strong> 来运行本文中的 demo，它比文本编辑器功能更强大，比如支持自动补全和断点调试，又比 PyCharm 轻量得多。</p>
<h2 id="section1">1. 数据结构</h2>
<h3 id="section11">1.1 数组</h3>
<h4 id="section111">1.1.1 列表推导</h4>
<p>如果要对数组中的所有内容做一些修改，可以用 for 循环或者 map 函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">small = []
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> array: 
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>:
</div></li><li><div class="code_line">        small.append(n * <span class="hljs-number">2</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">print(small)  <span class="hljs-comment"># [2, 4, 6]</span>
</div></li></ul></code></pre>
<p>比较地道的 Python 写法是使用列表推导：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">small = [n * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> array <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">4</span>]
</div></li></ul></code></pre>
<p><code>for in</code> 可以写两次，类似于嵌套的 for 循环，会得到一个笛卡尔积：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">signs = [<span class="hljs-string">'+'</span>, <span class="hljs-string">'-'</span>]
</div></li><li><div class="code_line">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">ascii = [<span class="hljs-string">'{sign}{number}'</span>.format(sign=sign, number=number) 
</div></li><li><div class="code_line">        <span class="hljs-keyword">for</span> sign <span class="hljs-keyword">in</span> signs <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers]
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：['+1', '+2', '-1', '-2']</span>
</div></li></ul></code></pre>
<h4 id="section112">1.1.2 元组</h4>
<p>元组可以简单的理解为不可变的数组，也就是没有 <code>append</code>、<code>del</code> 等方法，一旦创建，就无法新增或删除元素，元素自身的值也不能改变，但元素内部的属性是否可变并不受元组的影响，这一点符合其他语言中的常识。</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, [])
</div></li><li><div class="code_line">t[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>  <span class="hljs-comment"># 抛出错误 TypeError: 'tuple' object does not support item assignment</span>
</div></li><li><div class="code_line">t[<span class="hljs-number">1</span>].append(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 正常运行，现在的 t 是 (1, [2])</span>
</div></li></ul></code></pre>
<p>除了不可变性以外，有时候元组也会被当做不具名的数据结构，这时候元素的位置就不再是可有可无的了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">coordinate = (<span class="hljs-number">33.9425</span>, <span class="hljs-number">-118.408056</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># coordinate 的第一个位置用来表示经度，第二个位置表示纬度</span>
</div></li></ul></code></pre>
<p>在解析元组数据时，可以一一对应的写上变量名：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line">a, b = t <span class="hljs-comment"># a = 1, b = 2</span>
</div></li></ul></code></pre>
<p>有时候变量名比较长， 但我只关心其中某一个，可以这样写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line">a, _ = t <span class="hljs-comment"># a = 1</span>
</div></li></ul></code></pre>
<p>如果元组中元素特别多，即使挨个写下划线也比较累，可以用 \* 来批量解包：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
</div></li><li><div class="code_line">first, *middle, last = t
</div></li><li><div class="code_line"><span class="hljs-comment"># first = 1</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># middle = [2, 3, 4]</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># last = 5</span>
</div></li></ul></code></pre>
<p>当然，如果元素数量较多，含义较复杂，我还是建议使用具名元组：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> collections
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">People = collections.namedtuple(<span class="hljs-string">'People'</span>, [<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>])
</div></li><li><div class="code_line">p = People(<span class="hljs-string">'bestswifter'</span>, <span class="hljs-string">'22'</span>)
</div></li><li><div class="code_line">p.name <span class="hljs-comment"># bestswifter</span>
</div></li></ul></code></pre>
<p>具名元组更像是一个不能定义方法的简化版的类，能提供友好的数据展示。</p>
<p>元组的一个小技巧是可以避免用临时变量来交换两个数的值：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = <span class="hljs-number">1</span> 
</div></li><li><div class="code_line">b = <span class="hljs-number">2</span>
</div></li><li><div class="code_line">a, b = b, a
</div></li><li><div class="code_line"><span class="hljs-comment"># a = 2, b = 1</span>
</div></li></ul></code></pre>
<h4 id="section113">1.1.3 数组切片</h4>
<p>切片的基本格式是 <code>array[start🔚step]</code>，表示对 array 在 start 到 end 之前以 step 为间隔取切片。注意这里的区间是 [start, end)，也就是左闭右开。比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]
</div></li><li><div class="code_line"><span class="hljs-comment"># 表示取 s 的第 0、2、4 个字符，结果是 'hlo'</span>
</div></li></ul></code></pre>
<p>再举几个例子</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]  <span class="hljs-comment"># 不写 step 默认就是 1，因此得到 'hello'</span>
</div></li><li><div class="code_line">s[<span class="hljs-number">1</span>:]   <span class="hljs-comment"># 不写 end 默认到结尾，因此还是得到 'ello'</span>
</div></li><li><div class="code_line">s[n:]   <span class="hljs-comment"># 获取 s 的最后 len(s) - n 个元素</span>
</div></li><li><div class="code_line">s[:<span class="hljs-number">2</span>]   <span class="hljs-comment"># 不写 start 默认从 0 开始，因此得到 'he'</span>
</div></li><li><div class="code_line">s[:n]   <span class="hljs-comment"># 获取 s 的前 n 个元素</span>
</div></li><li><div class="code_line">s[:<span class="hljs-number">-1</span>]  <span class="hljs-comment"># 负数表示倒过来数，因此这会刨除最后一个字符，得到 'hell'</span>
</div></li><li><div class="code_line">s[<span class="hljs-number">-2</span>:]  <span class="hljs-comment"># 同上，表示获取最后两个字符，得到 'lo'</span>
</div></li><li><div class="code_line">s[::<span class="hljs-number">-1</span>] <span class="hljs-comment"># 获取字符串的倒序排列，相当于 reverse 函数</span>
</div></li></ul></code></pre>
<p>step 和它前面的冒号要么同时写，要么同时不写，但 start 和 end 之间的冒号不能省，否则就不是切片而是获取元素了。再次强调 <code>array[start:end]</code> 表示的区间是 [a, b)，也许你会觉得这很难记，但同样的，这会得出以下美妙的公式：</p>
<blockquote>
  <p>array[:n] + array[n:] = array (0 &lt;= n &lt;= len(array))</p>
</blockquote>
<p>用代码来表示就是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">s[:<span class="hljs-number">2</span>] + s[<span class="hljs-number">2</span>:] == s  
</div></li><li><div class="code_line"><span class="hljs-comment"># True，因为 s[:2] 是 'he'，s[2:] 是 'llo'</span>
</div></li></ul></code></pre>
<p>切片不仅可以用来获取数组的一部分值，修改切片也可以直接修改数组的对应部分，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]
</div></li><li><div class="code_line"><span class="hljs-comment"># a = [1, 22, 33, 44, 4, 5, 6]</span>
</div></li></ul></code></pre>
<p>并没有人规定切片的新值必须和原来的长度一致：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">3</span>]
</div></li><li><div class="code_line"><span class="hljs-comment"># a = [1, 3, 4, 5, 6]</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] = []
</div></li><li><div class="code_line"><span class="hljs-comment"># a = [1, 6]，相当于删除了中间的三个数字</span>
</div></li></ul></code></pre>
<p>但切片的新值必须也是可迭代的对象，比如这样写是不合法的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]
</div></li><li><div class="code_line">a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># TypeError: can only assign an iterable</span>
</div></li></ul></code></pre>
<h4 id="section114">1.1.4 循环与遍历</h4>
<p>一般来说，在 Python 中我们不会写出 <code>for (int i = 0; i &lt; len(array); ++i)</code> 这种风格的代码，而是使用 <code>for in</code> 这种语法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:
</div></li><li><div class="code_line">    print(i)
</div></li></ul></code></pre>
<p>虽然大家都知道 <code>for in</code> 语法，但它的某些灵活用法或许就不是那么众所周知了。有时候，我们会在 <code>if</code> 语句中对某个变量的值做多次判断，只要满足一个条件即可：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">name = <span class="hljs-string">'bs'</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> name == <span class="hljs-string">'hello'</span> <span class="hljs-keyword">or</span> name == <span class="hljs-string">'hi'</span> <span class="hljs-keyword">or</span> name == <span class="hljs-string">'bs'</span> <span class="hljs-keyword">or</span> name == <span class="hljs-string">'admin'</span>:
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Valid'</span>) 
</div></li></ul></code></pre>
<p>这种情况推荐用 <code>in</code> 来代替：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">name = <span class="hljs-string">'bs'</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> (<span class="hljs-string">'hello'</span>, <span class="hljs-string">'hi'</span>, <span class="hljs-string">'bs'</span>, <span class="hljs-string">'admin'</span>):
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Valid'</span>)
</div></li></ul></code></pre>
<p>有时候，如果我们想要把某件事重复固定的次数，用 <code>for in</code> 会显得有些啰嗦，这时候可以借助 <code>range</code> 类型：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hi'</span>) <span class="hljs-comment"># 打印五次 'Hi'</span>
</div></li></ul></code></pre>
<p><code>range</code> 的语法和切片类似，比如我们需要访问数组所有奇数下标的元素，可以这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(a), <span class="hljs-number">2</span>):
</div></li><li><div class="code_line">    print(a[i])
</div></li></ul></code></pre>
<p>在这种写法中，我们不仅能获得元素，还能知道元素的下标，这与使用 <code>enumerate(iterable [, start ])</code> 函数类似：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i, n <span class="hljs-keyword">in</span> enumerate(a):
</div></li><li><div class="code_line">    print(i, n)
</div></li></ul></code></pre>
<h4 id="section115">1.1.5 魔术方法</h4>
<p>也许你已经注意到了，数组和字符串都支持切片，而且语法高度统一。这在某些强类型语言（比如我经常接触的 Objective-C 和 Java）中是不可能的，事实上，Python 能够支持这样统一的语法，并非巧合，而是因为所有用中括号进行下标访问的操作，其实都是调用这个类的 <code>__getitem__</code> 方法。</p>
<p>比如我们完全可以让自己的类也支持通过下标访问：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.chapters = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, n)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self.chapters[n]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">b = Book()
</div></li><li><div class="code_line">print(b[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 结果是 2</span>
</div></li></ul></code></pre>
<p>需要注意的是，这段代码几乎不会出问题（除非数组越界），这是因为我们直接把下标传到了内部的 <code>self.chapters</code> 数组上。但如果要自己处理下标，需要牢记它不一定是数字，也可以是切片，因此更完整的逻辑应该是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self, n)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> isinstance(n, int): <span class="hljs-comment"># n是索引</span>
</div></li><li><div class="code_line">        <span class="hljs-comment"># 处理索引</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> isinstance(n, slice): <span class="hljs-comment"># n是切片</span>
</div></li><li><div class="code_line">        <span class="hljs-comment"># 通过 n.start，n.stop 和 n.step 来处理切片</span>
</div></li></ul></code></pre>
<p>与静态语言不同的是，任何实现了 <code>__getitem__</code> 都支持通过下标访问，而不用声明为实现了某个协议，这种特性也被称为 “鸭子类型”。鸭子类型并不要求某个类 <strong>是什么</strong>，仅仅要求这个类 <strong>能做什么</strong>。</p>
<p>顺便说一句，实现了 <code>__getitem__</code> 方法的类都是可迭代的，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">b = Book()
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> b:
</div></li><li><div class="code_line">    print(c)
</div></li></ul></code></pre>
<p>后续的章节还会介绍更多 Python 中的魔术方法，这种方法的名称前后都有两个下划线，如果读作 “下划线-下划线-getitem” 会比较拗口，因此可以读作 “dunder-getitem” 或者 “双下-getitem”，类似的，我想每个人都能猜到 <code>__setitem__</code> 的作用和用法。</p>
<h3 id="section12">1.2 字典</h3>
<h4 id="section121">1.2.1 初始化字典</h4>
<p>最简单的创建一个字典的方式就是直接写字面量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">{<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">63</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">64</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">65</span>}
</div></li></ul></code></pre>
<p>字典字面量由大括号包住（注意区别于数组的中括号），键值对之间由逗号分割，每个键值对内部用冒号分割键和值。</p>
<p>如果数组的每个元素都是二元的元组，这个数组可以直接转成字典：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">dict([(<span class="hljs-string">'a'</span>, <span class="hljs-number">61</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-number">62</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-number">63</span>), (<span class="hljs-string">'d'</span>, <span class="hljs-number">64</span>), (<span class="hljs-string">'e'</span>, <span class="hljs-number">65</span>)])
</div></li></ul></code></pre>
<p>就像数组可以推导一样，字典也可以推导：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [(<span class="hljs-string">'a'</span>, <span class="hljs-number">61</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-number">62</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-number">63</span>), (<span class="hljs-string">'d'</span>, <span class="hljs-number">64</span>), (<span class="hljs-string">'e'</span>, <span class="hljs-number">65</span>)]
</div></li><li><div class="code_line">d = {letter: number <span class="hljs-keyword">for</span> letter, number <span class="hljs-keyword">in</span> a} <span class="hljs-comment"># 这里用到了元组拆包</span>
</div></li></ul></code></pre>
<p>只要记得外面还是大括号就行了。</p>
<p>两个独立的数组可以被压缩成一个字典：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">numbers = [<span class="hljs-number">61</span>, <span class="hljs-number">62</span>, <span class="hljs-number">63</span>, <span class="hljs-number">64</span>, <span class="hljs-number">65</span>]
</div></li><li><div class="code_line">letters = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>]
</div></li><li><div class="code_line">dict(zip(letters, numbers))
</div></li></ul></code></pre>
<p>正如 zip 的意思所表示的，超出长处的那部分数组会被抛弃。</p>
<h4 id="section122">1.2.2 查询字典</h4>
<p>最简单方法是直接写键名，但如果键名不存在会抛出 <code>KeyError</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>}
</div></li><li><div class="code_line">d[<span class="hljs-string">'a'</span>] <span class="hljs-comment"># 值是 61</span>
</div></li><li><div class="code_line">d[<span class="hljs-string">'b'</span>] <span class="hljs-comment"># KeyError: 'b'</span>
</div></li></ul></code></pre>
<p>可以用 <code>if key in dict</code> 的判断来检查键是否存在，甚至可以先 <code>try</code> 再 <code>catch KeyError</code> ，但更加优雅简洁一些的写法是用 <code>get(k, default)</code> 方法来提供默认值：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>}
</div></li><li><div class="code_line">d.get(<span class="hljs-string">'a'</span>, <span class="hljs-number">62</span>) <span class="hljs-comment"># 得到 61</span>
</div></li><li><div class="code_line">d.get(<span class="hljs-string">'b'</span>, <span class="hljs-number">62</span>) <span class="hljs-comment"># 得到 62</span>
</div></li></ul></code></pre>
<p>不过有时候，我们可能不仅仅要读出默认属性，更希望能把这个默认属性能写入到字典中，比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {}
</div></li><li><div class="code_line"><span class="hljs-comment"># 我们想对字典中某个 Value 做操作，如果 Key 不存在，就先写入一个空值</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">if</span> <span class="hljs-string">'list'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> d:
</div></li><li><div class="code_line">    d[<span class="hljs-string">'list'</span>] = []
</div></li><li><div class="code_line">d[<span class="hljs-string">'list'</span>].append(<span class="hljs-number">1</span>)
</div></li></ul></code></pre>
<p>这种情况下，<code>setdefault(key, default)</code> 函数或许更合适：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d.setdefault(<span class="hljs-string">'key'</span>, []).append(<span class="hljs-number">1</span>)
</div></li></ul></code></pre>
<p>这个函数虽然名为 <code>set</code>，但作用其实是查找，仅仅在查找不到时才会把默认值写入字典。</p>
<h4 id="section123">1.2.3 遍历字典</h4>
<p>直接遍历字典实际上是遍历了字典的键，因此也可以通过键获取值：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">63</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">64</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">65</span>}
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> d:
</div></li><li><div class="code_line">    print(i, d[i])
</div></li><li><div class="code_line"><span class="hljs-comment">#b 62</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#a 61</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#e 65</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#d 64</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#c 63</span>
</div></li></ul></code></pre>
<p>我们也可以用字典的 <code>keys()</code> 或者 <code>values()</code> 方法显式的获取键和值。字典还有一个 <code>items()</code> 方法，它返回一个数组，每个元素都是由键和值组成的二元元组：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">63</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">64</span>, <span class="hljs-string">'e'</span>: <span class="hljs-number">65</span>}
</div></li><li><div class="code_line"><span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> d.items():
</div></li><li><div class="code_line">    print(k, v)
</div></li><li><div class="code_line"><span class="hljs-comment">#e 65</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#d 64</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#a 61</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#c 63</span>
</div></li><li><div class="code_line"><span class="hljs-comment">#b 62</span>
</div></li></ul></code></pre>
<p>可见 <code>items()</code> 方法和字典的构造方法互为逆操作，因为这个公式总是成立的：</p>
<blockquote>
  <p>dict(d.items()) == d</p>
</blockquote>
<h4 id="section124">1.2.4 字典的魔术方法</h4>
<p>在 1.1.4 节中介绍过，通过下标访问最终都会由 <code>__getitem__</code> 这个魔术方法处理，因此字典的 <code>d[key]</code> 这种写法也不例外， 如果键不存在，则会走到 <code>__missing__</code> 方法，再给一次挽救的机会。比如我们可以实现一个字典， 自动忽略键的大小写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDict</span><span class="hljs-params">(dict)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__missing__</span><span class="hljs-params">(self, key)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> key.islower():
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> KeyError(key)
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">return</span> self[key.lower()]
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">d = MyDict({<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>})
</div></li><li><div class="code_line">d[<span class="hljs-string">'A'</span>] <span class="hljs-comment"># 返回 61</span>
</div></li><li><div class="code_line"><span class="hljs-string">'A'</span> <span class="hljs-keyword">in</span> d <span class="hljs-comment"># False</span>
</div></li></ul></code></pre>
<p>这个字典比较简陋，比如 key 可能不是字符串，不过我没有处理太多情况，因为它主要是用来演示 <code>__missing__</code> 的用法，如果想要最后一行的 <code>in</code> 语法正确工作，需要重写 <code>__contains__</code> 这个魔术方法，过程类似，就不赘述了。</p>
<p>虽然通过自定义的函数也能实现相似的效果，不过这个自定义字典对用户更加透明，如果不在文档中说明，调用方很难察觉到字典的内部逻辑被修改了。 Python 有很多强大的功能，可以具备这种内部进行修改，但是对外保持透明的能力。这可能是我们第一次体会到，后续还会不断的经历。</p>
<h4 id="section125">1.2.5 集合</h4>
<p>集合更像是不会有重复元素的数组，但它的本质是以元素的哈希值作为 Key，从而实现去重的逻辑。因此，集合也可以推导，不过得用字典的语法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]
</div></li><li><div class="code_line">d = {i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">5</span>}
</div></li><li><div class="code_line"><span class="hljs-comment"># d = {1, 2, 3, 4}，注意这里的大括号</span>
</div></li></ul></code></pre>
<p>回忆一下，二进制逻辑运算一共有三个运算符，按位或 <code>|</code>，按位与 <code>&amp;</code> 和异或 <code>^</code>，这三个运算符也可以用在集合之间，而且含义变化不大。比如：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a | b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {1, 2, 3, 4, 5}</span>
</div></li></ul></code></pre>
<p>这里的 <code>|</code> 运算表示并集，也就是 c 中的任意元素，要么在 a，要么在 b 集合中。类似的，按位与 <code>&amp;</code> 运算求的就是交集：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a &amp; b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {3}</span>
</div></li></ul></code></pre>
<p>而异或则表示那些只在 a 不在 b 或者只在 b 不在 a 的元素。或者换个说法，表示那些在集合 a 和 b 中出现了且仅出现了一次的元素：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a ^ b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {1, 2, 4, 5}</span>
</div></li></ul></code></pre>
<p>还有一个差集运算 <code>-</code>，表示在集合 a 中但不在集合 b 中的元素：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
</div></li><li><div class="code_line">b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
</div></li><li><div class="code_line">c = a - b
</div></li><li><div class="code_line"><span class="hljs-comment"># c = {1, 2}</span>
</div></li></ul></code></pre>
<p>回忆一下韦恩图，就会得到以下公式（虽然并没有什么卵用）：</p>
<blockquote>
  <p>A | B = (A ^ B) | (A &amp; B)<br>
  A ^ B = (A - B) | (B - A)</p>
</blockquote>
<h3 id="section13">1.3 字符串</h3>
<h4 id="section131">1.3.1 字符串编码</h4>
<p>用 Python 写过爬虫的人都应该感受过被字符串编码支配的恐惧。简单来说，编码指的是将可读的字符串转换成不太可读的数字，用来存储或者传输。解码则指的是将数字还原成字符串的过程。常见的编码有 ASCII、GBK 等。</p>
<p>ASCII 编码是一个相当小的字符集合，只有一百多个常用的字符，因此只用一个字节（8 位）就能表示，为了存储本国语言，各个国家都开发出了自己的编码，比如中文的 GBK。这就带来了一个问题，如果我想要在一篇文章中同时写中文和日文，就无法实现了，除非能对每个字符指定编码，这个成本高到无法接受。</p>
<p>Unicode 则是一个最全的编码方式，每个 Unicode 字符占据 6 个字节，可以表示出 2 ^ 48 种字符。但随之而来的是 Unicode 编码后的内容不适合存储和发送，因此诞生了基于 Unicode 的再次编码，目的是为了更高效的存储。</p>
<p>更详细的概念分析和配图说明可以参考我的这篇文章：<a href="http://fullstack.blog/2017/09/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E5%85%A5%E9%97%A8%E7%A7%91%E6%99%AE/" target="_blank">字符串编码入门科普</a>，这里我们主要聊聊 Python 对字符串编码的处理。</p>
<p>首先，编码的函数是 <code>encode</code>，它是字符串的方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">s.encode()         <span class="hljs-comment"># 得到 b'hello'</span>
</div></li><li><div class="code_line">s.encode(<span class="hljs-string">'utf16'</span>)  <span class="hljs-comment"># 得到 b'\xff\xfeh\x00e\x00l\x00l\x00o\x00'</span>
</div></li></ul></code></pre>
<p><code>encode</code> 函数有两个参数，第一个参数不写表示使用默认的 <code>utf8</code> 编码，理论上会输出二进制格式的编码结果，但在终端打印时，被自动还原回字符串了。如果用 <code>utf16</code> 进行编码，则会看到编码以后的二进制结果。</p>
<p>前面说过，编码是字符转到二进制的转化过程，有时候在某个编码规范中，并没有指定某个字符是如何编码的，也就是找不到对应的数字，这时候编码就会报错：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">city = <span class="hljs-string">'São Paulo'</span>
</div></li><li><div class="code_line">b_city = city.encode(<span class="hljs-string">'cp437'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># UnicodeEncodeError: 'charmap' codec can't encode character '\xe3' in position 1: character maps to &lt;undefined&gt;</span>
</div></li></ul></code></pre>
<p>此时需要用到 <code>encode</code> 函数的第二个参数，用来指定遇到错误时的行为。它的值可以是 <code>'ignore'</code>，表示忽略这个不能编码的字符，也可以是 <code>'replace'</code>，表示用默认字符代替：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">b_city = city.encode(<span class="hljs-string">'cp437'</span>, errors=<span class="hljs-string">'ignore'</span>) 
</div></li><li><div class="code_line"><span class="hljs-comment"># b'So Paulo'</span>
</div></li><li><div class="code_line">b_city = city.encode(<span class="hljs-string">'cp437'</span>, errors=<span class="hljs-string">'replace'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># b'S?o Paulo'</span>
</div></li></ul></code></pre>
<p><code>decode</code> 完全是 <code>encode</code> 的逆操作，只有二进制类型才有这个函数。它的两个参数含义和 <code>encode</code> 函数完全一致，就不再介绍了。</p>
<p>从理论上来说，仅从编码后的内容上来看，是无法确定编码方式的，也无法解码出原来的字符。但不同的编码有各自的特点，虽然无法完全倒推，但可以从概率上来猜测，如果发现某个二进制内容，有 99% 的可能性是 <code>utf8</code> 编码生成的，我们就可以用 <code>utf8</code> 进行解码。Python 提供了一个强大的工具包 <code>Chardet</code>  来完成这一任务：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">octets = <span class="hljs-string">b'Montr\xe9al'</span>
</div></li><li><div class="code_line">chardet.detect(octets)
</div></li><li><div class="code_line"><span class="hljs-comment"># {'encoding': 'ISO-8859-1', 'confidence': 0.73, 'language': ''}</span>
</div></li><li><div class="code_line">octets.decode(<span class="hljs-string">'ISO-8859-1'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># Montréal</span>
</div></li></ul></code></pre>
<p>返回结果中包含了猜测的编码方式，以及可信度。可信度越高，说明是这种编码方式的可能性越大。</p>
<p>有时候，我们拿到的是二进制的字符串字面量，比如 <code>68 65 6c 6c 6f</code>，前文说过只有二进制类型才有 <code>decode</code> 函数，所以需要通过二进制的字面量生成二进制变量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'68 65 6c 6c 6f'</span>
</div></li><li><div class="code_line">b = bytearray.fromhex(s)
</div></li><li><div class="code_line">b.decode()  <span class="hljs-comment"># hello</span>
</div></li></ul></code></pre>
<h4 id="section132">1.3.2 字符串的常用方法</h4>
<p>字符串的 <code>split(sep, maxsplit)</code> 方法可以以指定的分隔符进行分割，有点类似于 Shell 中的 <code>awk -F ' '</code>'，第一个 <code>sep</code> 参数表示分隔符，不填则为空格：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'a b c d e'</span>
</div></li><li><div class="code_line">a = s.split()
</div></li><li><div class="code_line"><span class="hljs-comment"># a = ['a', 'b', 'c', 'd', 'e']</span>
</div></li></ul></code></pre>
<p>第二个参数 <code>maxsplit</code> 表示最多分割多少次，因此返回数组的长度是 <code>maxsplit + 1</code>。举个例子说明下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'a;b;c;d;e'</span>
</div></li><li><div class="code_line">a = s.split(<span class="hljs-string">';'</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># a = ['a', 'b', 'c', 'd', 'e']</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">b = s.split(<span class="hljs-string">';'</span>, <span class="hljs-number">2</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># b = ['a', 'b', 'c;d;e']</span>
</div></li></ul></code></pre>
<p>如果想批量替换，则可以用 <code>replace(old, new[, count])</code> 方法，由中括号括起来的参数表示选填。</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">old = <span class="hljs-string">'a;b;c;d;e'</span>
</div></li><li><div class="code_line">new = old.replace(<span class="hljs-string">';'</span>, <span class="hljs-string">' '</span>, <span class="hljs-number">3</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># new = 'a b c d;e'</span>
</div></li></ul></code></pre>
<p><code>strip[chars]</code> 用于移除指定的字符们：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">old = <span class="hljs-string">"*****!!!Hello!!!*****"</span>
</div></li><li><div class="code_line">new = old.strip(<span class="hljs-string">'*'</span>)  <span class="hljs-comment"># 得到 '!!!Hello!!!'</span>
</div></li><li><div class="code_line">new = old.strip(<span class="hljs-string">'*！'</span>)  <span class="hljs-comment"># 得到 'Hello'</span>
</div></li></ul></code></pre>
<p>如果不传参数，则默认移除空格。其实 <code>strip</code> 等价于分别执行 <code>lstrip()</code> 和 <code>rstrip()</code>，即分别从左侧和右侧进行移除。比如 <code>lstrip()</code> 表示从左侧第一个字符开始，移除空格，直到第一个非空格字符为止，所以字符串中间的空格，无论是 <code>lstrip</code> 还是 <code>strip()</code> 都是无法移除的。</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">old = <span class="hljs-string">'  Hello world  '</span>
</div></li><li><div class="code_line">new = old.strip()   <span class="hljs-comment"># 得到 'Hello wrold'</span>
</div></li><li><div class="code_line">new = old.lstrip()  <span class="hljs-comment"># 得到 'Hello world  '</span>
</div></li></ul></code></pre>
<p>最后一个常用方法是 <code>join</code>，其实这个可以理解为字符串的构造方法，它可以把数组转换成字符串：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">array = <span class="hljs-string">'a b c d e'</span>.split() <span class="hljs-comment"># 之前说过，结果是 ['a', 'b', 'c', 'd', 'e']</span>
</div></li><li><div class="code_line">s = <span class="hljs-string">';'</span>.join(array) <span class="hljs-comment"># 以分号为连接符，把数组中的元素连接起来</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># s = 'a;b;c;d;e'</span>
</div></li></ul></code></pre>
<p>所以 <code>join</code> 可以理解为 <code>split</code> 的逆操作，这个公式始终是成立的：</p>
<blockquote>
  <p>c.join(string.split(c)) = string</p>
</blockquote>
<p>上面这些字符串处理的函数，大多返回的还是字符串，因此可以链式调用，避免使用临时变量和多行代码，但也要避免过长（超过 3 个）的链式调用，以免影响可读性。</p>
<h4 id="section133">1.3.3 字符串格式化</h4>
<p>最初级的字符串格式化方法是使用 <code>+</code> 来拼接：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">        self.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">        self.sex = <span class="hljs-string">'m'</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">print(<span class="hljs-string">'Name: '</span> + p.name + <span class="hljs-string">', Age: '</span> + str(p.age) + <span class="hljs-string">', Sex: '</span> + p.sex)
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span>
</div></li></ul></code></pre>
<p>这里必须要把 <code>int</code> 类型的年龄转成字符串以后才能进行拼接，这是因为 Python 是强类型语言，不支持类型的隐式转换。</p>
<p>这种做法的缺点在于如果输出结构比较复杂，极容易出现引号匹配错误的问题，可读性非常低。</p>
<p>Python 2 中的做法是使用占位符，类似于 C 语言中 <code>printf</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">content = <span class="hljs-string">'Name: %s, Age: %i, Sex: %c'</span> % (p.name, p.age, p.sex)
</div></li><li><div class="code_line">print(content)
</div></li></ul></code></pre>
<p>从结构上看，要比上一种写法清楚得多， 但每个变量都需要指定类型，这和 Python 的简洁不符。实际上每个对象都可以通过 <code>str()</code> 函数转换成字符串，这个函数的背后是 <code>__str__</code> 魔术方法。</p>
<p>Python 3 中的写法是使用 <code>format</code> 函数，比如我们来实现一下 <code>__str__</code> 方法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">        self.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">        self.sex = <span class="hljs-string">'m'</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Name: {user.name}, Age: {user.age}, Sex: {user.sex}'</span>.format(user=self)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">print(p)
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出：Name: bestswifter, Age: 22, Sex: m</span>
</div></li></ul></code></pre>
<p>除了把对象传给 <code>format</code> 函数并在字符串中展开以外， 也可以传入多个参数，并且通过下标访问他们：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">print(<span class="hljs-string">'{0}, {1}, {0}'</span>.format(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出：1, 2, 1，这里的 {1} 表示第二个参数</span>
</div></li></ul></code></pre>
<h4 id="section134heredoc">1.3.4 HereDoc</h4>
<p>Heredoc 不是 Python 特有的概念， 命令行和各种脚本中都会见到，它表示一种所见即所得的文本。</p>
<p>假设我们在写一个 HTML 的模板，绝大多数字符串都是常量，只有有限的几个地方会用变量去替换，那这个字符串该如何表示呢？一种写法是直接用单引号去定义：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;\nFriends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;\n&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;\n&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;\n&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back\nONCLICK=\'window.history.back()\'&gt;&lt;/FORM&gt;\n&lt;/BODY&gt;&lt;/HTML&gt;'</span>
</div></li></ul></code></pre>
<p>这段代码是自动生成的还好，如果是手动维护的，那么可读性就非常差，因为换行符和转义后的引号增加了理解的难度。如果用 heredoc 来写，就非常简单了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">s = <span class="hljs-string">'''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back
</span></div></li><li><div class="code_line"><span class="hljs-string">ONCLICK='window.history.back()'&gt;&lt;/FORM&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">&lt;/BODY&gt;&lt;/HTML&gt;
</span></div></li><li><div class="code_line"><span class="hljs-string">'''</span>
</div></li></ul></code></pre>
<p>Heredoc 主要是用来书写大段的字符串常量，比如 HTML 模板，SQL语句等等。</p>
<h2 id="section2">2 函数</h2>
<h3 id="section21">2.1 函数是一等公民</h3>
<p>一等公民指的是 Python 的函数能够动态创建，能赋值给别的变量，能作为参传给函数，也能作为函数的返回值。总而言之，函数和普通变量并没有什么区别。</p>
<p>函数是一等公民，这是函数式编程的基础，然而 Python 中基本上不会使用 lambda 表达式，因为在 lambda 表达式的中仅能使用单纯的表达式，不能赋值，不能使用 while、try 等语句，因此 lambda 表达式要么难以阅读，要么根本无法写出。这极大的限制了 lambda 表达式的使用场景。</p>
<p>上文说过，函数和普通变量没什么区别，但普通变量并不是函数，因为这些变量无法调用。但如果某个类实现了 <code>__call__</code> 这个魔术方法，这个类的实例就都可以像函数一样被调用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">        self.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">        self.sex = <span class="hljs-string">'m'</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        print(self)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-string">'Name: {user.name}, Age: {user.age}, Sex: {user.sex}'</span>.format(user=self)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">p() <span class="hljs-comment"># 等价于 print(p)</span>
</div></li></ul></code></pre>
<h3 id="section22">2.2 函数参数</h3>
<h4 id="section221">2.2.1 函数传参</h4>
<p>对于熟悉 C 系列语言的人来说，函数传参的方式一目了然。默认是拷贝传值，如果传指针是引用传值。我们先来看一段简单的 Python 代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(arg)</span>:</span>
</div></li><li><div class="code_line">    arg = <span class="hljs-number">5</span>
</div></li><li><div class="code_line">    print(arg)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">a = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">foo(a)
</div></li><li><div class="code_line">print(a)
</div></li><li><div class="code_line"><span class="hljs-comment"># 输出 5 和 1</span>
</div></li></ul></code></pre>
<p>这段代码的结果符合我们的预期，从这段代码来看，Python 也属于拷贝传值。但如果再看这段代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(arg)</span>:</span>
</div></li><li><div class="code_line">    arg.append(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">    print(arg)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">a = [<span class="hljs-number">1</span>]
</div></li><li><div class="code_line">foo(a)
</div></li><li><div class="code_line">print(a) <span class="hljs-comment"># 输出两个 [1, 1]</span>
</div></li></ul></code></pre>
<p>你会发现参数数组在函数内部被改变了。就像是 C 语言中传递了变量的指针一样。所以 Python 到底是拷贝传值还是引用传值呢？答案<strong>都是否定的</strong>！</p>
<p>Python 的传值方式可以被理解为混合传值。对于那些不可变的对象（比如 1.1.2 节中介绍过的元组，还有数字、字符串类型），传值方式是拷贝传值；对于那些可变对象（比如数组和字典）则是引用传值。</p>
<h4 id="section222">2.2.2 默认参数</h4>
<p>Python 的函数可以有默认值，这个功能很好用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(a, l=[])</span>:</span>
</div></li><li><div class="code_line">    l.append(a)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> l
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">foo(<span class="hljs-number">2</span>,[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 给数组 [1] 添加一个元素 2，得到 [1,2]</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">2</span>)      <span class="hljs-comment"># 没有传入数组，使用默认的空数组，得到 [2]</span>
</div></li></ul></code></pre>
<p>然而如果这样调用：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 利用默认参数，得到 [2]</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 竟然得到了 [2, 3]</span>
</div></li></ul></code></pre>
<p>函数调用了两次以后，默认参数被改变了，也就是说函数调用产生了副作用。这是因为默认参数的存储并不像函数里的临时变量一样存储在栈上、随着函数调用结束而释放，而是存储在函数这个对象的内部：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo.__defaults__  <span class="hljs-comment"># 一开始确实是空数组</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 利用默认参数，得到 [2]</span>
</div></li><li><div class="code_line">foo.__defaults__  <span class="hljs-comment"># 如果打印出来看，已经变成 [2] 了</span>
</div></li><li><div class="code_line">foo(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 再添加一个元素就得到了 [2, 3]</span>
</div></li></ul></code></pre>
<p>因为函数 <code>foo</code> 作为一个对象，不会被释放，因此这个对象内部的属性也不会随着多次调用而自动重置，会一直保持上次发生的变化。基于这个前提，我们得出一个结论：<strong>函数的默认参数不允许是可变对象</strong>，比如这里的 <code>foo</code> 函数需要这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(a, l=None)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">if</span> l <span class="hljs-keyword">is</span> <span class="hljs-keyword">None</span>:
</div></li><li><div class="code_line">        l = []
</div></li><li><div class="code_line">    l.append(a)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> l
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">print(foo(<span class="hljs-number">2</span>)) <span class="hljs-comment"># 得到 [2]</span>
</div></li><li><div class="code_line">print(foo(<span class="hljs-number">3</span>)) <span class="hljs-comment"># 得到 [3]</span>
</div></li></ul></code></pre>
<p>现在，给参数添加默认值的行为在函数体中完成，不会随着函数的多次调用而累积。</p>
<p>对于 Python 的默认参数来说：</p>
<blockquote>
  <p>如果默认值是不可变的，可以直接设置默认值，否则要设置为 None 并在函数体中设置默认值。</p>
</blockquote>
<h4 id="section223">2.2.3 多参数传递</h4>
<p>当参数个数不确定时，可以在参数名前加一个 <code>*</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args)</span>:</span>
</div></li><li><div class="code_line">    print(args)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 输出 [1, 2, 3]</span>
</div></li></ul></code></pre>
<p>如果直接把数组作为参数传入，它其实是单个参数，如果要把数组中所有元素都作为单独的参数传入，则在数组前面加上 <code>*</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]    
</div></li><li><div class="code_line">foo(a)  <span class="hljs-comment"># 会输出 ([1,2,3], )   因为只传了一个数组作为参数</span>
</div></li><li><div class="code_line">foo(*a) <span class="hljs-comment"># 输出 [1, 2, 3]</span>
</div></li></ul></code></pre>
<p>这里的单个 <code>*</code> 只能接收非关键字参数，也就是仅有参数值的哪些参数。如果想接受关键字参数，需要用 <code>**</code> 来表示：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args, **kwargs)</span>:</span>
</div></li><li><div class="code_line">    print(args)
</div></li><li><div class="code_line">    print(kwargs)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">foo(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>, a=<span class="hljs-number">61</span>, b=<span class="hljs-number">62</span>)
</div></li><li><div class="code_line"><span class="hljs-comment"># 第一行输出：(1, 2, 3)</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># 第二行输出：{'a': 61, 'b': 62}</span>
</div></li></ul></code></pre>
<p>类似的，字典变量传入函数只能作为单个参数，如果要想展开并被 <code>**kwargs</code> 识别，需要在字典前面加上两个星号 <code>**</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">d = {<span class="hljs-string">'a'</span>: <span class="hljs-number">61</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">62</span>}
</div></li><li><div class="code_line">foo(*a, **d)
</div></li></ul></code></pre>
<h4 id="section224">2.2.4 参数分类</h4>
<p>Python 中函数的参数可以分为两大类：</p>
<ol>
<li>定位参数（Positional）：表示参数的位置是固定的。比如对于函数 <code>foo(a, b)</code> 来说，<code>foo(1, 2)</code> 和 <code>foo(2, 1)</code> 就是截然不同的，a 和 b 的位置是固定的，不可随意调换。</li>
<li>关键词参数（Keyword）：表示参数的位置不重要，但是参数名称很重要。比如 <code>foo(a = 1, b = 2)</code> 和 <code>foo(b = 2, a = 1)</code> 的含义相同。</li>
</ol>
<p>有一种参数叫做仅限关键字（Keyword-Only）参数，比如考虑这个函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args, n=<span class="hljs-number">1</span>, **kwargs)</span>:</span>
</div></li><li><div class="code_line">    print(n)
</div></li></ul></code></pre>
<p>这个函数在调用时，如果参数 n 不指定名字，就会被前面的 <code>*args</code> 处理掉，如果指定的名字不是 n，又会被后面的 <code>**kwargs</code> 处理掉，所以参数 n 必须精确的以 <code>(n = xxx)</code> 的形式出现，也就是 Keyworld-Only。</p>
<h3 id="section23">2.3 函数内省</h3>
<p>在 2.2.2 节中，我们查看了函数变量的 <code>__defaults__</code> 属性，其实这就是一种内省，也就是在运行时动态的查看变量的信息。</p>
<p>前文说过，函数也是对象，因此函数的变量个数，变量类型都应该有办法获取到，如果你需要开发一个框架，也许会对函数有各种奇葩的检查和校验。 </p>
<p>以下面这个函数为例：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">g = <span class="hljs-number">1</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(m, *args, n, **kwargs)</span>:</span>
</div></li><li><div class="code_line">    a = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    b = <span class="hljs-number">2</span>
</div></li></ul></code></pre>
<p>首先可以获取函数名，函数所在模块的全局变量等：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo.__globals__   <span class="hljs-comment"># 全局变量，包含了 g = 1</span>
</div></li><li><div class="code_line">foo.__name__      <span class="hljs-comment"># foo</span>
</div></li></ul></code></pre>
<p>我们还可以看到函数的参数，函数内部的局部变量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">foo.__code__.co_varnames  <span class="hljs-comment"># ('m', 'n', 'args', 'kwargs', 'a', 'b')</span>
</div></li><li><div class="code_line">foo.__code__.co_argcount  <span class="hljs-comment"># 只计算参数个数，不考虑可变参数和仅限关键字参数，所以得到 1</span>
</div></li></ul></code></pre>
<p>或者用 <code>inspect</code> 模块来查看更详细的信息：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> inspect
</div></li><li><div class="code_line">sig = inspect.signature(foo)  <span class="hljs-comment"># 获取函数签名</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'m'</span>].kind      <span class="hljs-comment"># POSITIONAL_OR_KEYWORD 表示可以是定位参数或关键字参数</span>
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'args'</span>].kind   <span class="hljs-comment"># VAR_POSITIONAL 定位参数构成的数组</span>
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'n'</span>].kind      <span class="hljs-comment"># KEYWORD_ONLY 仅限关键字参数</span>
</div></li><li><div class="code_line">sig.parameters[<span class="hljs-string">'kwargs'</span>].kind <span class="hljs-comment"># VAR_KEYWORD 关键字参数构成的字典</span>
</div></li><li><div class="code_line">inspect.getfullargspec(foo)       
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到：ArgSpec(args=['m', 'n'], varargs='args', keywords='kwargs', defaults=None)</span>
</div></li></ul></code></pre>
<p>本节的新 API 比较多，但并不要求记住这些 API 的用法。再次强调，本文的写作目的是为了建立读者对 Python 的总体认知，了解 Python <strong>能做什么</strong>，至于怎么做，那是文档该做的事。</p>
<h3 id="section24">2.4 装饰器</h3>
<h4 id="section241">2.4.1 设计模式的消亡</h4>
<p>经典的设计模式有 23 个，虽然设计模式都是常用代码的总结，理论上来说与语法无关。但不得不承认的是，标准的设计模式在不同的语言中，有的因为语法的限制根本无法轻易实现（比如在 C 语言中实现组合模式），有的则因为语言的特定功能，变得冗余啰嗦。</p>
<p>以策略模式为例，有一个抽象的策略类，定义了策略的接口，然后使用者选择一个具体的策略类，构造他们的实例并且调用策略方法。具体代码可以参考：<a href="https://baike.baidu.com/item/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/646307?fr=aladdin" target="_blank">策略模式在百度百科的定义</a>。</p>
<p>然而这些对象本身并没有作用，它们仅仅是可以调用相同的方法而已，只不过在 Java 中，所有的任务都需要由对象来完成。即使策略本身就是一个函数，但也必须把它包裹在一个策略对象中。所以在 Python 中更优雅写法是直接把策略函数作为变量使用。不过这就引入一个问题，如何判断某个函数是个策略呢，毕竟在面向对象的写法中，只要检查它的父类是否是抽象的策略类即可。</p>
<p>也许你已经见过类似的写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@strategy</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">strategyA</span><span class="hljs-params">(n)</span>:</span>
</div></li><li><div class="code_line">    print(n * <span class="hljs-number">2</span>)
</div></li></ul></code></pre>
<p>下面就开始介绍装饰器。</p>
<h4 id="section242">2.4.2 装饰器的基本原理</h4>
<p>首先，装饰器是个函数，它的参数是被装饰的函数，返回值也是一个函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(origin_func)</span>:</span>  <span class="hljs-comment"># 这个参数是被装饰的函数</span>
</div></li><li><div class="code_line">    print(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 先输出点东西</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> origin_func  <span class="hljs-comment"># 把原函数直接返回</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-meta">@decorate    # 注意这里不是函数调用，所以不用加括号，也不用加被修饰的函数名</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sayHello()  <span class="hljs-comment"># 如果没有装饰器，只会打印 'Hello'，实际结果是打印 1 再打印 'Hello'</span>
</div></li></ul></code></pre>
<p>因此，使用装饰器的这种写法：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@decorate</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li></ul></code></pre>
<p>和下面这种写法是完全等价的， 初学者可以把装饰器在心中默默的转换成下一种写法，以方便理解：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">foo = decorate(foo)
</div></li></ul></code></pre>
<p>需要注意的是，装饰器函数 <code>decorate</code> 在模块被导入时就会执行，而被装饰的函数只在被调用时才会执行，也就是说即使不调用 <code>sayHello</code> 函数也会输出 1，但这样就不会输出 Hello 了。</p>
<p>有了装饰器，配合前面介绍的函数对象，函数内省，我们可以做很多有意思的事，至少判断上一节中某个函数是否是策略是非常容易的。在装饰器中，我们还可以把策略函数都保存到数组中， 然后提供一个“推荐最佳策略”的功能， 其实就是遍历执行所有的策略，然后选择最好的结果。</p>
<h4 id="section243">2.4.3 装饰器进阶</h4>
<p>上一节中的装饰器主要是为了介绍工作原理，它的功能非常简单，并不会改变被装饰函数的运行结果，仅仅是在导入时装饰函数，然后输出一些内容。换句话说，即使不执行函数，也要执行装饰器中的 <code>print</code> 语句，而且因为直接返回函数的缘故，其实没有真正的起到装饰的效果。</p>
<p>如何做到装饰时不输出任何内容，仅在函数执行最初输出一些东西呢？这是常见的 AOP（面向切片编程） 的需求。这就要求我们不能再直接返回被装饰的函数，而是应该返回一个新的函数，所以新的装饰器需要这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(origin_func)</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_func</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">        origin_func()
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> new_func
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">decorate
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sayHello() <span class="hljs-comment"># 运行结果不变，但是仅在调用函数 sayHello 时才会输出 1</span>
</div></li></ul></code></pre>
<p>这个例子的工作原理是，<code>sayHello</code> 函数作为参数 <code>origin_func</code> 被传到装饰器中，经过装饰以后，它实际上变成了 <code>new_func</code>，会先输出 1 再执行原来的函数，也就是 <code>sayHello</code>。</p>
<p>这个例子很简陋，因为我们知道了 <code>sayHello</code> 函数没有参数，所以才能定义一个同样没有参数的替代者：<code>nwe_func</code>。如果我们在开发一个框架，要求装饰器能对任意函数生效，就需要用到 2.2.3 中介绍的 <code>*</code> 和 <code>**</code> 这种不定参数语法了。</p>
<p>如果查看 <code>sayHello</code> 函数的名字，得到的结果将是 <code>new_func</code>：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">sayHello.__name__  <span class="hljs-comment"># new_func</span>
</div></li></ul></code></pre>
<p>这是很自然的，因为本质上其实执行的是：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">new_func = decorate(sayHello)
</div></li></ul></code></pre>
<p>而装饰器的返回结果是另一个函数 <code>new_func</code>，两者仅仅是运行结果类似，但两个对象并没有什么关联。</p>
<p>所以为了处理不定参数，并且不改变被装饰函数的外观（比如函数名），我们需要做一些细微的修补工作。这些工作都是模板代码，所以 Python 早就提供了封装：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> functools
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(origin_func)</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @functools.wraps(origin_func)  # 这是 Python 内置的装饰器</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_func</span><span class="hljs-params">(*args, **kwargs)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-number">1</span>)
</div></li><li><div class="code_line">        origin_func(*args, **kwargs)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> new_func
</div></li></ul></code></pre>
<h4 id="section244">2.4.4 装饰器工厂</h4>
<p>在 2.4.2 节的代码注释中我解释过，装饰器后面不要加括号，被装饰的函数自动作为参数，传递到装饰器函数中。如果加了括号和参数，就变成手动调用装饰器函数了，大多数时候这与预期不符（因为装饰器的参数一般都是被装饰的函数）。</p>
<p>不过装饰器可以接受自定义的参数，然后返回另一个装饰器，这样外面的装饰器实际上就是一个装饰器工厂，可以根据用户的参数，生成不同的装饰器。还是以上面的装饰器为例，我希望输出的内容不是固定的 1，而是用户可以指定的，代码就应该这么写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> functools
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span><span class="hljs-params">(content)</span>:</span>                        <span class="hljs-comment"># 这其实是一个装饰器工厂</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">real_decorator</span><span class="hljs-params">(origin_func)</span>:</span>          <span class="hljs-comment"># 这才是刚刚的装饰器</span>
</div></li><li><div class="code_line"><span class="hljs-meta">        @functools.wraps(origin_func)</span>
</div></li><li><div class="code_line">        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_func</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">            print(<span class="hljs-string">'You said '</span> + str(content)) <span class="hljs-comment"># 现在输出内容可以由用户指定</span>
</div></li><li><div class="code_line">            origin_func()
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> new_func                       <span class="hljs-comment"># 在装饰器里，返回的是新的函数</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> real_decorator                     <span class="hljs-comment"># 装饰器工厂返回的是装饰器</span>
</div></li></ul></code></pre>
<p>装饰器工厂和装饰器的区别在于它可以接受参数，返回一个装饰器：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-meta">@decorate(2017)</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">sayHello()
</div></li></ul></code></pre>
<p>其实等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">real_decorator = decorate(<span class="hljs-number">2017</span>)      <span class="hljs-comment"># 通过装饰器工厂生成装饰器</span>
</div></li><li><div class="code_line">new_func = real_decorator(sayHello)  <span class="hljs-comment"># 正常的装饰器工作逻辑</span>
</div></li><li><div class="code_line">new_func()                           <span class="hljs-comment"># 调用的是装饰过的函数</span>
</div></li></ul></code></pre>
<h2 id="section3">3 面向对象</h2>
<h3 id="section31">3.1 对象内存管理</h3>
<h4 id="section311">3.1.1 对象不是盒子</h4>
<p>C 语言中我们定义变量用到的语法是：</p>
<pre><code class="c language-c hljs cpp"><ul><li><div class="code_line"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;
</div></li></ul></code></pre>
<p>这背后的含义是定义了一个 <code>int</code> 类型的变量 <code>a</code>，相当于申请了一个名为 <code>a</code> 的盒子（存储空间），里面装了数字 1。<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/d488dd71e0be57efe82f076c550e6a22.png" alt=""></p>
<p>然后我们改变 <code>a</code> 的值：<code>a = 2;</code>，可以打印 <code>a</code> 的地址来证明它并没有发生变化。所以只是盒子里装的内容（指针指向的位置）发生了改变：<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/63785ebe7adfb514dcc88d4b96a34cad.png" alt=""></p>
<p>但是在 Python 中，变量不是盒子。比如同样的定义变量：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = <span class="hljs-number">1</span>
</div></li></ul></code></pre>
<p>这里就不能把 <code>a</code> 理解为 <code>int</code> 类型的变量了。因为在 Python 中，变量没有类型，值才有，或者说只有对象才有类型。因为即使是数字 1，也是 <code>int</code> 类的实例，而变量 <code>a</code> 更像是给这个对象贴的一个标签。</p>
<p><img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/6d30c0da2d2108ccc071c8751c4e7c1a.png" alt=""><br>
如果执行赋值语句 <code>a = 2</code>，相当于把标签 a 贴在另一个对象上：<br>
<img src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/05a4f3b25b942f0656f1759eb5b6dbc6.png" alt=""></p>
<p>基于这个认知，我们现在应该更容易理解 2.2.1 节中所说的函数传参规则了。如果传入的是不可变类型，比如 <code>int</code>，改变它的值实际上就是把标签挂在新的对象上，自然不会改变原来的参数。如果是可变类型，并且做了修改，那么函数中的变量和外面的变量都是指向同一个对象的标签，所以会共享变化。</p>
<h4 id="section312">3.1.2 默认浅复制</h4>
<p>根据上一节的描述，直接把变量赋值给另一个变量， 还算不上复制：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">b = a
</div></li><li><div class="code_line">b == a   <span class="hljs-comment"># True，等同性校验，会调用 __eq__ 函数，这里只判断内容是否相等</span>
</div></li><li><div class="code_line">b <span class="hljs-keyword">is</span> a   <span class="hljs-comment"># True，一致性校验，会检查是否是同一个对象，调用 hash() 函数，可以理解为比较指针</span>
</div></li></ul></code></pre>
<p>可见不仅仅数组相同，就连变量也是相同的，可以把 b 理解为 a 的别名。</p>
<p>如果用切片，或者数组的构造函数来创建新的数组，得到的是原数组的浅拷贝：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
</div></li><li><div class="code_line">b = list(a)
</div></li><li><div class="code_line">b == a   <span class="hljs-comment"># True，因为数组内容相同</span>
</div></li><li><div class="code_line">b <span class="hljs-keyword">is</span> a   <span class="hljs-comment"># False，现在 a 和 b 是两个变量，恰好指向同一个数组对象</span>
</div></li></ul></code></pre>
<p>但如果数组中的元素是可变的，可以看到这些元素并没有被完全拷贝：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">a = [[<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>]]
</div></li><li><div class="code_line">b = list(a)
</div></li><li><div class="code_line">b[<span class="hljs-number">0</span>].append(<span class="hljs-number">2</span>)
</div></li><li><div class="code_line">a <span class="hljs-comment"># 得到 [[1, 2], [2], [3]]，因为 a[0] 和 b[0] 其实还是挂在相同对象上的不同标签</span>
</div></li></ul></code></pre>
<p>如果想要深拷贝，需要使用 <code>copy</code> 模块的 <code>deepcopy</code> 函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-keyword">import</span> copy 
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">b = copy.deepcopy(a)
</div></li><li><div class="code_line">b[<span class="hljs-number">0</span>].append(<span class="hljs-number">2</span>)
</div></li><li><div class="code_line">b  <span class="hljs-comment"># 变成了 [[1, 2], [2], [3]]</span>
</div></li><li><div class="code_line">a  <span class="hljs-comment"># 还是 [[1], [2], [3]]</span>
</div></li></ul></code></pre>
<p>此时，不仅仅是每个元素的引用被拷贝，就连每个元素自己也被拷贝。所以现在的 <code>a[0]</code> 和 <code>b[0]</code> 是指向两个不同对象的两个不同变量（标签），自然就互不干扰了。</p>
<p>如果要实现自定义对象的深复制，只要实现 <code>__deepcopy__</code> 函数即可。这个概念在几乎所有面向对象的语言中都会存在，就不详细介绍了。</p>
<h4 id="section313">3.1.3 弱引用</h4>
<p>Python 内存管理使用垃圾回收的方式，当没有指向对象的引用时，对象就会被回收。然而对象一直被持有也并非什么好事，比如我们要实现一个缓存，预期目标是缓存中的内容随着真正对象的存在而存在，随着真正对象的消失而消失。如果因为缓存的存在，导致被缓存的对象无法释放，就会导致内存泄漏。</p>
<p>Python 提供了语言级别的支持，我们可以使用 <code>weakref</code> 模块，它提供了 <code>weakref.WeakValueDictionary</code> 这个弱引用字典来确保字典中的值不会被引用。如果想要获取某个对象的弱引用，可以使用 <code>weakref.ref(obj)</code>  函数。</p>
<h3 id="section32python">3.2 Python 风格的对象</h3>
<h4 id="section321">3.2.1 静态函数与类方法</h4>
<p>静态函数其实和类的方法没什么关系，它只是恰好定义在类的内部而已，所以这里我用函数（function) 来形容它。它可以没有参数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @staticmethod   # 用 staticmethod 这个修饰器来表明函数是静态的</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'Hello'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">Person.sayHello() <span class="hljs-comment"># 输出 'Hello`</span>
</div></li></ul></code></pre>
<p>静态函数的调用方式是类名加上函数名。类方法的调用方式也是这样，唯一的不同是需要用 <code>@staticmethod</code> 修饰器，而且方法的第一个参数必须是类：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @classmethod    # 用 classmethod 这个修饰器来表明这是一个类方法</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sayHi</span><span class="hljs-params">(cls)</span>:</span>
</div></li><li><div class="code_line">        print(<span class="hljs-string">'Hi: '</span> + cls.__name__)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">Person.sayHi() <span class="hljs-comment"># 输出 'Hi: Person`</span>
</div></li></ul></code></pre>
<p>类方法和静态函数的调用方法一致，在定义时除了修饰器不一样，唯一的区别就是类方法需要多声明一个参数。这样看起来比较麻烦，但静态函数无法引用到类对象，自然就无法访问类的任何属性。</p>
<p>于是问题来了，静态函数有何意义呢？有的人说类名可以提供命名空间的概念，但在我看来这种解释并不成立，因为每个 Python 文件都可以作为模块被别的模块引用，把静态函数从类里抽取出来，定义成全局函数，也是有命名空间的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-comment"># 在 module1.py 文件中：</span>
</div></li><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">global</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span> 
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Util</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @staticmethod</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-comment"># 在 module2.py 文件中：</span>
</div></li><li><div class="code_line"><span class="hljs-keyword">import</span> module1
</div></li><li><div class="code_line">module1.<span class="hljs-keyword">global</span>()        <span class="hljs-comment"># 调用全局函数</span>
</div></li><li><div class="code_line">module1.Util.helper()   <span class="hljs-comment"># 调用静态函数</span>
</div></li></ul></code></pre>
<p>从这个角度看，定义在类中的静态函数不仅不具备命名空间的优点，甚至调用语法还更加啰嗦。对此，我的理解是：<strong>静态函数可以被继承、重写，但全局函数不行</strong>，由于 Python 中的函数是一等公民，因此很多时候用函数替代类都会使代码更加简洁，但缺点就是无法继承，后面还会有更多这样的例子。</p>
<h4 id="section322attribute">3.2.2 属性 attribute</h4>
<p>Python （等多数动态语言）中的类并不像 C/OC/Java 这些静态语言一样，需要预先定义属性。我们可以直接在初始化函数中创建属性：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.name  <span class="hljs-comment"># 值是 'bestswifter'</span>
</div></li></ul></code></pre>
<p>由于 <code>__init__</code> 函数是运行时调用的，所以我们可以直接给对象添加属性：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs.age = <span class="hljs-number">22</span>
</div></li><li><div class="code_line">bs.age  <span class="hljs-comment"># 因为刚刚赋值了，所以现在取到的值是 22</span>
</div></li></ul></code></pre>
<p>如果访问一个不存在的属性，将会抛出异常。从以上特性来看，对象其实和字典非常相似，但这种过于灵活的特性其实蕴含了潜在的风险。比如某个封装好的父类中定义了许多属性， 但是子类的使用者并不一定清楚这一点，他们很可能会不小心就重写了父类的属性。一种隐藏并保护属性的方式是在属性前面加上两个下划线：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        self.__name = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs.__name          <span class="hljs-comment"># 这样是无法获取属性的</span>
</div></li><li><div class="code_line">bs._Person__name   <span class="hljs-comment"># 这样还是可以读取属性</span>
</div></li></ul></code></pre>
<p>这是因为 Python 会自动处理以双下划线开头的属性，把他们重名为 <code>_Classname__attrname</code> 的格式。由于 Python 对象的所有属性都保存在实例的 <code>__dict__</code>  属性中，我们可以验证一下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs = Person()
</div></li><li><div class="code_line">bs.__dict__ 
</div></li><li><div class="code_line"><span class="hljs-comment"># 得到 {'_Person__name': 'bestswifter'}</span>
</div></li></ul></code></pre>
<p>但很多人并不认可通过名称改写（name mangling) 的方式来存储私有属性，原因很简单，只要知道改写规则，依然<strong>很容易的</strong>就能读写私有属性。与其自欺欺人，不如采用更简单，更通用的方法，比如给私有属性前面加上单个下划线 <code>_</code>。</p>
<p>注意，以单个下划线开头的属性不会触发任何操作，完全靠自觉与共识。<strong>任何稍有追求的 Python 程序员，都不应该读写这些属性。</strong></p>
<h4 id="section323property">3.2.3 特性 property</h4>
<p>使用过别的面向对象语言的读者应该都清楚属性的 <code>getter</code> 和 <code>setter</code> 函数的重要性。它们封装了属性的读写操作，可以添加一些额外的逻辑，比如校验新值，返回属性前做一些修饰等等。最简陋的 <code>getter</code> 和 <code>setter</code> 就是两个普通函数：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self.name.upper()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span><span class="hljs-params">(self, new_name)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> isinstance(new_name, str):
</div></li><li><div class="code_line">            self.name = new_name.lower()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.get_name()   <span class="hljs-comment"># 得到大写的名字： 'BESTSWIFTER'</span>
</div></li><li><div class="code_line">bs.set_name(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 由于新的名字不是字符串，所以无法赋值</span>
</div></li><li><div class="code_line">bs.get_name()   <span class="hljs-comment"># 还是老的名字： 'BESTSWIFTER'</span>
</div></li></ul></code></pre>
<p>工作虽然完成了，但方法并不高明。在 1.2.3 节中我们就见识到了 Python 的一个特点：“内部高度封装，完全对外透明”。这里手动调用 <code>getter</code> 和 <code>setter</code> 方法显得有些愚蠢、啰嗦，比如对比下面的两种写法，在变量名和函数名很长的情况下，差距会更大：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs.name += <span class="hljs-string">'1995'</span>
</div></li><li><div class="code_line">bs.set_name(bs.get_name() + <span class="hljs-string">'1995'</span>)
</div></li></ul></code></pre>
<p>Python 提供了 <code>@property</code> 关键字来装饰 <code>getter</code> 和 <code>setter</code> 方法，这样的好处是可以直接使用点语法，了解 Objective-C 的读者对这一特性一定倍感亲切：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line"><span class="hljs-meta">    @property                        # 定义 getter</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self)</span>:</span>                  <span class="hljs-comment"># 函数名就是点语法访问的属性名</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self._name.upper()    <span class="hljs-comment"># 现在真正的属性是 _name 了</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line"><span class="hljs-meta">    @name.setter                     # 定义 setter</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(self, new_name)</span>:</span>        <span class="hljs-comment"># 函数名不变</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> isinstance(new_name, str):
</div></li><li><div class="code_line">            self._name = new_name.lower()  <span class="hljs-comment"># 把值存到私有属性 _name 里</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.name      <span class="hljs-comment"># 其实调用了 name 函数，得到大写的名字： 'BESTSWIFTER'</span>
</div></li><li><div class="code_line">bs.name = <span class="hljs-number">1</span>  <span class="hljs-comment"># 其实调用了 name 函数，因为类型不符，无法赋值</span>
</div></li><li><div class="code_line">bs.name      <span class="hljs-comment"># 还是老的名字： 'BESTSWIFTER'</span>
</div></li></ul></code></pre>
<p>我们已经在 2.4 节详细学习了装饰器，应该能意识到这里的 <code>@property</code> 和 <code>@xxx.setter</code> 都是装饰器。因此上述写法实际上等价于：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> self._name.upper()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span><span class="hljs-params">(self, new_name)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> isinstance(new_name, str):
</div></li><li><div class="code_line">            self._name = new_name.lower()
</div></li><li><div class="code_line">    <span class="hljs-comment"># 以上是老旧的 getter 和 setter 定义</span>
</div></li><li><div class="code_line">    <span class="hljs-comment"># 如果不用 @property，可以定义一个 property 类的实例</span>
</div></li><li><div class="code_line">    name = property(get_name, set_name)
</div></li></ul></code></pre>
<p>可见，特性的本质是给类创建了一个类属性，它是 <code>property</code> 类的实例，构造方法中需要把 <code>getter</code>、<code>setter</code> 等函数传入，我们可以打印一下类的 <code>name</code> 属性来证明：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">Person.name  <span class="hljs-comment"># &lt;property object at 0x107c99868&gt;</span>
</div></li></ul></code></pre>
<p>理解特性的工作原理至关重要。以这里的 <code>name</code> 特性为例，我们访问了对象的 <code>name</code> 属性，但是它并不存在，所以会尝试访问类的 <code>name</code> 属性，这个属性是 <code>property</code> 类的实例，会对读写操作做特殊处理。这也意味着，如果我们重写了类的 <code>name</code> 属性，那么对象的读写方法就不会生效了：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">bs = Person()
</div></li><li><div class="code_line">Person.name = <span class="hljs-string">'hello'</span>
</div></li><li><div class="code_line">bs.name  <span class="hljs-comment"># 实例并没有 name 属性，因此会访问到类的属性 name，现在的值是 'hello` 了</span>
</div></li></ul></code></pre>
<p>如果访问不存在的属性，默认会抛出异常，但如果实现了 <code>__getattr__</code> 函数，还有一次挽救的机会：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, attr)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name)</span>:</span>
</div></li><li><div class="code_line">        self.name = name
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">bs = Person(<span class="hljs-string">'bestswifter'</span>)
</div></li><li><div class="code_line">bs.name    <span class="hljs-comment"># 直接访问属性</span>
</div></li><li><div class="code_line">bs.age     <span class="hljs-comment"># 得到 0，这是 __getattr__ 方法提供的默认值</span>
</div></li><li><div class="code_line">bs.age = <span class="hljs-number">1</span> <span class="hljs-comment"># 动态给属性赋值</span>
</div></li><li><div class="code_line">bs.age     <span class="hljs-comment"># 得到 1，注意！！！这时候就不会再调用 __getattr__ 方法了</span>
</div></li></ul></code></pre>
<p>由于 <code>__getattr__</code> 只是兜底策略，处理一些异常情况，并非每次都能被调用，所以不能把重要的业务逻辑写在这个方法中。</p>
<h4 id="section324">3.2.4 特性工厂</h4>
<p>在上一节中，我们利用特性来封装 <code>getter</code> 和 <code>setter</code>，对外暴露统一的读写接口。但有些 <code>getter</code> 和 <code>setter</code> 的逻辑其实是可以复用的，比如商品的价格和剩余数量在赋值时，都必须是大于 0 的数字。这时候如果每次都要写一遍 <code>setter</code>，代码就显得很冗余，所以我们需要一个能批量生产特性的函数。由于我们已经知道了特性是 <code>property</code> 类的实例，而且是类的属性，所以代码可以这样写：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quantity</span><span class="hljs-params">(storage_name)</span>:</span>  <span class="hljs-comment"># 定义 getter 和 setter</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_getter</span><span class="hljs-params">(instance)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[storage_name]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_setter</span><span class="hljs-params">(instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            <span class="hljs-comment"># 把值保存在实例的 __dict__ 字典中</span>
</div></li><li><div class="code_line">            instance.__dict__[storage_name] = value 
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> property(qty_getter, qty_setter) <span class="hljs-comment"># 返回 property 的实例</span>
</div></li></ul></code></pre>
<p>有了这个特性工厂，我们可以这样来定义特性：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>:</span>
</div></li><li><div class="code_line">    price = quantity(<span class="hljs-string">'price'</span>)
</div></li><li><div class="code_line">    number = quantity(<span class="hljs-string">'number'</span>)
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = Item()
</div></li><li><div class="code_line">i.price = <span class="hljs-number">-1</span> 
</div></li><li><div class="code_line"><span class="hljs-comment"># Traceback (most recent call last):</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ...</span>
</div></li><li><div class="code_line"><span class="hljs-comment"># ValueError: value must be &gt; 0</span>
</div></li></ul></code></pre>
<p>作为追求简洁的程序员，我们不禁会问，在 <code>price = quantity('price')</code> 这行代码中，属性名重复了两次，能不能在 <code>quantity</code> 函数中自动读取左边的属性名呢，这样代码就可以简化成 <code>price = quantity()</code> 了。</p>
<p>答案显然是否定的，因为右边的函数先被调用，然后才能把结果赋值给左边的变量。不过我们可以采用迂回策略，变相的实现上面的需求：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quantity</span><span class="hljs-params">()</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">try</span>:
</div></li><li><div class="code_line">        quantity.count += <span class="hljs-number">1</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">except</span> AttributeError:
</div></li><li><div class="code_line">        quantity.count = <span class="hljs-number">0</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    storage_name = <span class="hljs-string">'_{}:{}'</span>.format(<span class="hljs-string">'quantity'</span>, quantity.count)  
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_getter</span><span class="hljs-params">(instance)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[storage_name]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">qty_setter</span><span class="hljs-params">(instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            instance.__dict__[storage_name] = value
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li><li><div class="code_line">    <span class="hljs-keyword">return</span> property(qty_getter, qty_setter)
</div></li></ul></code></pre>
<p>这段代码中我们利用了两个技巧。首先函数是一等公民， 所以函数也是对象，自然就有属性。所以我们利用 <code>try ... except</code> 很容易的就给函数工厂添加了一个计数器对象 <code>count</code>，它每次调用都会增加，然后再拼接成存储时用的键 <code>storage_name</code> ，并且可以保证不同 <code>property</code> 实例的存储键名各不相同。</p>
<p>其次，<code>storage_name</code> 在 <code>getter</code> 和 <code>setter</code> 函数中都被引用到，而这两个函数又被 <code>property</code> 的实例引用，所以 <code>storage_name</code> 会因为被持有而延长生命周期。这也正是闭包的一大特性：能够捕获自由变量并延长它的生命周期和作用域。</p>
<p>我们来验证一下：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span>:</span>
</div></li><li><div class="code_line">    price = quantity()
</div></li><li><div class="code_line">    number = quantity()
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">i = Item()
</div></li><li><div class="code_line">i.price = <span class="hljs-number">1</span>
</div></li><li><div class="code_line">i.number = <span class="hljs-number">2</span>
</div></li><li><div class="code_line">i.price     <span class="hljs-comment"># 得到 1，可以正常访问</span>
</div></li><li><div class="code_line">i.number    <span class="hljs-comment"># 得到 2，可以正常访问</span>
</div></li><li><div class="code_line">i.__dict__  <span class="hljs-comment"># {'_quantity:0': 1, '_quantity:1': 2}</span>
</div></li></ul></code></pre>
<p>可见现在存储的键名可以被正确地自动生成。</p>
<h4 id="section325">3.2.5 属性描述符</h4>
<p>文件描述符的作用和特性工厂一样，都是为了批量的应用特性。它的写法也和特性工厂非常类似：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quantity</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, storage_name)</span>:</span>
</div></li><li><div class="code_line">        self.storage = storage_name
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__get__</span><span class="hljs-params">(self, instance, owner)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">return</span> instance.__dict__[self.storage]
</div></li><li><div class="code_line">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__set__</span><span class="hljs-params">(self, instance, value)</span>:</span>
</div></li><li><div class="code_line">        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:
</div></li><li><div class="code_line">            instance.__dict__[self.storage] = value
</div></li><li><div class="code_line">        <span class="hljs-keyword">else</span>:
</div></li><li><div class="code_line">            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'value must be &gt; 0'</span>)
</div></li></ul></code></pre>
<p>主要有以下几个改动：</p>
<ol>
<li>不用返回 <code>property</code> 类的实例了，因此 <code>getter</code> 和 <code>setter</code> 方法的名字是固定的，这样才能满足协议。</li>
<li><code>__get__</code> 方法的第一个参数是描述符类 <code>Quantity</code> 的实例，第二个参数 <code>self</code> 是要读取属性的实例，比如上面的 <code>i</code>，也被称作托管实例。第三个参数是托管类，也就是 <code>Item</code>。</li>
<li><code>__set__</code> 方法的前两个参数含义类似，第三个则是要读取的属性名，比如 <code>price</code>。</li>
</ol>
<p>和特性工厂类似，属性描述符也可以实现 <code>storage_name</code> 的自动生成，这里就不重复代码了。看起来属性描述符和特性工厂几乎一样，但由于属性描述符是类，它就可以继承。比如这里的 <code>Quantity</code> 描述符有两个功能：自动存储和值的校验。自动存储是一个非常通用的逻辑，而值的校验是可变的业务逻辑，所以我们可以先定义一个 <code>AutoStorage</code> 描述符来实现自动存储功能，然后留下一个空的 <code>validate</code> 函数交给子类去重写。</p>
<p>而特性工厂作为函数，自然就没有上述功能，这两者的区别类似于 3.2.1 节中介绍的静态函数与全局函数的区别。</p>
<h4 id="section326">3.2.6 实例属性的查找顺序</h4>
<p>我们知道类的属性都会存储在 <code>__dict__</code> 字典中，即使没有显式的给属性赋值，但只要字典里面有这个字段，也是可以读取到的：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span>
</div></li><li><div class="code_line">    <span class="hljs-keyword">pass</span>
</div></li><li><div class="code_line">
</div></li><li><div class="code_line">p = Person()
</div></li><li><div class="code_line">p.__dict__[<span class="hljs-string">'name'</span>] = <span class="hljs-string">'bestswifter'</span>
</div></li><li><div class="code_line">p.name  <span class="hljs-comment"># 不会报错，而是返回字典中的值，'bestswifter'</span>
</div></li></ul></code></pre>
<p>但我们在特性工厂和属性描述符的实现中，都是直接把属性的值存储在 <code>__dict__</code> 中，而且键就是属性名。之前我们还介绍过，特性的工作原理是没有直接访问实例的属性，而是读取了 <code>property</code> 的实例。那直接把值存在 <code>__dict__</code> 中，会不会导致特性失效，直接访问到原始内容呢？从之前的实践结果来看，答案是否定的，要解释这个问题，我们需要搞明白访问实例属性的查找顺序。</p>
<p>假设有这么一段代码：</p>
<pre><code class="python language-python hljs"><ul><li><div class="code_line">o = cls()   <span class="hljs-comment"># 假设 o 是 cls 类的实例</span>
</div></li><li><div class="code_line">o.attr      <span class="hljs-comment"># 试图访问 o 的属性 attr</span>
</div></li></ul></code></pre>
<p>再对上一节中的属性描述符做一个简单的分类：</p>
<ol>
<li>覆盖型描述符：定义了 <code>__set__</code> 方法的描述符</li>
<li>非覆盖型描述符：没有定义 <code>__set__</code> 方法的描述符</li>
</ol>
<p>在执行 <code>o.attr</code> 时，查找顺序如下：</p>
<ol>
<li>如果 <code>attr</code> 出现在 <code>cls</code> 或父类的 <code>__dict__</code> 中，且 <code>attr</code> 是覆盖型描述符，那么调用 <code>__get__</code> 方法。</li>
<li>否则，如果 <code>attr</code> 出现在 <code>o</code> 的<code>__dict__</code> 中，返回 <code>o.__dict__[attr]</code></li>
<li>否则，如果<code>attr</code> 出现在 <code>cls</code> 或父类的 <code>__dict__</code> 中，如果 <code>attr</code> 是非覆盖型描述符，那么调用 <code>__get__</code> 方法。</li>
<li>否则，如果没有非覆盖型描述符，直接返回 <code>cls.__dict__[attr]</code></li>
<li>否则，如果 <code>cls</code> 实现了 <code>__getattr__</code> 方法，调用这个方法</li>
<li>抛出 <code>AttributeError</code></li>
</ol>
<p>所以，在访问类的属性时，覆盖型描述符的优先级是高于直接存储在 <code>__dict__</code> 中的值的。</p>
<h3 id="section33">3.3 多继承</h3>
<p>本节内容部分摘自我的这篇文章：<a href="http://www.jianshu.com/p/fc105512bf40" target="_blank">从 Swift 的面向协议编程说开去</a>，本节聊的是多继承在 Python 中的知识，如果想阅读关于多继承的讨论，请参考原文。</p>
<h4 id="section331">3.3.1 多继承的必要性</h4>
<p>很多语言类的书籍都会介绍，多继承是个危险的行为。诚然，狭义上的多继承在绝大多数情况下都是不合理的。这里所谓的 <strong>“狭义”</strong>，指的是一个类拥有多个父类。我们要明确一个概念：继承的目的不是代码复用，而是声明一种 <code>is a</code> 的关系，代码复用只是 <code>is a</code> 关系的一种外在表现。</p>
<p>因此，如果你需要狭义上的多继承，还是应该先问问自己，真的存在这么多 <code>is a</code> 的关系么？你是需要声明这种关系，还是为了代码复用。如果是后者，有很多更优雅的解决方案，因为多继承的一个直接问题就是菱形问题（Diamond Problem）。</p>
<p>但是广义上的多继承是必须的，不能因为害怕多继承的问题就忽略多继承的优点。<strong>广义多继承</strong> 指的是通过定义接口（Interface）以及接口方法的默认实现，形成“一个父类，多个接口”的模式，最终实现代码的复用。当然，不是每个语言都有接口的概念，比如 Python 里面叫 Mixin，会在 3.3.3 节中介绍。</p>
<p>广义上的多继承非常常见，有一些教科书式的例子，比如动物可以按照哺乳动物，爬行动物等分类，也可以按照有没有翅膀来分类。某一个具体的动物可能满足上述好几类。在实际的开发中也到处都是广义多继承的使用场景，比如 iOS 或者安卓开发中，系统控件的父类都是固定的，如果想让他们复用别的父类的代码，就会比较麻烦。</p>
<h4 id="section332python">3.3.2 Python 的多继承</h4></div>
                </div>
                <div class="topic-tags">
    <label><a href="https://xiaozhuanlan.com/tags/%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">入门指南</a></label>
    <label><a href="https://xiaozhuanlan.com/tags/Python" target="_blank" rel="noopener">Python</a></label>
</div>
                <div class="topic-vertical-btns hidden">
  <button class="button xzl-primary-btn topic-favorite-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-topic-id="1435" data-favorite="false" data-topic-count="false">
    <span class="xzl-default-state-btn">
      <span class="svgIcon svgIcon--heart svgIcon--25px is-flushLeft">
        <svg class="svgIcon-use topic-unfavorited " width="25" height="25" viewbox="0 0 25 25">
          <path d="M12.5 21a.492.492 0 0 1-.327-.122c-.278-.24-.61-.517-.978-.826-2.99-2.5-7.995-6.684-7.995-10.565C3.2 6.462 5.578 4 8.5 4c1.55 0 3 .695 4 1.89a5.21 5.21 0 0 1 4-1.89c2.923 0 5.3 2.462 5.3 5.487 0 3.97-4.923 8.035-7.865 10.464-.42.35-.798.66-1.108.93a.503.503 0 0 1-.327.12zM8.428 4.866c-2.414 0-4.378 2.05-4.378 4.568 0 3.475 5.057 7.704 7.774 9.975.243.2.47.39.676.56.245-.21.52-.43.813-.68 2.856-2.36 7.637-6.31 7.637-9.87 0-2.52-1.964-4.57-4.377-4.57-1.466 0-2.828.76-3.644 2.04-.1.14-.26.23-.43.23-.18 0-.34-.09-.43-.24-.82-1.27-2.18-2.03-3.65-2.03z" fill-rule="evenodd"/>
          
        </svg>
        <svg class="svgIcon-use topic-favorited hidden" width="25" height="25" viewbox="0 0 25 25">
          <path d="M12.5 21a.492.492 0 0 1-.327-.122c-.278-.24-.61-.517-.978-.826-2.99-2.5-7.995-6.684-7.995-10.565C3.2 6.462 5.578 4 8.5 4c1.55 0 3 .695 4 1.89a5.21 5.21 0 0 1 4-1.89c2.923 0 5.3 2.462 5.3 5.487 0 3.97-4.923 8.035-7.865 10.464-.42.35-.798.66-1.108.93a.503.503 0 0 1-.327.12z" fill-rule="evenodd"/>
          
        </svg>
      </span>
    </span>
  </button>
</div>
                <div class="topic-rights">
                  <span>© 著作权归作者所有</span>
                </div>
                <div class="reward-partial">
      <div class="reward-partial-for-tip">
  <span class="tip">这个作品真棒，我要支持一下！</span>
</div>
<div class="reward-partial-for-reward">
      <button class="button button--small reward-btn  xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn">
        <span class="button-label  xzl-default-state-btn ">
          赞赏
        </span>
      </button>
</div>
<div class="rewarded-users">
    <a href="https://xiaozhuanlan.com/u/5262714674" target="_blank" rel="noopener">
      <img class="user-avatar avatar-present" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/31469b3ad08c72861469f732a43e61ea.jpg!small" alt="31469b3ad08c72861469f732a43e61ea">
</a></div>
    </div>
    <div class="topic-footer">
  <div class="favorite-partial topic-favorite-btn-item">
    <button class="button xzl-primary-btn topic-favorite-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-topic-id="1435" data-favorite="false" data-topic-count="false">
      <span class="xzl-default-state-btn">
        <span class="svgIcon svgIcon--heart topic-btn">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20px" height="20px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use topic-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use topic-unfavorited-hover ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -347.000000)" stroke="#2D2E2F">
            <path d="M211.978949,366.95489 C211.926485,366.972967 211.87389,366.990773 211.821167,367.008306 L212.136732,367.008306 C212.084007,366.990772 212.031412,366.972966 211.978949,366.95489 Z M201.505033,353.185818 C201.502008,353.093677 201.501932,353.092246 201.499329,353.043074 L201,353.068966 L201,353.568966 L201.482808,353.568966 L201.505033,353.185818 Z M211.978949,366.95489 C206.754996,365.155011 202.831944,360.676332 201.767482,355.227148 C201.586643,354.622169 201.5,354.041319 201.5,353.448276 C201.5,353.363399 201.501775,353.278748 201.505314,353.194357 C201.505217,353.191426 201.505124,353.188582 201.505033,353.185818 L201.510132,353.09792 C201.69196,349.963332 204.293503,347.5 207.448276,347.5 C209.044187,347.5 210.539021,348.130705 211.647055,349.234935 L212,349.586669 L212.352945,349.234935 C213.460979,348.130705 214.955813,347.5 216.551724,347.5 C219.836866,347.5 222.5,350.163134 222.5,353.448276 C222.5,354.151387 222.378189,354.837062 222.142953,355.483227 C220.970297,360.856032 217.094635,365.192275 211.978949,366.95489 Z" id="icon_like_hover"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20px" height="20px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use topic-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </span>
      </span>
    </button>
    <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
      赞
    </button>
  </div>
  <div class="topic-other-btns ">
    <div class="xzl-topic-btn topic-collect-btn-item">
      <button class="button xzl-button-chrome-less topic-collect  topic-collect-btn is-touchIconFadeInPulse  button--withIcon button--withSvgIcon button--bookmark js-bookmarkButton" data-topic-id="1435" data-collect="false" data-topic-count="false">
        <span class="xzl-default-state-btn topic-uncollected ">
          <span class="svgIcon svgIcon--bookmark topic-btn">
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="21px" viewbox="0 0 16 22" version="1.1" class="svgIcon-use unmark-btn">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-534.000000, -222.000000)" stroke="#818181">
            <g id="icon_mark_normal" transform="translate(534.000000, 222.000000)">
                <path d="M0.5,20.6397122 L8,18.1407585 L15.5,20.6397122 L15.5,3.00002705 C15.5,1.61420677 14.3800496,0.5 12.9905224,0.5 L3.00947762,0.5 C1.61641364,0.5 0.5,1.61566259 0.5,3.00002705 L0.5,20.6397122 Z" id="icon_mark"/>
            </g>
        </g>
    </g>
</defs></title></svg>

            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="21px" viewbox="0 0 16 21" version="1.1" class="svgIcon-use unmark-hover-btn">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-534.000000, -345.000000)" stroke="#2D2E2F">
            <g id="icon_mark_hover" transform="translate(534.000000, 345.000000)">
                <path d="M0.5,20.309799 L8,17.8498915 L15.5,20.309799 L15.5,3.00878799 C15.5,1.62231116 14.3770475,0.5 12.9905224,0.5 L3.00947762,0.5 C1.61674031,0.5 0.5,1.61924805 0.5,3.00878799 L0.5,20.309799 Z" id="icon_mark"/>
            </g>
        </g>
    </g>
</defs></title></svg>

          </span>
        </span>
        <span class="topic-collected hidden">
          <span class="svgIcon svgIcon--bookmarkFilled topic-btn">
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="21px" viewbox="0 0 16 22" version="1.1" class="svgIcon-use">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-534.000000, -418.000000)" fill="#2D2E2F">
            <path d="M534,421.000027 C534,419.343158 535.336631,418 537.009478,418 L546.990522,418 C548.652611,418 550,419.334496 550,421.000027 L550,439.333333 L542,436.667783 L534,439.333333 L534,421.000027 Z" id="icon_mark_press"/>
        </g>
    </g>
</defs></title></svg>

          </span>
        </span>
      </button>
      <button class="button xzl-button-chrome-less xzl-base-color-normal-btn  collections-count collections-count-for-1435 u-disablePointerEvents" data-action="show-recommends" data-action-value="ca48fab0cac2">
          收藏
      </button>  
    </div>
    <div class="xzl-topic-btn topic-share-btn-item">
      <button class="button xzl-button-chrome-less topic-share-btn is-touchIconFadeInPulse  button--withIcon button--withSvgIcon button--bookmark js-bookmarkButton">
        <span class="xzl-default-state-btn topic-uncollected">
          <span class="svgIcon svgIcon--bookmark topic-btn">
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="19px" height="21px" viewbox="0 0 19 21" version="1.1" class="btn-unhover">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-1072.000000, -221.000000)" fill-rule="nonzero" fill="#818181">
            <g id="icon_share_normal" transform="translate(1072.000000, 221.000000)">
                <path d="M10,1.70710678 L10,16 L9,16 L9,1.94974747 L6.70710678,4.24264069 L6,3.53553391 L9.53553391,-9.59232693e-14 L9.62132034,0.0857864376 L9.70710678,-9.59232693e-14 L13.2426407,3.53553391 L12.5355339,4.24264069 L10,1.70710678 Z M6.98406982,6 L6.98406982,7 L2.00135411,7 C1.44882877,7 1,7.44628753 1,7.99188419 L1,19.0081158 C1,19.5543728 1.44661828,20 1.99742191,20 L17.0025781,20 C17.5559942,20 18,19.5567115 18,19.0081158 L18,7.99188419 C18,7.44560951 17.5534348,7 17.0027359,7 L11.9909668,7 L11.9909668,6 L17.0027359,6 C18.1057944,6 19,6.89339733 19,7.99188419 L19,19.0081158 C19,20.1082031 18.1090746,21 17.0025781,21 L1.99742191,21 C0.894276248,21 0,20.1066027 0,19.0081158 L0,7.99188419 C0,6.89179693 0.898747194,6 2.00135411,6 L6.98406982,6 Z" id="Shape"/>
            </g>
        </g>
    </g>
</defs></title></svg>

            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="19px" height="21px" viewbox="0 0 19 21" version="1.1" class="btn-hovered">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-1072.000000, -284.000000)" fill-rule="nonzero" fill="#2D2E2F">
            <g id="icon_share_press" transform="translate(1072.000000, 284.000000)">
                <path d="M10,1.70710678 L10,16 L9,16 L9,1.94974747 L6.70710678,4.24264069 L6,3.53553391 L9.53553391,-1.13686838e-13 L9.62132034,0.0857864376 L9.70710678,-1.13686838e-13 L13.2426407,3.53553391 L12.5355339,4.24264069 L10,1.70710678 Z M6.98406982,6 L6.98406982,7 L2.00135411,7 C1.44882877,7 1,7.44628753 1,7.99188419 L1,19.0081158 C1,19.5543728 1.44661828,20 1.99742191,20 L17.0025781,20 C17.5559942,20 18,19.5567115 18,19.0081158 L18,7.99188419 C18,7.44560951 17.5534348,7 17.0027359,7 L11.9909668,7 L11.9909668,6 L17.0027359,6 C18.1057944,6 19,6.89339733 19,7.99188419 L19,19.0081158 C19,20.1082031 18.1090746,21 17.0025781,21 L1.99742191,21 C0.894276248,21 0,20.1066027 0,19.0081158 L0,7.99188419 C0,6.89179693 0.898747194,6 2.00135411,6 L6.98406982,6 Z" id="Shape"/>
            </g>
        </g>
    </g>
</defs></title></svg>

          </span>
        </span>
      </button>
      <button class="button xzl-button-chrome-less xzl-base-color-normal-btn share-text  collections-count u-disablePointerEvents" data-action="show-recommends" data-action-value="ca48fab0cac2">
          分享
        
      </button>
    </div>
      <div class="xzl-topic-btn topic-reprint-btn-item">
        <button class="button xzl-button-chrome-less reprint-btn topic-reprint-btn is-touchIconFadeInPulse  button--withIcon button--withSvgIcon button--bookmark js-bookmarkButton">
          <span class="xzl-default-state-btn topic-uncollected">
            <span class="svgIcon svgIcon--bookmark topic-btn">
              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="23px" height="21px" viewbox="0 0 23 21" version="1.1" class="btn-unhover">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-783.000000, -221.000000)" stroke="#818181">
            <g id="icon_transport_normal" transform="translate(783.000000, 221.000000)">
                <path d="M0.620499195,19.6260789 C0.689774669,19.6000793 0.876367811,19.410893 1.14703386,19.018654 C1.22460981,18.9062339 1.99011688,17.7148837 2.26997018,17.3225109 L2.27162961,17.3201848 C4.76238917,13.8294641 8.63937114,11.5496832 12.9544008,11.1256372 L13.5033012,11.0716957 L13.5033012,14.4053433 C13.5033012,15.0795642 13.7000275,15.1721039 14.2205525,14.737934 L21.9568395,8.28509759 C22.5566887,7.78476341 22.5404655,7.04226228 21.915794,6.56493142 L14.294968,0.741622353 C13.7392626,0.316990668 13.5033012,0.432990692 13.5033012,1.12435459 L13.5033012,4.11604062 L13.0522015,4.16037103 C5.95973399,4.85736114 0.503301161,10.8422818 0.503301161,18.0213137 C0.503301161,18.1416723 0.502883115,18.2315328 0.501639697,18.4238454 C0.494858406,19.4516318 0.516834709,19.5941383 0.620499195,19.6260789 Z" id="Combined-Shape"/>
            </g>
        </g>
    </g>
</defs></title></svg>

              <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="23px" height="21px" viewbox="0 0 23 21" version="1.1" class="btn-hovered">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-783.000000, -285.000000)" stroke="#2D2E2F">
            <path d="M783.620499,304.626079 C783.689775,304.600079 783.876368,304.410893 784.147034,304.018654 C784.22461,303.906234 784.990117,302.714884 785.26997,302.322511 L785.27163,302.320185 C787.762389,298.829464 791.639371,296.549683 795.954401,296.125637 L796.503301,296.071696 L796.503301,299.405343 C796.503301,300.079564 796.700027,300.172104 797.220552,299.737934 L804.95684,293.285098 C805.556689,292.784763 805.540465,292.042262 804.915794,291.564931 L797.294968,285.741622 C796.739263,285.316991 796.503301,285.432991 796.503301,286.124355 L796.503301,289.116041 L796.052202,289.160371 C788.959734,289.857361 783.503301,295.842282 783.503301,303.021314 C783.503301,303.141672 783.502883,303.231533 783.50164,303.423845 C783.494858,304.451632 783.516835,304.594138 783.620499,304.626079 Z" id="icon_transport_press"/>
        </g>
    </g>
</defs></title></svg>

            </span>
          </span>
        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn reprint-text u-disablePointerEvents" data-action="show-recommends">
            转载
        </button>
      </div>
  </div>
</div>




<script type="text/javascript">
  // $(".wechat-qrcode-img").qrcode({
  //   render: "canvas",
  //   text: $(".wechat-qrcode-img").data("url"),
  //   height: 70,
  //   width: 70,
  // })

 
  $(window).on("click.Bst", function(e) {
    if(!$(event.target).closest('.xzl-invite-icon').length){
      //$(".xzl-invite-card").fadeOut()
    }else{
    }
  })

  
</script>
<script type="text/javascript">
  $(".topic-reprint-btn-item").click(function(){
    $(".topic-reprint-modal").removeClass("hidden")
  })

  
</script>
      <div class="topic-show-zhuanlan">
    <div class="streamItem-card">
      <div class="zhuanlan">
        <div class="zl-header">
          <a href="https://xiaozhuanlan.com/bestswifter" target="_blank" rel="noopener">
            <img class="avatar zhuanlan-logo-with-border" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/de72c2a2887d30c37adc04b0d760166b.png" alt="De72c2a2887d30c37adc04b0d760166b">
</a>        </div>
        <div class="zl-body">
          <div class="zl-title"><a href="https://xiaozhuanlan.com/bestswifter" target="_blank" rel="noopener">从 iOS 到全栈</a></div>
          <div class="zl-bio">这个专栏不同于我的博客，主要的更新模式是频率快，内容简洁扼要，会分享一些我平时工作、学习时收获的知识。我希望靠自己...</div>
        </div>
        <div class="zl-footer">
              <button class="button button--small subscribed has-subscribed-btn xzl-btn-with-chrome xzl-base-color-normal-btn">
                <span class="button-label  xzl-default-state-btn">
                  已经订阅
                </span>
              </button>
        </div>
      </div>
    </div>
    
  </div>

    <div class="comment-list-title-header u-block">
  <span class="comment-list-title">
    59条评论
  </span>
</div>
<div class="comments-list">
    <div class="comment-partial" id="reply1">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6487557455" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/6766a88feda7bbbd2a0f8815d287597a.png" alt="6766a88feda7bbbd2a0f8815d287597a">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6487557455" target="_blank" rel="noopener">yu-vin</a>
        <div class="floor">
          <span>#1</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已经订阅，我的微信yu-vin</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-11-20T16:59:01+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="1" data-user-id="7152" data-user-name="yu-vin">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="412" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply2">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/4117613098" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/bf3aa9f8015fa4674524cae79572a9ad.png" alt="Bf3aa9f8015fa4674524cae79572a9ad">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/4117613098" target="_blank" rel="noopener">yeafel</a>
        <div class="floor">
          <span>#2</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信：yeafel </p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-11-28T08:28:17+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="2" data-user-id="7147" data-user-name="yeafel">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="468" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply3">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/2148362116" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/38b72d1e2bc1cddc1b65af971f6a56a3.jpeg" alt="38b72d1e2bc1cddc1b65af971f6a56a3">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/2148362116" target="_blank" rel="noopener">槑玩槑了</a>
        <div class="floor">
          <span>#3</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信    guaiguaifamily</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-07T11:59:53+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="3" data-user-id="1591" data-user-name="槑玩槑了">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="538" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply4">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/8376805409" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/70d04aeb976f684226c4915995a84389.jpg" alt="70d04aeb976f684226c4915995a84389">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/8376805409" target="_blank" rel="noopener">瞄了个咪Yuen</a>
        <div class="floor">
          <span>#4</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信 DayDayFriday</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-11T09:47:34+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="4" data-user-id="25724" data-user-name="瞄了个咪Yuen">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="575" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply5">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/5006638376" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/cc2fe823edaf10d7f914bba24f0a223b.jpeg" alt="Cc2fe823edaf10d7f914bba24f0a223b">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/5006638376" target="_blank" rel="noopener">随波逐流58</a>
        <div class="floor">
          <span>#5</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信hffengshun</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-12T21:41:21+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="5" data-user-id="29084" data-user-name="随波逐流58">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="586" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply6">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/9703450192" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/b427de653c520e3b2e734cd22a95f1ea.png" alt="B427de653c520e3b2e734cd22a95f1ea">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/9703450192" target="_blank" rel="noopener">WAMaker</a>
        <div class="floor">
          <span>#6</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信 fangzhou962837</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-13T00:02:09+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="6" data-user-id="10902" data-user-name="WAMaker">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="587" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply7">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/2075831444" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/0545476daea0872f6f3a85c677718ed7.jpeg" alt="0545476daea0872f6f3a85c677718ed7">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/2075831444" target="_blank" rel="noopener">S.</a>
        <div class="floor">
          <span>#7</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信 nevampire</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-13T00:23:02+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="7" data-user-id="16155" data-user-name="S.">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="588" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply8">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/2051887315" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/f65d300241b70bd276481cb23409aa34.jpeg" alt="F65d300241b70bd276481cb23409aa34">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/2051887315" target="_blank" rel="noopener">☀ Molly ☀</a>
        <div class="floor">
          <span>#8</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信molly1521</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-15T14:16:32+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="8" data-user-id="29612" data-user-name="☀ Molly ☀">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="616" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply9">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/2050692849" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/0a42735e24ce3742e56b000ce99ca119.jpeg" alt="0a42735e24ce3742e56b000ce99ca119">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/2050692849" target="_blank" rel="noopener">MichaelQiu</a>
        <div class="floor">
          <span>#9</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>2.2.3 中多参数传递的 foo(1, 2, 3) 的输出是 (1, 2, 3) 不是 输出 [1, 2, 3]</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-16T16:21:31+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="9" data-user-id="28107" data-user-name="MichaelQiu">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="621" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply10">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg" alt="0bb3579c4b0803177fee89aa150d3ea9">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">张星宇</a>
        <div class="floor">
          <span>#10</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p><a href="https://xiaozhuanlan.com/topic/1053427869#reply9" class="at_floor" data-floor="9" target="_blank" rel="noopener">#9楼</a> <a href="https://xiaozhuanlan.com/u/2050692849" target="_blank" class="at_user" title="@2050692849"><i>@</i>MichaelQiu</a> mark，之后一起改正</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-18T10:53:42+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="10" data-user-id="915" data-user-name="张星宇">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="628" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply11">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/2688600478" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/0e3b9fa52fa3483eeeb8a2b126064174.jpeg" alt="0e3b9fa52fa3483eeeb8a2b126064174">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/2688600478" target="_blank" rel="noopener">Jccc</a>
        <div class="floor">
          <span>#11</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 ，微信  juncairexue</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-22T15:27:05+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="11" data-user-id="4934" data-user-name="Jccc">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="679" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply12">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6382071547" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/c0c24bc2d9413af382825082cb2a84a7.jpg" alt="C0c24bc2d9413af382825082cb2a84a7">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6382071547" target="_blank" rel="noopener">自律性超差的1900</a>
        <div class="floor">
          <span>#12</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅。</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-23T14:46:41+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="12" data-user-id="31354" data-user-name="自律性超差的1900">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="681" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply13">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg" alt="0bb3579c4b0803177fee89aa150d3ea9">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">张星宇</a>
        <div class="floor">
          <span>#13</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p><a href="https://xiaozhuanlan.com/topic/1053427869#reply12" class="at_floor" data-floor="12" target="_blank" rel="noopener">#12楼</a> <a href="https://xiaozhuanlan.com/u/6382071547" target="_blank" class="at_user" title="@6382071547"><i>@</i>自律性超差的1900</a> 提供一下微信号，或者到微博上私聊我，我拉你入群</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-24T19:55:53+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="13" data-user-id="915" data-user-name="张星宇">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="686" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply14">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/3549431373" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/bce84abd5b3b46130270a8c244625cbf.jpeg" alt="Bce84abd5b3b46130270a8c244625cbf">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/3549431373" target="_blank" rel="noopener">柴米油鹽醬醋茶</a>
        <div class="floor">
          <span>#14</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信 jinheng_Y</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2017-12-31T16:29:26+08:00">1 年前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="14" data-user-id="32340" data-user-name="柴米油鹽醬醋茶">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="734" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply15">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/5838153870" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/3fd8dad1645b01bc16efcefdefab6fca" alt="3fd8dad1645b01bc16efcefdefab6fca">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/5838153870" target="_blank" rel="noopener">井底之蛙</a>
        <div class="floor">
          <span>#15</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>微信号： Lxh19931023</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-01-29T09:05:14+08:00">12 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="15" data-user-id="40075" data-user-name="井底之蛙">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="975" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply16">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/1125723714" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/e6e92b8c65473dc125fce865d8353932.jpeg" alt="E6e92b8c65473dc125fce865d8353932">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/1125723714" target="_blank" rel="noopener">YLo.</a>
        <div class="floor">
          <span>#16</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信号：cragod</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-01-29T09:17:26+08:00">12 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="16" data-user-id="27664" data-user-name="YLo.">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="976" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply17">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6116933438" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/65e7c7e51f6e106deea3daef037edd45" alt="65e7c7e51f6e106deea3daef037edd45">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6116933438" target="_blank" rel="noopener">Merging</a>
        <div class="floor">
          <span>#17</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信号suhongcheng_</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-01-30T14:20:25+08:00">12 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="17" data-user-id="41403" data-user-name="Merging">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1009" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply18">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/1821706458" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/5c5dc26e64b05c7d0381bc3fdcf47b47" alt="5c5dc26e64b05c7d0381bc3fdcf47b47">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/1821706458" target="_blank" rel="noopener">不知南北找东西</a>
        <div class="floor">
          <span>#18</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信号：zhaowei842996144</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-01-30T22:58:16+08:00">12 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="18" data-user-id="41727" data-user-name="不知南北找东西">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1022" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply19">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/2601042297" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/75188c2e8ac7fd1e9e407083982206ea" alt="75188c2e8ac7fd1e9e407083982206ea">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/2601042297" target="_blank" rel="noopener">✨单禹钦(ShanYuQin)</a>
        <div class="floor">
          <span>#19</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已定阅微信号s514471574</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-02-01T17:53:31+08:00">11 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="19" data-user-id="40303" data-user-name="✨单禹钦(ShanYuQin)">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1051" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply20">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/2576310263" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/4dc4a3fb596e21db48e5979e32c3c2ab" alt="4dc4a3fb596e21db48e5979e32c3c2ab">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/2576310263" target="_blank" rel="noopener">Legolas_Paul</a>
        <div class="floor">
          <span>#20</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信号 music9131</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-02-06T14:44:43+08:00">11 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="20" data-user-id="42740" data-user-name="Legolas_Paul">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1090" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply21">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/4793313957" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/ac9787bc1c1abf94ee5b295352c7f709.jpeg" alt="Ac9787bc1c1abf94ee5b295352c7f709">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/4793313957" target="_blank" rel="noopener">雪夜</a>
        <div class="floor">
          <span>#21</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信号wstankang</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-02-26T17:17:33+08:00">11 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="21" data-user-id="28407" data-user-name="雪夜">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1184" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply22">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/4640892238" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/f41f8898ae8d88abfaad37af6ae3993a" alt="F41f8898ae8d88abfaad37af6ae3993a">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/4640892238" target="_blank" rel="noopener">bubble</a>
        <div class="floor">
          <span>#22</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信号BaishengDai</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-02-28T16:37:00+08:00">11 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="22" data-user-id="44599" data-user-name="bubble">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1214" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply23">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6565216267" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/e8589f82b49c5d712d21256477ee354c.jpeg" alt="E8589f82b49c5d712d21256477ee354c">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6565216267" target="_blank" rel="noopener">神话先生</a>
        <div class="floor">
          <span>#23</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，wechat: bin-myth</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-01T17:56:21+08:00">11 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="23" data-user-id="1664" data-user-name="神话先生">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1246" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply24">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/5680213680" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/849e9afbd5e53836367745f1ae7e09a5" alt="849e9afbd5e53836367745f1ae7e09a5">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/5680213680" target="_blank" rel="noopener">宁缺</a>
        <div class="floor">
          <span>#24</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信号  ziwei39</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-04T14:12:14+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="24" data-user-id="28358" data-user-name="宁缺">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1279" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply25">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/7014965092" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/e0f27aa764650d290355d0b930830cec.jpeg" alt="E0f27aa764650d290355d0b930830cec">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/7014965092" target="_blank" rel="noopener">HIiii</a>
        <div class="floor">
          <span>#25</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信：ANSEL920</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-04T23:02:41+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="25" data-user-id="2246" data-user-name="HIiii">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1283" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply26">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/1816426041" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/74195a1d1a1984c79a9cece5180064fc.jpeg" alt="74195a1d1a1984c79a9cece5180064fc">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/1816426041" target="_blank" rel="noopener">孙晨</a>
        <div class="floor">
          <span>#26</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>你好，已订阅，微信号sc744715436</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-10T12:51:41+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="26" data-user-id="1904" data-user-name="孙晨">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1355" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply27">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/8059542014" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/2ba5d1612e896600f0245d6fe3cf55e1.jpeg" alt="2ba5d1612e896600f0245d6fe3cf55e1">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/8059542014" target="_blank" rel="noopener">haiweiliu</a>
        <div class="floor">
          <span>#27</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信号，lhwcqu</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-12T10:56:12+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="27" data-user-id="1777" data-user-name="haiweiliu">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1372" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply28">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/chengyu" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/1c44deacfe847a6935b3b8d4a7b93a04.jpeg" alt="1c44deacfe847a6935b3b8d4a7b93a04">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/chengyu" target="_blank" rel="noopener">丸子被占用了</a>
        <div class="floor">
          <span>#28</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信 c0ldsummer</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-17T16:14:11+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="28" data-user-id="27279" data-user-name="丸子被占用了">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1436" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply29">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/4394816618" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/3552a2ac5711ee6e99962a2f171332b0.jpeg" alt="3552a2ac5711ee6e99962a2f171332b0">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/4394816618" target="_blank" rel="noopener">唐健</a>
        <div class="floor">
          <span>#29</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信号：tangjianzju</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-20T21:33:45+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="29" data-user-id="32042" data-user-name="唐健">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1503" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply30">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/8061528302" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/f67a21e2662edf08c260c1cbce52fa31.jpeg" alt="F67a21e2662edf08c260c1cbce52fa31">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/8061528302" target="_blank" rel="noopener">沈大空翼🐈</a>
        <div class="floor">
          <span>#30</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信号:bigshen</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-23T20:32:13+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="30" data-user-id="1771" data-user-name="沈大空翼🐈">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1552" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply31">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/1442104459" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/048981f8149a8836d612e3ff1952f07e" alt="048981f8149a8836d612e3ff1952f07e">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/1442104459" target="_blank" rel="noopener">啾啾</a>
        <div class="floor">
          <span>#31</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅,微信号lazyjiushi</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-25T00:09:02+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="31" data-user-id="52038" data-user-name="啾啾">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1565" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply32">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/3139061979" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/6637487168e8ae745655e04f63f726d0.jpeg" alt="6637487168e8ae745655e04f63f726d0">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/3139061979" target="_blank" rel="noopener">will</a>
        <div class="floor">
          <span>#32</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信will995432525</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-27T11:16:15+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="32" data-user-id="7203" data-user-name="will">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1584" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply33">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/7294200579" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/fd61ba95a601ed1681e18c3453d1747e.jpeg" alt="Fd61ba95a601ed1681e18c3453d1747e">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/7294200579" target="_blank" rel="noopener">xudsh</a>
        <div class="floor">
          <span>#33</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅xudong4397</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-03-31T11:19:48+08:00">10 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="33" data-user-id="33772" data-user-name="xudsh">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1631" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply34">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/3911099684" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/b8853af62e568ed0010d23a77d372360" alt="B8853af62e568ed0010d23a77d372360">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/3911099684" target="_blank" rel="noopener">飞49</a>
        <div class="floor">
          <span>#34</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅18566491052 飞</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-04-08T23:49:32+08:00">9 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="34" data-user-id="56185" data-user-name="飞49">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1702" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply35">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/9636460328" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/5c317fa91f61662c9313ae23fc24c743" alt="5c317fa91f61662c9313ae23fc24c743">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/9636460328" target="_blank" rel="noopener">KM30</a>
        <div class="floor">
          <span>#35</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订，微信km2822072760</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-04-17T10:00:37+08:00">9 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="35" data-user-id="57949" data-user-name="KM30">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1793" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply36">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg" alt="0bb3579c4b0803177fee89aa150d3ea9">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">张星宇</a>
        <div class="floor">
          <span>#36</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p><a href="https://xiaozhuanlan.com/topic/1053427869#reply35" class="at_floor" data-floor="35" target="_blank" rel="noopener">#35楼</a> <a href="https://xiaozhuanlan.com/u/9636460328" target="_blank" class="at_user" title="@9636460328"><i>@</i>KM30</a> 该用户不存在</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-04-17T13:54:16+08:00">9 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="36" data-user-id="915" data-user-name="张星宇">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1795" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply37">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/7142506639" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/a3072951abba7a814f37b46f26753f72.jpeg" alt="A3072951abba7a814f37b46f26753f72">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/7142506639" target="_blank" rel="noopener">kinmo</a>
        <div class="floor">
          <span>#37</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信：yiye664733051</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-04-20T17:08:38+08:00">9 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="37" data-user-id="26182" data-user-name="kinmo">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1849" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply38">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/5602543040" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/f1facde3ce5b7ba68857754fe094ef65.jpeg" alt="F1facde3ce5b7ba68857754fe094ef65">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/5602543040" target="_blank" rel="noopener">Castle</a>
        <div class="floor">
          <span>#38</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅，微信（Base64）：RmFudGFzdGljQ2FzdGxl</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-04-21T14:58:44+08:00">9 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="38" data-user-id="7086" data-user-name="Castle">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1850" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply39">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/9636460328" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/5c317fa91f61662c9313ae23fc24c743" alt="5c317fa91f61662c9313ae23fc24c743">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/9636460328" target="_blank" rel="noopener">KM30</a>
        <div class="floor">
          <span>#39</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p><a href="https://xiaozhuanlan.com/topic/1053427869#reply36" class="at_floor" data-floor="36" target="_blank" rel="noopener">#36楼</a> <a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" class="at_user" title="@4809976499"><i>@</i>张星宇</a> 复制过来，再试一下：km2822072760</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-04-24T15:02:58+08:00">9 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="39" data-user-id="57949" data-user-name="KM30">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="1870" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply40">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/heronlyj" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/b7eb1aeef225fdfb5ed76371606b99a1.jpeg" alt="B7eb1aeef225fdfb5ed76371606b99a1">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/heronlyj" target="_blank" rel="noopener">heronlyj_hd</a>
        <div class="floor">
          <span>#40</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>微信 heronlyj</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-05-16T22:16:30+08:00">8 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="40" data-user-id="32096" data-user-name="heronlyj_hd">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="2004" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply41">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/1069066608" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/d7e4a31006464c3004407f1a29766092.jpeg" alt="D7e4a31006464c3004407f1a29766092">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/1069066608" target="_blank" rel="noopener">生于八零年代</a>
        <div class="floor">
          <span>#41</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅,微信：gongshiwei2013</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-06-06T14:26:13+08:00">7 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="41" data-user-id="26206" data-user-name="生于八零年代">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="2200" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply42">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/7157276569" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/de3e03a16070d32f02b88e860609fc9d" alt="De3e03a16070d32f02b88e860609fc9d">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/7157276569" target="_blank" rel="noopener">.....</a>
        <div class="floor">
          <span>#42</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅,微信:mX_12345</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-06-11T17:57:37+08:00">7 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="42" data-user-id="67046" data-user-name=".....">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="2265" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply43">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/4201728222" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/c3430433302aaaa20d1acf3d93ee7fca" alt="C3430433302aaaa20d1acf3d93ee7fca">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/4201728222" target="_blank" rel="noopener">夏了南城</a>
        <div class="floor">
          <span>#43</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已定阅微信18336070775</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-07-16T17:03:09+08:00">6 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="43" data-user-id="48633" data-user-name="夏了南城">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="2532" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply44">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/JarvisMa" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/317dc68116a605a7471652a0d17302de.png" alt="317dc68116a605a7471652a0d17302de">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/JarvisMa" target="_blank" rel="noopener">JavisMa</a>
        <div class="floor">
          <span>#44</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信 15686448718</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-09-12T20:05:06+08:00">4 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="44" data-user-id="27245" data-user-name="JavisMa">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="3536" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply45">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6250948476" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/eb02ca7ee2a7eb26b4a7748bd84232e2" alt="Eb02ca7ee2a7eb26b4a7748bd84232e2">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6250948476" target="_blank" rel="noopener">开元₂³³³³³³³</a>
        <div class="floor">
          <span>#45</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信 zkylzx1314</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-09-17T17:40:45+08:00">4 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="45" data-user-id="83047" data-user-name="开元₂³³³³³³³">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="3612" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply46">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/5817317652" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/3fed820eb78e9d1c5f296871af915648" alt="3fed820eb78e9d1c5f296871af915648">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/5817317652" target="_blank" rel="noopener">0000</a>
        <div class="floor">
          <span>#46</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信 18107554521</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-09-21T08:56:17+08:00">4 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="46" data-user-id="92387" data-user-name="0000">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="3720" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply47">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6306835122" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/a32c3d2dba32d51a7b007df50af3e88b.jpeg" alt="A32c3d2dba32d51a7b007df50af3e88b">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6306835122" target="_blank" rel="noopener">猫猫</a>
        <div class="floor">
          <span>#47</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信 cat0156</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-09-27T10:30:14+08:00">4 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="47" data-user-id="2933" data-user-name="猫猫">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="3828" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply48">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/2035437492" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/7f74692aba736da5cdb40c12e6be94ef" alt="7f74692aba736da5cdb40c12e6be94ef">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/2035437492" target="_blank" rel="noopener">Dawn62</a>
        <div class="floor">
          <span>#48</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信 X1028958995</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-01T22:01:29+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="48" data-user-id="61519" data-user-name="Dawn62">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4226" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply49">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6765843148" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/c80b8a2c8461db552a5a4344890304b3.jpeg" alt="C80b8a2c8461db552a5a4344890304b3">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6765843148" target="_blank" rel="noopener">slowdony</a>
        <div class="floor">
          <span>#49</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信:dn0224</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-09T09:14:02+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="49" data-user-id="717" data-user-name="slowdony">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4281" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply50">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/7513438194" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/343a695ff477b38815df891afe2c0106.jpeg" alt="343a695ff477b38815df891afe2c0106">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/7513438194" target="_blank" rel="noopener">张熙</a>
        <div class="floor">
          <span>#50</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信:15811006396</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-09T09:46:08+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="50" data-user-id="4197" data-user-name="张熙">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4283" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply51">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/8029320491" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/04cc1a8878c6f749b51215173241befd.jpeg" alt="04cc1a8878c6f749b51215173241befd">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/8029320491" target="_blank" rel="noopener">ChengQian</a>
        <div class="floor">
          <span>#51</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信:CC1010625160</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-09T10:34:46+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="51" data-user-id="1624" data-user-name="ChengQian">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4290" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply52">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/ijason" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/4f5609ad204d16c7c5009b8428b39619.jpeg" alt="4f5609ad204d16c7c5009b8428b39619">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/ijason" target="_blank" rel="noopener">iJasonY</a>
        <div class="floor">
          <span>#52</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信号: SkyForYan</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-09T10:35:12+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="52" data-user-id="25870" data-user-name="iJasonY">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4292" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply53">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6004363922" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/7a3e6ed1460e1e61bac46191abe51833" alt="7a3e6ed1460e1e61bac46191abe51833">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6004363922" target="_blank" rel="noopener">石军峰</a>
        <div class="floor">
          <span>#53</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信号：13825256540</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-09T11:45:52+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="53" data-user-id="81254" data-user-name="石军峰">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4295" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply54">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6832854225" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/20d50fcb6fd8122e0a88b9523a1ad366" alt="20d50fcb6fd8122e0a88b9523a1ad366">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6832854225" target="_blank" rel="noopener">对＆错</a>
        <div class="floor">
          <span>#54</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信 15136176473</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-09T11:48:11+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="54" data-user-id="49218" data-user-name="对＆错">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4297" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply55">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/5773074418" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/645063c4a48fff43c8d8a6c2ac573ba3" alt="645063c4a48fff43c8d8a6c2ac573ba3">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/5773074418" target="_blank" rel="noopener">okik༦ekka༦</a>
        <div class="floor">
          <span>#55</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅号微信lynsolo</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-10T00:39:36+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="55" data-user-id="52971" data-user-name="okik༦ekka༦">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4312" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply56">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/2467213371" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/c46e1beb8b1429b6f888386182c2e2b6.png" alt="C46e1beb8b1429b6f888386182c2e2b6">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/2467213371" target="_blank" rel="noopener">taoZen</a>
        <div class="floor">
          <span>#56</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信 geeksk0410</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-11T14:37:38+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="56" data-user-id="81093" data-user-name="taoZen">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4331" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply57">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/9783163242" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/eb6ab31476f84fe3043528ee07f753c9" alt="Eb6ab31476f84fe3043528ee07f753c9">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/9783163242" target="_blank" rel="noopener">煦暖</a>
        <div class="floor">
          <span>#57</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信 dxd9211</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-14T15:16:02+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="57" data-user-id="46800" data-user-name="煦暖">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4389" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply58">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/9138076029" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/c3d8814cbaaa7c516ad5a6edd3e05dab" alt="C3d8814cbaaa7c516ad5a6edd3e05dab">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/9138076029" target="_blank" rel="noopener">光煜Gray</a>
        <div class="floor">
          <span>#58</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 求拉微信 yugang_1990</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-11-15T19:50:35+08:00">2 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="58" data-user-id="73677" data-user-name="光煜Gray">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4413" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

    <div class="comment-partial" id="reply59">
  <div class="comment-header">
    <div class="avatar">
      <a href="https://xiaozhuanlan.com/u/6526225902" target="_blank" rel="noopener">
        <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/545a0a8c2986ffc8c647209eb27c901a" alt="545a0a8c2986ffc8c647209eb27c901a">
</a>    </div>
    <div class="comment-bd">
      <div class="comment-user-name">
        <a href="https://xiaozhuanlan.com/u/6526225902" target="_blank" rel="noopener">wuzelun</a>
        <div class="floor">
          <span>#59</span>
        </div>
      </div>
      <div class="comment-content markdown topic-body">
        <p>已订阅 微信wuzelun91106</p>
      </div>
    </div>
  </div>
  <div class="comment-footer">
    <span class="time"><abbr class="timeago" title="2018-12-19T11:18:13+08:00">1 月前</abbr></span>
    <div class="comment-btns">
      <div class="reply-partial" data-floor="59" data-user-id="98706" data-user-name="wuzelun">
        <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="20px" viewbox="0 0 22 20" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-103.000000, -40.000000)" id="icon_comment" stroke="#818181">
            <g transform="translate(103.000000, 40.000000)">
                <g>
                    <path d="M1.53190165,18.8176464 C2.49150192,18.4811039 3.92062152,17.9486811 4.12967848,17.8782316 C4.71921491,17.6795652 5.24413733,17.5358632 5.80297815,17.4276536 L5.95929475,17.3973856 L6.10433008,17.4630802 C7.60018069,18.1406347 9.26924932,18.5 11,18.5 C16.8139433,18.5 21.5,14.4529511 21.5,9.5 C21.5,4.54704893 16.8139433,0.5 11,0.5 C5.18605665,0.5 0.5,4.54704893 0.5,9.5 C0.5,11.2144816 1.06048178,12.8584857 2.10399824,14.281142 L2.28161457,14.5232915 L2.15129357,14.7938472 C1.61142046,15.9146623 1.37958882,17.2470024 1.53190165,18.8176464 Z"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          回复
        </button>
      </div>
      <div class="favorite-partial">
        <button class="button xzl-primary-btn topic-favorite-comment-btn xzl-button-chrome-less topic-favorite is-touchIconFadeInPulse  button--withIcon button--withSvgIcon u-accentColor--iconLight js-actionRecommendButton" data-comment-id="4711" data-favorite="false" data-topic-count="false">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-unfavorited ">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -222.000000)" stroke="#818181">
            <path d="M211.978949,241.95489 C211.926485,241.972967 211.87389,241.990773 211.821167,242.008306 L212.136732,242.008306 C212.084007,241.990772 212.031412,241.972966 211.978949,241.95489 Z M201.505033,228.185818 C201.502008,228.093677 201.501932,228.092246 201.499329,228.043074 L201,228.068966 L201,228.568966 L201.482808,228.568966 L201.505033,228.185818 Z M211.978949,241.95489 C206.754996,240.155011 202.831944,235.676332 201.767482,230.227148 C201.586643,229.622169 201.5,229.041319 201.5,228.448276 C201.5,228.363399 201.501775,228.278748 201.505314,228.194357 C201.505217,228.191426 201.505124,228.188582 201.505033,228.185818 L201.510132,228.09792 C201.69196,224.963332 204.293503,222.5 207.448276,222.5 C209.044187,222.5 210.539021,223.130705 211.647055,224.234935 L212,224.586669 L212.352945,224.234935 C213.460979,223.130705 214.955813,222.5 216.551724,222.5 C219.836866,222.5 222.5,225.163134 222.5,228.448276 C222.5,229.151387 222.378189,229.837062 222.142953,230.483227 C220.970297,235.856032 217.094635,240.192275 211.978949,241.95489 Z" id="icon_like_normal"/>
        </g>
    </g>
</defs></title></svg>

          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="21px" viewbox="0 0 22 21" version="1.1" class="svgIcon-use comment-favorited hidden">
    <!-- Generator: Sketch 46 (44423) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Artboard" transform="translate(-201.000000, -418.000000)" fill="#FF7055">
            <path d="M212,419.880774 C210.833721,418.718499 209.224906,418 207.448276,418 C204.014324,418 201.207309,420.684235 201.010971,424.068966 L201,424.068966 C201.001807,424.103813 201.003725,424.138625 201.005753,424.173407 C201.00193,424.264554 201,424.356189 201,424.448276 C201,425.100318 201.096779,425.729755 201.276757,426.323008 C202.393727,432.040989 206.54132,436.674435 211.978949,438.482758 C217.311181,436.709486 221.402901,432.219549 222.612787,426.65427 C222.863332,425.966052 223,425.223124 223,424.448276 C223,420.886991 220.113009,418 216.551724,418 C214.775094,418 213.166279,418.718499 212,419.880774 Z" id="icon_like_press"/>
        </g>
    </g>
</defs></title></svg>

        </button>
        <button class="button xzl-button-chrome-less xzl-base-color-normal-btn favorites-count favorites_count-for-1435 u-disablePointerEvents">
          赞
        </button>
      </div>
    </div>
  </div>
</div>

</div>

  <div class="write-comment">
    <div class="avatar">
      <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/20d50fcb6fd8122e0a88b9523a1ad366" alt="20d50fcb6fd8122e0a88b9523a1ad366">
    </div>
    <textarea class="comment-input" id="comment-input" type="text" rows="1" placeholder="写下你的评论" data-autosize-on="true" style="overflow: hidden; overflow-wrap: break-word; height: 48px;"></textarea> 
  </div>
  <div class="publish-commnt-button">
    <button class="button xzl-primary-btn comment-publish-btn  pull-right xzl-basic-btn hidden xzl-btn-with-chrome disabled" data-topic-id="1435" disbaled="">
      <span class="button-label  xzl-default-state-btn js-buttonLabel">
        发表评论
      </span>
    </button>
  </div>
<script type="text/javascript">
  var formatCommentPublishBtn = function(){
    var text = $(".comment-input").val()
    if(!text){
      $(".comment-publish-btn").addClass("disabled")
    }else{
      $(".comment-publish-btn").removeClass("disabled")
    }
  }
  autosize(document.getElementById('comment-input'));
  $(".comment-input").focus(function(){
    $(".comment-publish-btn").removeClass("hidden")
    formatCommentPublishBtn()
  })
  $(".comment-input").keyup(function(){
    formatCommentPublishBtn()
  })
  $(".comment-input").blur(function(){
    if(!$(".comment-input").val()){
      $(".comment-publish-btn").addClass("hidden")
    }else{
      $(".comment-publish-btn").removeClass("hidden")
    }
  })

  window.replayPartial = function(){
    $(".reply-partial").unbind("click")
    $(".reply-partial").click(function(){
      var floor = $(this).data("floor")
      var userId = $(this).data("user-id")
      var userName = $(this).data("user-name")
      $(".comment-publish-btn").attr("data-user-id", "" + userId)
      $(".comment-input").val(" #" + floor + "楼 @" + userName + " "  ).focus()
    })
  }

  window.replayPartial()

  // $(".comment-partial").blur((function(){
  //   $(this).find(".reply-partial").addClass("hidden")
  // }))
</script>
    <div class="overlay topic-reward-modal hidden overlay--dark">
  <div class="overlay-dialog overlay-dialog--signin overlay-dialog--animate js-overlayDialog" tabindex="-1">
    <div class="close">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="16px" viewbox="0 0 16 16" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-273.000000, -154.000000)" id="icon_close_2" fill="#818181">
            <path d="M281,160.59766 L274.691197,154.288858 C274.296436,153.894097 273.674377,153.899886 273.287131,154.287131 C272.897186,154.677077 272.900659,155.302999 273.288858,155.691197 L279.59766,162 L273.288858,168.308803 C272.894097,168.703564 272.899886,169.325623 273.287131,169.712869 C273.677077,170.102814 274.302999,170.099341 274.691197,169.711142 L281,163.40234 L287.308803,169.711142 C287.703564,170.105903 288.325623,170.100114 288.712869,169.712869 C289.102814,169.322923 289.099341,168.697001 288.711142,168.308803 L282.40234,162 L288.711142,155.691197 C289.105903,155.296436 289.100114,154.674377 288.712869,154.287131 C288.322923,153.897186 287.697001,153.900659 287.308803,154.288858 L281,160.59766 Z"/>
        </g>
    </g>
</defs></title></svg>

    </div>
    <div class="overlay-actions">
      <div class="reward-header">
        <div class="avatar">
          <a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">
            <img class="user-avatar" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/0bb3579c4b0803177fee89aa150d3ea9.jpeg" alt="0bb3579c4b0803177fee89aa150d3ea9">
</a>        </div>
        <div class="user-name">
          <a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">
            张星宇
</a>        </div>
      </div>
      <div class="reward-body">
        <div class="reward-price reward-body-item">
          <span class="user-tip-label">赞赏金额</span>
          <div class="prices">
            <button class="button button--small price reward-price-btn price-btn  selected reward-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" price="2">
              <span class="button-label  xzl-default-state-btn ">
                2元
              </span>
            </button>
            <button class="button button--small price reward-price-btn price-btn reward-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" price="5">
              <span class="button-label  xzl-default-state-btn ">
                5元
              </span>
            </button>
            <button class="button button--small price reward-price-btn price-btn reward-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" price="10">
              <span class="button-label  xzl-default-state-btn ">
                10元
              </span>
            </button>
          </div>
        </div>
        <div class="custom-price-div">
          <a href="javascript:void(0)" class="custom-price" target="_blank" rel="noopener">自定义金额</a>
          <div class="message reward-body-item  hidden">
            <input class="custom-price-input" placeholder="你想赞赏的金额（不超过20000元）">
            <button class="button button--small custom-price-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-gray-btn xzl-base-color-normal-btn" data-topic-id="1435">
              <span class="button-label  xzl-default-state-btn ">
                确定
              </span>
            </button>
          </div>
          <div class="confirmed-custom-price-div hidden">
            <span class="confirmed-custom-price">2222元</span>
          </div>
        </div>
        <div class="pay-way reward-body-item">
          <span class="user-tip-label">支付方式</span>
          <div class="wechat-pay-way pay-way-button selected" data-value="wechat">
            <img class="wechat-pay-logo" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/wechat-e7cc39b856533cdc49437c7235aa3a12525480633f79fb7d9164005112ae4d90.svg" alt="Wechat">
            <span class="tip">微信支付</span>
          </div>
          <div class="alipay-pay-way pay-way-button hidden">
            <span class="tip">支付宝支付</span>
          </div>
          <div class="wallet-pay-way pay-way-button wallet-btn" data-value="wallet" data-amount="0">
            <span class="tip">钱包余额：¥0</span>
          </div>
        </div>
      </div>
      <div class="reward-footer">
        <button class="button button--small pay-confirm-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" data-topic-id="1435">
          <span class="button-label  xzl-default-state-btn ">
            立即支付
          </span>
        </button>
      </div>
    </div>
  </div>
</div>
<div class="qrcode-for-reward">
</div>
<script type="text/javascript">

  $(".custom-price-btn").click(function(){
    const price = $(".custom-price-input").val()
    if(!price){
      alert("自定义价格不能为空")
      return
    }
    if(isNaN(price)){
      alert("自定义价格必须是数字")
      return
    }

    const priceFloat = parseFloat(price)
    if(priceFloat > 20000){
      alert("金额不能超过20000元")
      return
    }

    const pricePrecision = parseInt(priceFloat*10*10)/100
    if (pricePrecision != priceFloat){
      alert("金额只能精确到分")
      return
    }
    $(".confirmed-custom-price-div").html(price + "元")
    $(".custom-price-div .reward-body-item").addClass("hidden")
    $(".confirmed-custom-price-div").removeClass("hidden")
  })


  $(".confirmed-custom-price-div").click(function(){
    $(".custom-price-div .reward-body-item").removeClass("hidden")
    $(".confirmed-custom-price-div").addClass("hidden")
  })

  window.checkWalletAmount = function(){
    //var topicId = $(this).data("topic-id")
    var price = $(".custom-price-input").val()
    if(!price){
      price = $(".price-btn.selected").attr("price")
    }
    price = parseFloat(price)
    if(price <= 0 || price > 20000){
      $(".pay-confirm-btn").attr("disabled", true)
      $(".pay-confirm-btn span").text("金额不正确")
      return
    }
    var walletAmount = parseFloat($(".wallet-pay-way").data("amount"))
    if(price > walletAmount && $(".pay-way-button.selected").data("value") == "wallet"){
      $(".pay-confirm-btn").attr("disabled", true)
      $(".pay-confirm-btn span").text("余额不足")
    }else{
      $(".pay-confirm-btn").removeAttr("disabled")
      $(".pay-confirm-btn span").text("立即支付")
    }
  }

  $(".pay-way-button").unbind("click")
  $(".pay-way-button").click(function(){
    $(".pay-way-button").removeClass("selected")
    $(this).addClass("selected")
    window.checkWalletAmount()
  })

  $(".custom-price").click(function(){
    $(this).addClass("hidden")
    $(".reward-price-btn").removeClass("selected")
    $(".reward-body-item").removeClass("hidden")
  })

  $(".custom-price-input").on("input", function(){
    window.checkWalletAmount()
  })


</script>
    <div class="overlay wechat-pay-success-modal overlay--dark new-session-modal hidden">
  <div class="overlay-dialog overlay-dialog--animate js-overlayDialog" tabindex="-1">
    <div class="close">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="16px" viewbox="0 0 16 16" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-273.000000, -154.000000)" id="icon_close_2" fill="#818181">
            <path d="M281,160.59766 L274.691197,154.288858 C274.296436,153.894097 273.674377,153.899886 273.287131,154.287131 C272.897186,154.677077 272.900659,155.302999 273.288858,155.691197 L279.59766,162 L273.288858,168.308803 C272.894097,168.703564 272.899886,169.325623 273.287131,169.712869 C273.677077,170.102814 274.302999,170.099341 274.691197,169.711142 L281,163.40234 L287.308803,169.711142 C287.703564,170.105903 288.325623,170.100114 288.712869,169.712869 C289.102814,169.322923 289.099341,168.697001 288.711142,168.308803 L282.40234,162 L288.711142,155.691197 C289.105903,155.296436 289.100114,154.674377 288.712869,154.287131 C288.322923,153.897186 287.697001,153.900659 287.308803,154.288858 L281,160.59766 Z"/>
        </g>
    </g>
</defs></title></svg>

    </div>
    <div class="overlay-actions xzl-button-set">
      <img class="pay-success-logo" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/pay-success-9d4074188ff3710b3587bf93ef297b98d647346b7f25f918be77ad1a6aa531c4.png" alt="Pay success">
      <div class="header">
        <span class="tip">已赞赏<span><a href="https://xiaozhuanlan.com/u/4809976499" target="_blank" rel="noopener">张星宇</a><span class="reward-amount">元</span>
      </span></span></div>
      <div class="line-sperator"></div>
      <div class="xzl-button-set share-topic-tip xzl-button-set--vertical">
        分享这篇超棒的文章
      </div>
      <div class="share-btns" data-title="Python 简单入门指北 https://xiaozhuanlan.com/topic/1053427869">
        <div class="share-to-weibo ssb-icon ssb-weibo" data-site="weibo" onclick="return SocialShareButton.share(this);">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="22px" height="19px" viewbox="0 0 22 19" version="1.1" class="share-to-weibo-logo">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill-rule="evenodd">
        <g transform="translate(-204.000000, -229.000000)" id="icon_mine_weibo" fill="#FF636C">
            <g transform="translate(204.000000, 229.000000)">
                <path d="M8.682,19.0015 C4.414,19.0015 0,16.813 0,13.1495 C0,11.311 1.0825,9.18 3.0485,7.1505 C4.9335,5.2065 7.08,3.9985 8.6505,3.9985 C9.277,3.9985 9.8005,4.1975 10.1655,4.5745 C10.5325,4.9525 10.884,5.654 10.6315,6.9015 C11.564,6.536 12.4405,6.3435 13.185,6.3435 C14.3855,6.3435 14.9715,6.8355 15.2505,7.2475 C15.6545,7.8425 15.6855,8.628 15.345,9.5845 C17.019,10.137 18.014,11.3335 18.014,12.796 C18.014,15.731 14.1815,19.0015 8.682,19.0015 L8.682,19.0015 Z M8.6505,4.9985 C7.3805,4.9985 5.418,6.143 3.767,7.8465 C1.9825,9.688 1,11.5715 1,13.1495 C1,15.535 3.8735,18.0015 8.682,18.0015 C13.844,18.0015 17.014,14.97 17.014,12.796 C17.014,11.327 15.6035,10.7175 14.9975,10.523 C14.788,10.4585 14.4975,10.368 14.3525,10.0685 C14.2055,9.764 14.3255,9.4535 14.365,9.3515 C14.547,8.8775 14.7055,8.225 14.423,7.809 C14.1625,7.424 13.6055,7.3435 13.185,7.3435 C12.485,7.3435 11.6205,7.5575 10.6845,7.9615 C10.681,7.963 10.677,7.9645 10.6735,7.966 C10.548,8.019 10.3615,8.08 10.174,8.08 C9.8615,8.08 9.694,7.916 9.622,7.8175 C9.528,7.69 9.4385,7.466 9.5445,7.1255 C9.8005,6.276 9.7655,5.5985 9.4475,5.2705 C9.2725,5.0895 9.0045,4.9985 8.6505,4.9985 L8.6505,4.9985 Z M21.51,6 C21.234,6 21.01,5.7765 21.01,5.5 C21.01,3.0185 18.9915,1 16.51,1 C16.234,1 16.01,0.7765 16.01,0.5 C16.01,0.2235 16.234,0 16.51,0 C19.543,0 22.01,2.4675 22.01,5.5 C22.01,5.7765 21.7865,6 21.51,6 L21.51,6 Z M18.01,6 C17.734,6 17.51,5.7765 17.51,5.5 C17.51,4.949 17.0615,4.5 16.51,4.5 C16.234,4.5 16.01,4.2765 16.01,4 C16.01,3.7235 16.234,3.5 16.51,3.5 C17.613,3.5 18.51,4.397 18.51,5.5 C18.51,5.7765 18.2865,6 18.01,6 L18.01,6 Z" id="Shape-Copy-3"/>
            </g>
        </g>
    </g>
</defs></title></svg>

          <span>微博分享</span>
        </div>
        <div class="share-to-wechat">
          <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="20px" height="20px" viewbox="0 0 20 20" version="1.1" class="share-to-wechat-logo">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-152.000000, -229.000000)" id="icon_mine_wechat" fill="#02BB00">
            <g transform="translate(152.000000, 229.000000)">
                <g id="Group-25">
                    <path d="M1.0075,19.497 C0.8925,19.497 0.779,19.4575 0.6875,19.381 C0.5405,19.259 0.476,19.063 0.5215,18.8775 L1.7115,14.025 C0.591,12.533 0,10.8005 0,9 C0,4.038 4.486,0 10,0 C15.514,0 20,4.038 20,9 C20,13.9625 15.514,18 10,18 C8.644,18 7.3215,17.754 6.065,17.268 L1.2125,19.453 C1.147,19.482 1.077,19.497 1.0075,19.497 L1.0075,19.497 Z M10,1 C5.0375,1 1,4.589 1,9 C1,10.652 1.5695,12.2425 2.646,13.6 C2.742,13.7205 2.777,13.879 2.74,14.0295 L1.7375,18.12 L5.8475,16.269 C5.9725,16.2125 6.116,16.21 6.242,16.262 C7.4375,16.7515 8.7015,17 10,17 C14.9625,17 19,13.4115 19,9 C19,4.589 14.9625,1 10,1 L10,1 Z M6.5,6.4985 C7.0525,6.4985 7.5,6.946 7.5,7.4985 C7.5,8.051 7.0525,8.4985 6.5,8.4985 C5.9475,8.4985 5.5,8.051 5.5,7.4985 C5.5,6.946 5.9475,6.4985 6.5,6.4985 L6.5,6.4985 Z M13.5,6.4985 C14.0525,6.4985 14.5,6.946 14.5,7.4985 C14.5,8.051 14.0525,8.4985 13.5,8.4985 C12.9475,8.4985 12.5,8.051 12.5,7.4985 C12.5,6.946 12.9475,6.4985 13.5,6.4985 L13.5,6.4985 Z" id="Shape-Copy-4"/>
                </g>
            </g>
        </g>
    </g>
</defs></title></svg>

          <span>微信扫一扫</span>
          <div class="wechat-qrcode-img" data-url="https://xiaozhuanlan.com/topic/1053427869"><canvas width="200" height="200"></canvas></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">
  $(".wechat-pay-success-modal .close").click(function(){
    $(".wechat-pay-success-modal").addClass("hidden")
    Turbolinks.visit(window.location.href)
  })

  $(".share-to-wechat").hover(function(){
    //$('.share-to-wechat .wechat-qrcode-img').
    $('.share-to-wechat .wechat-qrcode-img').fadeIn()
  })

  $(".share-to-wechat").mouseleave(function(){
    $('.share-to-wechat .wechat-qrcode-img').fadeOut()
  })
</script>

    <div class="overlay topic-reprint-modal hidden overlay--dark">
  <div class="overlay-dialog overlay-dialog--signin overlay-dialog--animate js-overlayDialog" tabindex="-1">
    <div class="close">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="16px" height="16px" viewbox="0 0 16 16" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-273.000000, -154.000000)" id="icon_close_2" fill="#818181">
            <path d="M281,160.59766 L274.691197,154.288858 C274.296436,153.894097 273.674377,153.899886 273.287131,154.287131 C272.897186,154.677077 272.900659,155.302999 273.288858,155.691197 L279.59766,162 L273.288858,168.308803 C272.894097,168.703564 272.899886,169.325623 273.287131,169.712869 C273.677077,170.102814 274.302999,170.099341 274.691197,169.711142 L281,163.40234 L287.308803,169.711142 C287.703564,170.105903 288.325623,170.100114 288.712869,169.712869 C289.102814,169.322923 289.099341,168.697001 288.711142,168.308803 L282.40234,162 L288.711142,155.691197 C289.105903,155.296436 289.100114,154.674377 288.712869,154.287131 C288.322923,153.897186 287.697001,153.900659 287.308803,154.288858 L281,160.59766 Z"/>
        </g>
    </g>
</defs></title></svg>

    </div>
    <div class="overlay-actions">
      <div class="reprint-body">
        <div class="reprint-body-item reprint-topic-title-item">
          <span class="user-tip-label">转载文章</span>
          <span class="reprint-topic-title">Python 简单入门指北</span>
        </div>
        <div class="reprint-price reprint-body-item">
          <span class="user-tip-label">转载费用</span>
          <div class="prices">
            <span class="number">99</span><span class="presion-number">.90</span>元
          </div>
        </div>
        <div class="reprint-address-div reprint-body-item">
          <span class="user-tip-label">转载到</span>
          <div class="custom-address-div">
            <input class="custom-address-input" placeholder="请填写你要转载的网站/公众号/纸媒等地址">
          </div>
        </div>
        <div class="pay-way reprint-body-item">
          <span class="user-tip-label">支付方式</span>
          <div class="wechat-pay-way pay-way-button">
            <img class="wechat-pay-logo" src="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/wechat-e7cc39b856533cdc49437c7235aa3a12525480633f79fb7d9164005112ae4d90.svg" alt="Wechat">
            <span class="tip">微信支付</span>
          </div>
        </div>
        <div class="reprint-notice reprint-body-item">
          <span class="user-tip-label">转载须知</span>
          <div class="notice topic-notice-item">
            <input id="topic-notice-item" type="checkbox" checked="true">
            <label for="topic-notice-item"></label>
            <span class="reprint-notice-link"><a href="https://xiaozhuanlan.com/topic/1053427869#" target="_blank" rel="noopener">《转载协议》</a></span>
          </div>
        </div>
      </div>
      <div class="reprint-footer">
        <button class="button button--small reprint-pay-confirm-btn xzl-basic-btn xzl-btn-with-chrome xzl-base-color-normal-btn" data-topic-id="1435">
          <span class="button-label  xzl-default-state-btn ">
            确认支付
          </span>
        </button>
      </div>
    </div>
  </div>
</div>
<div class="qrcode-for-reprint">
</div>
<script type="text/javascript">
  $(".topic-reprint-modal .close").click(function(){
    $(".topic-reprint-modal").addClass("hidden")
  })
</script>


          </div>
        </div>
      </section>
    </div>
  </article>
</div>
<script id="article-image-template" type="text/x-handlebars-template"><div class="ImageView" onclick="articleImageFloatClose()"><div class="ImageView-inner"> <img src='@img' /></div></div></script>
<div class="back-to-top" style="left: 976.5px; display: block;">
  <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="19px" height="11px" viewbox="0 0 19 11" version="1.1">
    <!-- Generator: Sketch 45.2 (43514) - http://www.bohemiancoding.com/sketch -->
    <title>top</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="A-首页-更改" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="B-文章详情-04" transform="translate(-1120.000000, -1149.000000)" stroke="#979797">
            <polyline id="top" transform="translate(1129.949747, 1158.949747) rotate(-315.000000) translate(-1129.949747, -1158.949747) " points="1123.62132 1165.27817 1123.62132 1152.62132 1123.62132 1152.62132 1136.27817 1152.62132"/>
        </g>
    </g>
</defs></svg>

</div>

<script type="text/javascript">
  $(".back-to-top").css({left: $(".xzl-home-containner").width() + $(".xzl-home-containner").offset().left + 50 + "px"})
  $(".back-to-top").click(function(){
    $("html, body").animate({
            scrollTop: 0
        }, 600);
  })
  $(window).scroll(function () {
      if ($(this).scrollTop() > 100) {
          $('.back-to-top').fadeIn();
      } else {
          $('.back-to-top').fadeOut();
      }
  });
</script>
<script type="text/javascript">
  
  setTimeout(function(){
    window.app.updateFrameHeight()
  }, 500)
  setTimeout(function(){
    window.app.fetch(window.location.href + "/visit", "get", {}, function(){}, false)
  }, 1500)


   var data = {}

    var contentTopic = document.getElementById("xzl-topic-content");

    contentTopic.innerHTML = (new window.Markdowner).getHtml();
    data["draft_html"] = $("#xzl-topic-content").html()

    var topicBody = document.getElementById("xzl-topic-body-content");
    if(topicBody){
      topicBody.innerHTML = (new window.Markdowner).getBodyHtml();
      if(!!topicBody.innerHTML){
        data["body_html"] = $("#xzl-topic-body-content").html()
      }
      var summaryHtml = document.getElementById("xzl-topic-summary-content");
      summaryHtml.innerHTML = (new window.Markdowner).getSumarryHtml();
      data["summary_html"] = $("#xzl-topic-summary-content").html()
      $("pre code").each(function(){
        $(this).html("<ul><li><div class='code_line'>" + $(this).html().replace(/\n/g,"\n</div></li><li><div class='code_line'>") +"\n</div></li></ul>");
      });
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
      //MathJax.Hub.Queue(["Typeset",MathJax.Hub, function(){
      if(!!$(".topic-body").data("enable-update-html")){
        data["update_token"] = $(".topic-body").data("update-token")
        $.ajax({
          url: $(".topic-body").data("url"),
          method: "put",
          data: data
        }).done(function(){
          summaryHtml.innerHTML = ""
          topicBody.innerHTML   = ""
        })
      }
      (new window.Markdowner).formatChartFromCode()
      //}]);
      // $(".hidden_topic_body").remove()
    }
</script>


    </div>
  </div>
    <div class="xzl-invite-card">
  <div class="share-logos">
    <div class="share-logo">
      <div class="share-tip"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="21px" height="17px" viewbox="0 0 21 17" version="1.1">
    <!-- Generator: Sketch 44.1 (41455) - http://www.bohemiancoding.com/sketch -->
    <title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-468.000000, -514.000000)" id="icon_1_wechat" fill="#02BB00">
            <g transform="translate(468.000000, 514.000000)">
                <path d="M17,11 C16.4444444,11 16,10.5555556 16,10 C16,9.44444444 16.4444444,9 17,9 C17.5555556,9 18,9.44444444 18,10 C18,10.5277778 17.5555556,11 17,11 M12,11 C11.4444444,11 11,10.5555556 11,10 C11,9.44444444 11.4444444,9 12,9 C12.5555556,9 13,9.44444444 13,10 C13,10.5277778 12.5555556,11 12,11 M18.7527881,15.1010526 C20.1301115,14.1515789 21,12.7389474 21,11.1873684 C21,8.31578947 18.1003717,6 14.5,6 C10.8996283,6 8,8.31578947 8,11.1873684 C8,14.0589474 10.8996283,16.3747368 14.5,16.3747368 C15.2490706,16.3747368 15.9498141,16.2821053 16.6263941,16.0968421 C16.6747212,16.0736842 16.7472119,16.0736842 16.8197026,16.0736842 C16.9405204,16.0736842 17.0613383,16.12 17.1579926,16.1663158 L18.5836431,16.9536842 C18.6319703,16.9768421 18.6561338,17 18.704461,17 C18.8252788,17 18.9219331,16.9073684 18.9219331,16.7915789 C18.9219331,16.7452632 18.8977695,16.6989474 18.8977695,16.6294737 C18.8977695,16.6063158 18.704461,15.9810526 18.6078067,15.5873684 C18.5836431,15.5410526 18.5836431,15.4947368 18.5836431,15.4484211 C18.5594796,15.2863158 18.6319703,15.1705263 18.7527881,15.1010526" id="Shape-Copy"/>
                <path d="M10,5.12844037 C9.45547362,5.12844037 9.02439024,4.70684873 9.02439024,4.17431193 C9.02439024,3.64177512 9.45547362,3.22018349 10,3.22018349 C10.5445264,3.22018349 10.9756098,3.64177512 10.9756098,4.17431193 C10.9756098,4.6846597 10.5445264,5.12844037 10,5.12844037 M5,5.12844037 C4.45547362,5.12844037 4.02439024,4.70684873 4.02439024,4.17431193 C4.02439024,3.64177512 4.45547362,3.22018349 5,3.22018349 C5.54452638,3.22018349 5.97560976,3.64177512 5.97560976,4.17431193 C5.97560976,4.6846597 5.54452638,5.12844037 5,5.12844037 M0,6.13508772 C0,7.98245614 1.00624025,9.64736842 2.62090484,10.7649123 C2.73790952,10.8561404 2.83151326,10.9929825 2.83151326,11.1754386 C2.83151326,11.2210526 2.80811232,11.2894737 2.80811232,11.3350877 C2.69110764,11.7912281 2.48049922,12.5438596 2.45709828,12.5666667 C2.43369735,12.6350877 2.41029641,12.6807018 2.41029641,12.7491228 C2.41029641,12.8859649 2.52730109,13 2.66770671,13 C2.71450858,13 2.76131045,12.977193 2.80811232,12.954386 L4.46957878,12.0192982 C4.58658346,11.9508772 4.72698908,11.9052632 4.8673947,11.9052632 C4.9375975,11.9052632 5.00780031,11.9052632 5.07800312,11.9280702 C5.85023401,12.1333333 6.69266771,12.2701754 7.5351014,12.2701754 L7.95631825,12.2701754 C7.7925117,11.7912281 7.69890796,11.2894737 7.69890796,10.7649123 C7.69890796,7.68596491 10.7878315,5.17719298 14.5787832,5.17719298 L15,5.17719298 C14.4617785,2.23508772 11.326053,0 7.55850234,0 C3.39313573,0 0,2.73684211 0,6.13508772 Z" id="Shape-Copy-2"/>
            </g>
        </g>
    </g>
</defs></title></svg>
<span>微信扫码</span></div>
      <div class="wechat-qrcode-img" data-url="https://xiaozhuanlan.com/topic/1053427869"><canvas width="200" height="200"></canvas></div>
    </div>
    <div class="line-speartor"></div>
    <div class="share-logo social-share-button" data-title="向大家推荐《Python 简单入门指北》
 https://xiaozhuanlan.com/topic/1053427869">

      <div class="share-tip" data-title="向大家推荐《Python 简单入门指北》
 https://xiaozhuanlan.com/topic/1053427869"><a rel="noopener" data-site="weibo" class="ssb-icon ssb-weibo" onclick="return SocialShareButton.share(this);" title="Share to Twitter" href="https://xiaozhuanlan.com/topic/1053427869" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="24px" height="19px" viewbox="0 0 24 19" version="1.1">
    <!-- Generator: Sketch 47.1 (45422) - http://www.bohemiancoding.com/sketch -->
    <title>icon_weibo_01@2x</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-786.000000, -75.000000)" id="icon_weibo_01" fill-rule="nonzero" fill="#F54E4C">
            <path d="M794.337934,85.2741341 C792.337079,85.5504873 790.899754,87.0989312 791.124877,88.7310747 C791.350722,90.3632182 793.155315,91.4628586 795.15617,91.1865054 C797.155582,90.9101522 798.595072,89.3617084 798.369227,87.7281218 C798.144104,86.0959783 796.338789,84.9970594 794.337934,85.2741341 Z M793.754201,89.8855528 C793.050691,89.9829619 792.417171,89.5969333 792.337079,89.0225804 C792.25843,88.4496706 792.763514,87.9056228 793.467024,87.8074921 C794.169813,87.7108046 794.804054,88.0968332 794.884146,88.6711861 C794.962795,89.2448174 794.456989,89.7881437 793.754201,89.8855528 Z M795.547971,88.0391093 C795.252858,88.1141504 794.963517,87.9792208 794.903628,87.7382234 C794.842297,87.4972261 795.032064,87.2417978 795.327177,87.1674783 C795.622291,87.0931588 795.910189,87.2273669 795.97152,87.4683642 C796.033574,87.7093615 795.841642,87.9655113 795.547971,88.0391093 Z M804.723908,82.5676044 C804.827811,82.6116188 804.936765,82.6325437 805.043554,82.6325437 C805.3632,82.6325437 805.668416,82.4442195 805.80118,82.1303457 C805.954149,81.7695713 806.031355,81.3849858 806.031355,80.989577 C806.031355,79.3740291 804.717414,78.0593671 803.101866,78.0593671 C802.707179,78.0593671 802.323315,78.1365729 801.961098,78.2895412 C801.542599,78.4670422 801.347059,78.9497584 801.523839,79.3675352 C801.70134,79.7860335 802.184056,79.9822948 802.602554,79.8055153 C802.760574,79.7391329 802.928695,79.7052201 803.101866,79.7052201 C803.809706,79.7052201 804.386223,80.281016 804.386223,80.989577 C804.386223,81.1641918 804.353032,81.3323127 804.286649,81.4896104 C804.109148,81.9073872 804.30541,82.3908249 804.723908,82.5676044 Z M802.808196,83.780528 C802.889009,83.5489108 802.969101,83.3201798 802.969101,83.3201798 C804.409313,80.5559262 800.696222,79.6547116 798.566932,80.8293932 C796.438363,82.0055178 797.465848,80.0154861 797.465848,80.0154861 C797.817964,76.3810445 793.997363,77.9893769 793.997363,77.9893769 C785.124477,82.9651778 786.025691,87.8962426 786.025691,87.8962426 C786.025691,90.6099878 790.279943,93.640493 795.64538,93.640493 C802.753358,93.640493 806.806298,89.4850932 806.102066,86.3968641 C805.817055,85.1500277 804.336436,84.0814138 802.808196,83.780528 Z M794.588311,92.2291435 C789.934321,92.2291435 788.359902,89.8083471 788.359902,88.0585911 C788.359902,85.2864004 792.032585,83.2386448 795.490247,83.2386448 C798.947188,83.2386448 801.411277,84.7077183 801.975528,86.6342537 C802.811082,89.4850932 799.16726,92.2291435 794.588311,92.2291435 Z M803.101866,75 C802.594617,75 802.088812,75.0642178 801.601045,75.1904889 C801.161621,75.3037721 800.896813,75.7525755 801.010096,76.1927203 C801.124822,76.6321435 801.572904,76.8969519 802.012327,76.7836688 C802.365886,76.6913105 802.732433,76.6458529 803.102588,76.6458529 C805.496687,76.6458529 807.44559,78.5947564 807.44559,80.9888555 C807.44559,81.5025982 807.356118,82.0047962 807.182947,82.4802969 C807.027092,82.9067323 807.246443,83.3800684 807.672878,83.5352014 C807.765958,83.5691142 807.861202,83.5857098 807.955004,83.5857098 C808.290524,83.5857098 808.606562,83.3779037 808.727783,83.0445481 C808.967337,82.3872171 809.09,81.6952518 809.09,80.9881339 C809.089279,77.6870479 806.403674,75 803.101866,75 Z"/>
        </g>
    </g>
</defs></svg>
<span>新浪微博</span></a></div>
      <div class="share-tip" data-title="向大家推荐《Python 简单入门指北》
 https://xiaozhuanlan.com/topic/1053427869"><a rel="noopener" data-site="twitter" class="ssb-icon ssb-twitter" onclick="return SocialShareButton.share(this);" title="Share to Twitter" href="https://xiaozhuanlan.com/topic/1053427869" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="21px" height="18px" viewbox="0 0 21 18" version="1.1">
    <!-- Generator: Sketch 47.1 (45422) - http://www.bohemiancoding.com/sketch -->
    <title>icon_twitter@2x</title>
    <desc>Created with Sketch.</desc>
    <defs>
    <g id="切图" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-722.000000, -74.000000)" id="icon_twitter" fill-rule="nonzero" fill="#1296DB">
            <g transform="translate(722.000000, 74.000000)">
                <path d="M14.2831702,0.00104702329 C15.9524708,-0.0287932359 16.8416087,0.582932296 17.6886425,1.3587793 C18.4093643,1.29661208 19.3430829,0.891281729 19.8953886,0.612772555 C20.0737115,0.513304984 20.2520344,0.416324117 20.4303574,0.316856546 C20.1158155,1.17227761 19.6873452,1.83871032 19.0334945,2.34848158 C18.8873688,2.4603826 18.7437198,2.61207062 18.5604435,2.68418461 L18.5604435,2.69413138 C19.4941621,2.68418464 20.2668947,2.26144748 21,2.03018537 L21,2.04013212 C20.6161104,2.65434433 20.0935252,3.27601663 19.5387428,3.72362069 C19.3133624,3.90266232 19.0904588,4.08170392 18.8650784,4.26074555 C18.877462,5.25542121 18.8502182,6.20284978 18.6644651,7.03837733 C17.5895743,11.8948813 14.7388843,15.1897444 10.2263239,16.6021838 C8.60655738,17.1094684 5.98620119,17.3158636 4.13114753,16.8533394 C3.20981246,16.624564 2.37763887,16.3659483 1.59747612,16.0227852 C1.16405237,15.8313102 0.762825805,15.624915 0.378936204,15.3911662 L0,15.1599041 C0.418563521,15.1723376 0.908951532,15.2892119 1.37704919,15.2121246 C1.8005661,15.1424973 2.2166529,15.1623908 2.60549592,15.0753567 C3.58131855,14.8615014 4.44568934,14.5780188 5.19117821,14.1403616 C5.55277746,13.928993 6.10012974,13.6778374 6.35770728,13.3719746 C5.87474938,13.3794347 5.43389551,13.2675337 5.07477296,13.1407125 C3.68038684,12.6458614 2.8705036,11.7382198 2.34296497,10.3730275 C2.76648189,10.4177879 3.98254511,10.5296889 4.26736644,10.2884801 C3.73487439,10.2586398 3.22467272,9.95029034 2.85812006,9.72151494 C1.73617171,9.01778191 0.82226678,7.83660455 0.829696899,6.01883477 C0.978299323,6.08846205 1.12442505,6.15808937 1.27055078,6.22771665 C1.55289539,6.34707774 1.83771672,6.41173164 2.17454889,6.47887227 C2.31572119,6.50871253 2.60054253,6.59325997 2.76400519,6.53109275 L2.74171483,6.53109275 C2.52624131,6.27745045 2.17207219,6.10835559 1.95412195,5.83730646 C1.23587688,4.93961166 0.559735827,3.55701251 0.988206164,1.91331097 C1.09718127,1.4955472 1.26807408,1.1275172 1.4513504,0.786840798 C1.45878052,0.789327478 1.46621064,0.794300863 1.47116406,0.796787543 C1.55537211,0.973342466 1.74112513,1.10265032 1.86000708,1.24936496 C2.22903644,1.70691576 2.67979716,2.11721947 3.14294139,2.48027611 C4.71565044,3.71864731 6.13232692,4.4770875 8.4059441,5.03907926 C8.98301686,5.18082054 9.64925109,5.29023485 10.3402524,5.29272153 C10.1470692,4.72575642 10.2089869,3.81065479 10.360066,3.2610965 C10.7439556,1.88347071 11.5761293,0.891281729 12.7996226,0.356643575 C13.0918741,0.229822424 13.4163227,0.137814918 13.7556316,0.0632142461 C13.9314778,0.0433207319 14.107324,0.0209405375 14.2831702,0.00104702329" id="Shape"/>
            </g>
        </g>
    </g>
</defs></svg>
<span>Twitter</span></a></div>
    </div>
  </div>
  <div class="popover-arrow down">
  </div>
</div>

<script type="text/javascript">
  $(".topic-share-btn-item").hover(function(){
  $(".xzl-invite-card").css({"top": $(".topic-share-btn").offset().top - 200, "left": $(".topic-share-btn").offset().left - 175})
    $(".xzl-invite-card").addClass("hovering-logo")
    $(".xzl-invite-card").show()
  })
  $(".xzl-invite-card").hover(function(){
    $(".xzl-invite-card").addClass("hovering-card")
    $(".xzl-invite-card").show()
  })

  var checkoutFoucs = function(){
    if(!$(".xzl-invite-card").hasClass("hovering-logo")){
      if(!$(".xzl-invite-card").hasClass("hovering-card")){
        $(".xzl-invite-card").hide()
      }
    }
  }

  $(".xzl-invite-card").mouseleave(function(){
    $(".xzl-invite-card").removeClass("hovering-card")
    setTimeout(checkoutFoucs, 500)
  })

  $(".topic-share-btn-item").mouseleave(function(){
    $(".xzl-invite-card").removeClass("hovering-logo")
    setTimeout(checkoutFoucs, 500)
  })
   $(".wechat-qrcode-img").qrcode({
    render: "canvas",
    text: $(".wechat-qrcode-img").data("url"),
    height: 70,
    width: 70,
  })

</script>
  


<script type="text/javascript">
  $(document).ready(function(){
    $("abbr.timeago").timeago()
    window.Photo.initUserAvatarDropzone()
    window.Photo.browseUpload(".user-avatar-edit")
    window.Photo.initPhotoDropzone("zhuanlan-logo", ".zhuanlan-logo-img")
    window.Photo.browsePhotoUpload("zhuanlan-logo")

    $(".buttonSwitch button").click(function(){
      if($(this).parent().hasClass("uneditable")){
        return
      }
      var siblings = $(this).siblings()
      siblings.each(function(index){
        $(siblings[index]).removeClass("selected")
      })
      $(this).addClass("selected")
    })
    Turbolinks.start()
  })
  window.user.init()
</script>

  <script type="text/javascript">
    // $("html, body").animate({
    //     scrollTop: 0
    // }, 600);
    var resize  = function(){
      var width = $(window).width()
      if (width > 730){
         $(".xzl-topic-item .topic-body .topic-cover-wrapper, .xzl-topic-item .topic-body .topic-cover-wrapper .topic-cover-div").css("height", 180 + "px")
      }else{  
        var height = 180*(width - 40)/670
        $(".xzl-topic-item .topic-body .topic-cover-wrapper, .xzl-topic-item .topic-body .topic-cover-wrapper .topic-cover-div").css("height", height + "px")
      }

      if(width > 1340){
        $(".topic-editor-dropzone.dz-clickable, .navbar.navbar-default, .cmmde_title, .topic-cover-dropzone.dz-clickable").css({"width": "670px"})
      }else{
        var maxWidth = ($(window).width() - 80) /2 
        $(".topic-editor-dropzone.dz-clickable, .navbar.navbar-default, .cmmde_title, .topic-cover-dropzone.dz-clickable").css({"width": maxWidth + "px"})
      }
    }
    window.onresize = resize;
    resize()
    window.followUserHover = function(){
      $(".btn-follow-user").unbind("hover")
      $(".btn-follow-user").unbind("mouseleave")
      $(".btn-follow-user.followed").hover(function(){
        if($(this).hasClass("followed")){
          $(this).find("span").text("取消关注")
        }
      })
      $(".btn-follow-user.followed").mouseleave(function(){
        $(this).find("span").text("已关注")
      })
    }
    window.followUserHover()

  </script>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-102672567-1', 'auto');
    ga('send', 'pageview');

  </script>

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e7fbc901596776745c59d839ad5b5ef7";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>

  


</body></html>
      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Micah
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/" title="">https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏_files/raphael-73fc121fcba5dc93ab67fbe3a44329411937f2f432ec705a3e2c337ad2d4d576/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="lvchenqiang.github.io/image/avatar.png"
                alt="Micah" />
            
              <p class="site-author-name" itemprop="name">Micah</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="lvchenqiang.github.io/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="lvchenqiang.github.io/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="lvchenqiang.github.io/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lvchenqiang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/lvchenqiang_" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-csdn"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#section0"><span class="nav-number">1.</span> <span class="nav-text">0. 准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section1"><span class="nav-number">2.</span> <span class="nav-text">1. 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section11"><span class="nav-number">2.1.</span> <span class="nav-text">1.1 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section111"><span class="nav-number">2.1.1.</span> <span class="nav-text">1.1.1 列表推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section112"><span class="nav-number">2.1.2.</span> <span class="nav-text">1.1.2 元组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section113"><span class="nav-number">2.1.3.</span> <span class="nav-text">1.1.3 数组切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section114"><span class="nav-number">2.1.4.</span> <span class="nav-text">1.1.4 循环与遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section115"><span class="nav-number">2.1.5.</span> <span class="nav-text">1.1.5 魔术方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section12"><span class="nav-number">2.2.</span> <span class="nav-text">1.2 字典</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section121"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.2.1 初始化字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section122"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2.2 查询字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section123"><span class="nav-number">2.2.3.</span> <span class="nav-text">1.2.3 遍历字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section124"><span class="nav-number">2.2.4.</span> <span class="nav-text">1.2.4 字典的魔术方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section125"><span class="nav-number">2.2.5.</span> <span class="nav-text">1.2.5 集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section13"><span class="nav-number">2.3.</span> <span class="nav-text">1.3 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section131"><span class="nav-number">2.3.1.</span> <span class="nav-text">1.3.1 字符串编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section132"><span class="nav-number">2.3.2.</span> <span class="nav-text">1.3.2 字符串的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section133"><span class="nav-number">2.3.3.</span> <span class="nav-text">1.3.3 字符串格式化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section134heredoc"><span class="nav-number">2.3.4.</span> <span class="nav-text">1.3.4 HereDoc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section2"><span class="nav-number">3.</span> <span class="nav-text">2 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section21"><span class="nav-number">3.1.</span> <span class="nav-text">2.1 函数是一等公民</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section22"><span class="nav-number">3.2.</span> <span class="nav-text">2.2 函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section221"><span class="nav-number">3.2.1.</span> <span class="nav-text">2.2.1 函数传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section222"><span class="nav-number">3.2.2.</span> <span class="nav-text">2.2.2 默认参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section223"><span class="nav-number">3.2.3.</span> <span class="nav-text">2.2.3 多参数传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section224"><span class="nav-number">3.2.4.</span> <span class="nav-text">2.2.4 参数分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section23"><span class="nav-number">3.3.</span> <span class="nav-text">2.3 函数内省</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section24"><span class="nav-number">3.4.</span> <span class="nav-text">2.4 装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section241"><span class="nav-number">3.4.1.</span> <span class="nav-text">2.4.1 设计模式的消亡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section242"><span class="nav-number">3.4.2.</span> <span class="nav-text">2.4.2 装饰器的基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section243"><span class="nav-number">3.4.3.</span> <span class="nav-text">2.4.3 装饰器进阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section244"><span class="nav-number">3.4.4.</span> <span class="nav-text">2.4.4 装饰器工厂</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section3"><span class="nav-number">4.</span> <span class="nav-text">3 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section31"><span class="nav-number">4.1.</span> <span class="nav-text">3.1 对象内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section311"><span class="nav-number">4.1.1.</span> <span class="nav-text">3.1.1 对象不是盒子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section312"><span class="nav-number">4.1.2.</span> <span class="nav-text">3.1.2 默认浅复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section313"><span class="nav-number">4.1.3.</span> <span class="nav-text">3.1.3 弱引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section32python"><span class="nav-number">4.2.</span> <span class="nav-text">3.2 Python 风格的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section321"><span class="nav-number">4.2.1.</span> <span class="nav-text">3.2.1 静态函数与类方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section322attribute"><span class="nav-number">4.2.2.</span> <span class="nav-text">3.2.2 属性 attribute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section323property"><span class="nav-number">4.2.3.</span> <span class="nav-text">3.2.3 特性 property</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section324"><span class="nav-number">4.2.4.</span> <span class="nav-text">3.2.4 特性工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section325"><span class="nav-number">4.2.5.</span> <span class="nav-text">3.2.5 属性描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section326"><span class="nav-number">4.2.6.</span> <span class="nav-text">3.2.6 实例属性的查找顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section33"><span class="nav-number">4.3.</span> <span class="nav-text">3.3 多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section331"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.3.1 多继承的必要性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section332python"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.3.2 Python 的多继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section333mixin"><span class="nav-number">4.3.3.</span> <span class="nav-text">3.3.3 Mixin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section334"><span class="nav-number">4.3.4.</span> <span class="nav-text">3.3.4 抽象类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section34"><span class="nav-number">4.4.</span> <span class="nav-text">3.4 元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section341"><span class="nav-number">4.4.1.</span> <span class="nav-text">3.4.1 类工厂函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section342"><span class="nav-number">4.4.2.</span> <span class="nav-text">3.4.2 元类的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section343"><span class="nav-number">4.4.3.</span> <span class="nav-text">3.4.3 元类的使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section4"><span class="nav-number">5.</span> <span class="nav-text">4. 流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section41else"><span class="nav-number">5.1.</span> <span class="nav-text">4.1 else</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section411forelse"><span class="nav-number">5.1.1.</span> <span class="nav-text">4.1.1 for else</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section412whileelse"><span class="nav-number">5.1.2.</span> <span class="nav-text">4.1.2 while else</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section413tryelse"><span class="nav-number">5.1.3.</span> <span class="nav-text">4.1.3 try else</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section42"><span class="nav-number">5.2.</span> <span class="nav-text">4.2 迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section421"><span class="nav-number">5.2.1.</span> <span class="nav-text">4.2.1 迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section422"><span class="nav-number">5.2.2.</span> <span class="nav-text">4.2.2 可迭代对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section423__iter__"><span class="nav-number">5.2.3.</span> <span class="nav-text">4.2.3 \__iter__ 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section424"><span class="nav-number">5.2.4.</span> <span class="nav-text">4.2.4 标准迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section425"><span class="nav-number">5.2.5.</span> <span class="nav-text">4.2.5 初识生成器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section43"><span class="nav-number">5.3.</span> <span class="nav-text">4.3 生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section431"><span class="nav-number">5.3.1.</span> <span class="nav-text">4.3.1 生成器的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section432"><span class="nav-number">5.3.2.</span> <span class="nav-text">4.3.2 生成器表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section433"><span class="nav-number">5.3.3.</span> <span class="nav-text">4.3.3 协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section434"><span class="nav-number">5.3.4.</span> <span class="nav-text">4.3.4 预激协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section435"><span class="nav-number">5.3.5.</span> <span class="nav-text">4.3.5 标准库中的生成器函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section44"><span class="nav-number">5.4.</span> <span class="nav-text">4.4 上下文管理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section441with"><span class="nav-number">5.4.1.</span> <span class="nav-text">4.4.1 with 块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section442"><span class="nav-number">5.4.2.</span> <span class="nav-text">4.4.2 自定义上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section443"><span class="nav-number">5.4.3.</span> <span class="nav-text">4.4.3 标准库中的上下文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section5python"><span class="nav-number">6.</span> <span class="nav-text">5. 其他 Python 特色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section51gil"><span class="nav-number">6.1.</span> <span class="nav-text">5.1 多线程与GIL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section511"><span class="nav-number">6.1.1.</span> <span class="nav-text">5.1.1 多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section512"><span class="nav-number">6.1.2.</span> <span class="nav-text">5.1.2 线程锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section513gil"><span class="nav-number">6.1.3.</span> <span class="nav-text">5.1.3 GIL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section514"><span class="nav-number">6.1.4.</span> <span class="nav-text">5.1.4 多进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section52python"><span class="nav-number">6.2.</span> <span class="nav-text">5.2 我眼中的  Python</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section521python"><span class="nav-number">6.2.1.</span> <span class="nav-text">5.2.1 Python 是动态强类型语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section522"><span class="nav-number">6.2.2.</span> <span class="nav-text">5.2.2 开发效率高</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section523"><span class="nav-number">6.2.3.</span> <span class="nav-text">5.2.3 对新人不是很友好</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section53python"><span class="nav-number">6.3.</span> <span class="nav-text">5.3 其它 Python 技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section531"><span class="nav-number">6.3.1.</span> <span class="nav-text">5.3.1 文件读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section532json"><span class="nav-number">6.3.2.</span> <span class="nav-text">5.3.2 JSON 读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section533shell"><span class="nav-number">6.3.3.</span> <span class="nav-text">5.3.3 执行 Shell</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section54python"><span class="nav-number">6.4.</span> <span class="nav-text">5.4 Python 模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section541python"><span class="nav-number">6.4.1.</span> <span class="nav-text">5.4.1 Python 中的模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section542"><span class="nav-number">6.4.2.</span> <span class="nav-text">5.4.2 模块查找顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section543__init__py"><span class="nav-number">6.4.3.</span> <span class="nav-text">5.4.3 包与 \__init__.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section554"><span class="nav-number">6.4.4.</span> <span class="nav-text">5.5.4 相对导入和绝对导入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section545python"><span class="nav-number">6.4.5.</span> <span class="nav-text">5.4.5 运行 Python 脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section55venv"><span class="nav-number">6.5.</span> <span class="nav-text">5.5 venv</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section551venv"><span class="nav-number">6.5.1.</span> <span class="nav-text">5.5.1 什么是 venv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section552venv"><span class="nav-number">6.5.2.</span> <span class="nav-text">5.5.2 venv 结构初探</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section553"><span class="nav-number">6.5.3.</span> <span class="nav-text">5.5.3 工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section6"><span class="nav-number">7.</span> <span class="nav-text">6 学习方向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section7"><span class="nav-number">8.</span> <span class="nav-text">7 版本历史</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section100"><span class="nav-number">8.0.1.</span> <span class="nav-text">1.0.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section101"><span class="nav-number">8.0.2.</span> <span class="nav-text">1.0.1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section"><span class="nav-number">9.</span> <span class="nav-text">参考资料：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section0"><span class="nav-number">10.</span> <span class="nav-text">0. 准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section1"><span class="nav-number">11.</span> <span class="nav-text">1. 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section11"><span class="nav-number">11.1.</span> <span class="nav-text">1.1 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section111"><span class="nav-number">11.1.1.</span> <span class="nav-text">1.1.1 列表推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section112"><span class="nav-number">11.1.2.</span> <span class="nav-text">1.1.2 元组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section113"><span class="nav-number">11.1.3.</span> <span class="nav-text">1.1.3 数组切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section114"><span class="nav-number">11.1.4.</span> <span class="nav-text">1.1.4 循环与遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section115"><span class="nav-number">11.1.5.</span> <span class="nav-text">1.1.5 魔术方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section12"><span class="nav-number">11.2.</span> <span class="nav-text">1.2 字典</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section121"><span class="nav-number">11.2.1.</span> <span class="nav-text">1.2.1 初始化字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section122"><span class="nav-number">11.2.2.</span> <span class="nav-text">1.2.2 查询字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section123"><span class="nav-number">11.2.3.</span> <span class="nav-text">1.2.3 遍历字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section124"><span class="nav-number">11.2.4.</span> <span class="nav-text">1.2.4 字典的魔术方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section125"><span class="nav-number">11.2.5.</span> <span class="nav-text">1.2.5 集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section13"><span class="nav-number">11.3.</span> <span class="nav-text">1.3 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section131"><span class="nav-number">11.3.1.</span> <span class="nav-text">1.3.1 字符串编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section132"><span class="nav-number">11.3.2.</span> <span class="nav-text">1.3.2 字符串的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section133"><span class="nav-number">11.3.3.</span> <span class="nav-text">1.3.3 字符串格式化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section134heredoc"><span class="nav-number">11.3.4.</span> <span class="nav-text">1.3.4 HereDoc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section2"><span class="nav-number">12.</span> <span class="nav-text">2 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section21"><span class="nav-number">12.1.</span> <span class="nav-text">2.1 函数是一等公民</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section22"><span class="nav-number">12.2.</span> <span class="nav-text">2.2 函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section221"><span class="nav-number">12.2.1.</span> <span class="nav-text">2.2.1 函数传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section222"><span class="nav-number">12.2.2.</span> <span class="nav-text">2.2.2 默认参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section223"><span class="nav-number">12.2.3.</span> <span class="nav-text">2.2.3 多参数传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section224"><span class="nav-number">12.2.4.</span> <span class="nav-text">2.2.4 参数分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section23"><span class="nav-number">12.3.</span> <span class="nav-text">2.3 函数内省</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section24"><span class="nav-number">12.4.</span> <span class="nav-text">2.4 装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section241"><span class="nav-number">12.4.1.</span> <span class="nav-text">2.4.1 设计模式的消亡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section242"><span class="nav-number">12.4.2.</span> <span class="nav-text">2.4.2 装饰器的基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section243"><span class="nav-number">12.4.3.</span> <span class="nav-text">2.4.3 装饰器进阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section244"><span class="nav-number">12.4.4.</span> <span class="nav-text">2.4.4 装饰器工厂</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section3"><span class="nav-number">13.</span> <span class="nav-text">3 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section31"><span class="nav-number">13.1.</span> <span class="nav-text">3.1 对象内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section311"><span class="nav-number">13.1.1.</span> <span class="nav-text">3.1.1 对象不是盒子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section312"><span class="nav-number">13.1.2.</span> <span class="nav-text">3.1.2 默认浅复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section313"><span class="nav-number">13.1.3.</span> <span class="nav-text">3.1.3 弱引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section32python"><span class="nav-number">13.2.</span> <span class="nav-text">3.2 Python 风格的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section321"><span class="nav-number">13.2.1.</span> <span class="nav-text">3.2.1 静态函数与类方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section322attribute"><span class="nav-number">13.2.2.</span> <span class="nav-text">3.2.2 属性 attribute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section323property"><span class="nav-number">13.2.3.</span> <span class="nav-text">3.2.3 特性 property</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section324"><span class="nav-number">13.2.4.</span> <span class="nav-text">3.2.4 特性工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section325"><span class="nav-number">13.2.5.</span> <span class="nav-text">3.2.5 属性描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section326"><span class="nav-number">13.2.6.</span> <span class="nav-text">3.2.6 实例属性的查找顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section33"><span class="nav-number">13.3.</span> <span class="nav-text">3.3 多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section331"><span class="nav-number">13.3.1.</span> <span class="nav-text">3.3.1 多继承的必要性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section332python"><span class="nav-number">13.3.2.</span> <span class="nav-text">3.3.2 Python 的多继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section333mixin"><span class="nav-number">13.3.3.</span> <span class="nav-text">3.3.3 Mixin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section334"><span class="nav-number">13.3.4.</span> <span class="nav-text">3.3.4 抽象类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section34"><span class="nav-number">13.4.</span> <span class="nav-text">3.4 元编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section341"><span class="nav-number">13.4.1.</span> <span class="nav-text">3.4.1 类工厂函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section342"><span class="nav-number">13.4.2.</span> <span class="nav-text">3.4.2 元类的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section343"><span class="nav-number">13.4.3.</span> <span class="nav-text">3.4.3 元类的使用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section4"><span class="nav-number">14.</span> <span class="nav-text">4. 流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section41else"><span class="nav-number">14.1.</span> <span class="nav-text">4.1 else</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section411forelse"><span class="nav-number">14.1.1.</span> <span class="nav-text">4.1.1 for else</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section412whileelse"><span class="nav-number">14.1.2.</span> <span class="nav-text">4.1.2 while else</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section413tryelse"><span class="nav-number">14.1.3.</span> <span class="nav-text">4.1.3 try else</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section42"><span class="nav-number">14.2.</span> <span class="nav-text">4.2 迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section421"><span class="nav-number">14.2.1.</span> <span class="nav-text">4.2.1 迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section422"><span class="nav-number">14.2.2.</span> <span class="nav-text">4.2.2 可迭代对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section423__iter__"><span class="nav-number">14.2.3.</span> <span class="nav-text">4.2.3 \__iter__ 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section424"><span class="nav-number">14.2.4.</span> <span class="nav-text">4.2.4 标准迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section425"><span class="nav-number">14.2.5.</span> <span class="nav-text">4.2.5 初识生成器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section43"><span class="nav-number">14.3.</span> <span class="nav-text">4.3 生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section431"><span class="nav-number">14.3.1.</span> <span class="nav-text">4.3.1 生成器的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section432"><span class="nav-number">14.3.2.</span> <span class="nav-text">4.3.2 生成器表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section433"><span class="nav-number">14.3.3.</span> <span class="nav-text">4.3.3 协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section434"><span class="nav-number">14.3.4.</span> <span class="nav-text">4.3.4 预激协程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section435"><span class="nav-number">14.3.5.</span> <span class="nav-text">4.3.5 标准库中的生成器函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section44"><span class="nav-number">14.4.</span> <span class="nav-text">4.4 上下文管理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section441with"><span class="nav-number">14.4.1.</span> <span class="nav-text">4.4.1 with 块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section442"><span class="nav-number">14.4.2.</span> <span class="nav-text">4.4.2 自定义上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section443"><span class="nav-number">14.4.3.</span> <span class="nav-text">4.4.3 标准库中的上下文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section5python"><span class="nav-number">15.</span> <span class="nav-text">5. 其他 Python 特色</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section51gil"><span class="nav-number">15.1.</span> <span class="nav-text">5.1 多线程与GIL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section511"><span class="nav-number">15.1.1.</span> <span class="nav-text">5.1.1 多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section512"><span class="nav-number">15.1.2.</span> <span class="nav-text">5.1.2 线程锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section513gil"><span class="nav-number">15.1.3.</span> <span class="nav-text">5.1.3 GIL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section514"><span class="nav-number">15.1.4.</span> <span class="nav-text">5.1.4 多进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section52python"><span class="nav-number">15.2.</span> <span class="nav-text">5.2 我眼中的  Python</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section521python"><span class="nav-number">15.2.1.</span> <span class="nav-text">5.2.1 Python 是动态强类型语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section522"><span class="nav-number">15.2.2.</span> <span class="nav-text">5.2.2 开发效率高</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section523"><span class="nav-number">15.2.3.</span> <span class="nav-text">5.2.3 对新人不是很友好</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section53python"><span class="nav-number">15.3.</span> <span class="nav-text">5.3 其它 Python 技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section531"><span class="nav-number">15.3.1.</span> <span class="nav-text">5.3.1 文件读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section532json"><span class="nav-number">15.3.2.</span> <span class="nav-text">5.3.2 JSON 读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section533shell"><span class="nav-number">15.3.3.</span> <span class="nav-text">5.3.3 执行 Shell</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section54python"><span class="nav-number">15.4.</span> <span class="nav-text">5.4 Python 模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section541python"><span class="nav-number">15.4.1.</span> <span class="nav-text">5.4.1 Python 中的模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section542"><span class="nav-number">15.4.2.</span> <span class="nav-text">5.4.2 模块查找顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section543__init__py"><span class="nav-number">15.4.3.</span> <span class="nav-text">5.4.3 包与 \__init__.py</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section554"><span class="nav-number">15.4.4.</span> <span class="nav-text">5.5.4 相对导入和绝对导入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section545python"><span class="nav-number">15.4.5.</span> <span class="nav-text">5.4.5 运行 Python 脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section55venv"><span class="nav-number">15.5.</span> <span class="nav-text">5.5 venv</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section551venv"><span class="nav-number">15.5.1.</span> <span class="nav-text">5.5.1 什么是 venv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section552venv"><span class="nav-number">15.5.2.</span> <span class="nav-text">5.5.2 venv 结构初探</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section553"><span class="nav-number">15.5.3.</span> <span class="nav-text">5.5.3 工作原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section6"><span class="nav-number">16.</span> <span class="nav-text">6 学习方向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section7"><span class="nav-number">17.</span> <span class="nav-text">7 版本历史</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section100"><span class="nav-number">17.0.1.</span> <span class="nav-text">1.0.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section101"><span class="nav-number">17.0.2.</span> <span class="nav-text">1.0.1</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section"><span class="nav-number">18.</span> <span class="nav-text">参考资料：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section0"><span class="nav-number">19.</span> <span class="nav-text">0. 准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section1"><span class="nav-number">20.</span> <span class="nav-text">1. 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section11"><span class="nav-number">20.1.</span> <span class="nav-text">1.1 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section111"><span class="nav-number">20.1.1.</span> <span class="nav-text">1.1.1 列表推导</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section112"><span class="nav-number">20.1.2.</span> <span class="nav-text">1.1.2 元组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section113"><span class="nav-number">20.1.3.</span> <span class="nav-text">1.1.3 数组切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section114"><span class="nav-number">20.1.4.</span> <span class="nav-text">1.1.4 循环与遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section115"><span class="nav-number">20.1.5.</span> <span class="nav-text">1.1.5 魔术方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section12"><span class="nav-number">20.2.</span> <span class="nav-text">1.2 字典</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section121"><span class="nav-number">20.2.1.</span> <span class="nav-text">1.2.1 初始化字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section122"><span class="nav-number">20.2.2.</span> <span class="nav-text">1.2.2 查询字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section123"><span class="nav-number">20.2.3.</span> <span class="nav-text">1.2.3 遍历字典</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section124"><span class="nav-number">20.2.4.</span> <span class="nav-text">1.2.4 字典的魔术方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section125"><span class="nav-number">20.2.5.</span> <span class="nav-text">1.2.5 集合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section13"><span class="nav-number">20.3.</span> <span class="nav-text">1.3 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section131"><span class="nav-number">20.3.1.</span> <span class="nav-text">1.3.1 字符串编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section132"><span class="nav-number">20.3.2.</span> <span class="nav-text">1.3.2 字符串的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section133"><span class="nav-number">20.3.3.</span> <span class="nav-text">1.3.3 字符串格式化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section134heredoc"><span class="nav-number">20.3.4.</span> <span class="nav-text">1.3.4 HereDoc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section2"><span class="nav-number">21.</span> <span class="nav-text">2 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section21"><span class="nav-number">21.1.</span> <span class="nav-text">2.1 函数是一等公民</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section22"><span class="nav-number">21.2.</span> <span class="nav-text">2.2 函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section221"><span class="nav-number">21.2.1.</span> <span class="nav-text">2.2.1 函数传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section222"><span class="nav-number">21.2.2.</span> <span class="nav-text">2.2.2 默认参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section223"><span class="nav-number">21.2.3.</span> <span class="nav-text">2.2.3 多参数传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section224"><span class="nav-number">21.2.4.</span> <span class="nav-text">2.2.4 参数分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section23"><span class="nav-number">21.3.</span> <span class="nav-text">2.3 函数内省</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section24"><span class="nav-number">21.4.</span> <span class="nav-text">2.4 装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section241"><span class="nav-number">21.4.1.</span> <span class="nav-text">2.4.1 设计模式的消亡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section242"><span class="nav-number">21.4.2.</span> <span class="nav-text">2.4.2 装饰器的基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section243"><span class="nav-number">21.4.3.</span> <span class="nav-text">2.4.3 装饰器进阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section244"><span class="nav-number">21.4.4.</span> <span class="nav-text">2.4.4 装饰器工厂</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section3"><span class="nav-number">22.</span> <span class="nav-text">3 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#section31"><span class="nav-number">22.1.</span> <span class="nav-text">3.1 对象内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section311"><span class="nav-number">22.1.1.</span> <span class="nav-text">3.1.1 对象不是盒子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section312"><span class="nav-number">22.1.2.</span> <span class="nav-text">3.1.2 默认浅复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section313"><span class="nav-number">22.1.3.</span> <span class="nav-text">3.1.3 弱引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section32python"><span class="nav-number">22.2.</span> <span class="nav-text">3.2 Python 风格的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section321"><span class="nav-number">22.2.1.</span> <span class="nav-text">3.2.1 静态函数与类方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section322attribute"><span class="nav-number">22.2.2.</span> <span class="nav-text">3.2.2 属性 attribute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section323property"><span class="nav-number">22.2.3.</span> <span class="nav-text">3.2.3 特性 property</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section324"><span class="nav-number">22.2.4.</span> <span class="nav-text">3.2.4 特性工厂</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section325"><span class="nav-number">22.2.5.</span> <span class="nav-text">3.2.5 属性描述符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section326"><span class="nav-number">22.2.6.</span> <span class="nav-text">3.2.6 实例属性的查找顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section33"><span class="nav-number">22.3.</span> <span class="nav-text">3.3 多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#section331"><span class="nav-number">22.3.1.</span> <span class="nav-text">3.3.1 多继承的必要性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#section332python"><span class="nav-number">22.3.2.</span> <span class="nav-text">3.3.2 Python 的多继承</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Micah</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="lvchenqiang.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="lvchenqiang.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="lvchenqiang.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="lvchenqiang.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lvchenqiang.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="lvchenqiang.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="lvchenqiang.github.io/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="lvchenqiang.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="lvchenqiang.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="lvchenqiang.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="lvchenqiang.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="lvchenqiang.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="lvchenqiang.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="lvchenqiang.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Micah.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://lvchenqiang.github.io/2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/';
          this.page.identifier = '2019/01/26/谁是谷歌想要的人才/Python 简单入门指北 － 小专栏/';
          this.page.title = '';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Micah.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  












  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'ob6xEevaCzifOdzvnfIrxSJ7-gzGzoHsz',
        appKey: 'ibWrHDRgAsLSxr5UnNH7Tb2n',
        placeholder: 'ヾﾉ≧∀≦)o来啊，快活啊!',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
